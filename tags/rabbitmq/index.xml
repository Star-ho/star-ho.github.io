<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RabbitMQ on Sungho's Dev BLog</title><link>https://sungho94.me/tags/rabbitmq/</link><description>Recent content in RabbitMQ on Sungho's Dev BLog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Thu, 15 Aug 2024 23:32:47 +0000</lastBuildDate><atom:link href="https://sungho94.me/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml"/><item><title>AMQP, MQTT, and STOMP</title><link>https://sungho94.me/p/amqp-mqtt-and-stomp/</link><pubDate>Thu, 15 Aug 2024 23:32:47 +0000</pubDate><guid>https://sungho94.me/p/amqp-mqtt-and-stomp/</guid><description>&lt;h2 id="웹에서-실시간-상효작용을-위한-접근법">웹에서 실시간 상효작용을 위한 접근법
&lt;/h2>&lt;ul>
&lt;li>Polling
&lt;ul>
&lt;li>브라우저에서 반복적으로 서버를 호출하여 새로운 데이터가 있는지 확인함&lt;/li>
&lt;li>효율적이지 못하며, 데이터 변경이 빈번하지 않을때 필요없는 요청이 너무 많이 발생함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server-Sent Envent(SSEs)
&lt;ul>
&lt;li>폴링처럼 주기적으로 서버를 호출하는 대신, 개방형 연결(open connection)을 유지하여 서버가 데이터를 사용할 수 있을때, 클라이언트로 데이터를 전송함&lt;/li>
&lt;li>불필요한 여러 요청과 응답으로 인한 오버헤드를 줄일 수 있음&lt;/li>
&lt;li>SSE의 주요단점은 단방향임&lt;/li>
&lt;li>서버는 데이터를 푸시할 수 있지만, 클라이언트는 동일한 연결을 통해 응답할 수 없기에, SSE는 일방적인 서버 업데이터에 이상적임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>WebSocket
&lt;ul>
&lt;li>데이터를 반복적으로 요청하는 대신, 브라오저와 서버간에 통신라인을 열어둠&lt;/li>
&lt;li>이로인해 웹소켓은 양방향 통신을 가능하게함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="mqtt-message-queuing-telemetry-transport">MQTT (Message Queuing Telemetry Transport)
&lt;/h2>&lt;ul>
&lt;li>배경
&lt;ul>
&lt;li>과거에는 거대한 외딴 지역의 데이터를 모니터링을 하는데 어려움이 있었음&lt;/li>
&lt;li>불안정하고 대역폭이 낮은 네트워크, 모니터링 장치는 배터리로 작동하기 때문에 에너지절약이 필수적이 었음&lt;/li>
&lt;li>이로인해 지속적인 통신이나 높은 네트워크 사용은 실용적이지 않았음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Light weight
&lt;ul>
&lt;li>MQTT는 간결한 메시지와 컴팩트한 페이로드를 사용하여 네트워크를 통해 전송해야 하는 데이터 양을 줄인 최소한의 프로토콜로 설계됨&lt;/li>
&lt;li>pub/sub이라는 단 하나의 메시지 패턴에만 집중함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>QoS
&lt;ul>
&lt;li>QoS레벨이 존재, 메시지 게시 시 QoS수준을 선택할 수 있음&lt;/li>
&lt;li>QoS 0은 대역폭 사용량이 낮지만, 전송 보장도 낮음&lt;/li>
&lt;li>QoS 2는 가장 높은 대역폭 사용량과 가장 높은 전송 보장을 제공&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Last Will and Testament
&lt;ul>
&lt;li>연결의 불안정한 특성을 고려할때, 예기치 않은 연결이 발생할때 브로커가 전송한 last will(마지막 유언)을 설정할 수 있음&lt;/li>
&lt;li>이 정보를 통해, subscriber는 유연한 대처가 가능함&lt;/li>
&lt;li>일반적으로 connection time에 클라이언트에 의해 지정됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Retained Message
&lt;ul>
&lt;li>MQTT브로커는 Topic에 대해 마지막으로 알려진 메시지를 유지하여, 다운타임후 온라인 상태가 된 모든 드바이스다 즉시 최신메시지를 받을수 있도록 보장함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위와 같은 특성에서 MQTT는 다양한 시나리오에서 사용가능했음&lt;/li>
&lt;li>현재 IoT 사용시에 이상적인 선택임&lt;/li>
&lt;/ul>
&lt;h2 id="amqp-advanced-message-queuing-protocol">AMQP (Advanced Message Queuing Protocol)
&lt;/h2>&lt;ul>
&lt;li>모든 벤더가 구현할수 있는 프로토콜을 통해 서로 다른 시스템과 제품간의 상호 운영성을 보장한다는 비전을 바탕으로 탄생함&lt;/li>
&lt;li>Open Standard
&lt;ul>
&lt;li>처음부터 개방형 표준으로 설계되었기에, 사양을 공개적으로 사용 가능함&lt;/li>
&lt;li>모든 벤더나 개발자는 이러한 사양을 사용하여 제품이나 시스템에 AMQP를 구현할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Reliable Message Deliveries
&lt;ul>
&lt;li>신뢰성을 보장하는 주요 메커니즘 중 하나는 승인임&lt;/li>
&lt;li>메시지가 소비되면 브로커에게 확인을 전송하여 메시지가 처리되었음을 확인함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Flexibility
&lt;ul>
&lt;li>메시지가 먼저 Exchange로 이동한 다음 Queue로 이동함&lt;/li>
&lt;li>Queue는 특정 패턴이나 기준에 따라 Exchange에 바인딩됨&lt;/li>
&lt;li>이러한 바인딩 메커니즘은 다양한 Exchange유형과 결함되어 복잡한 라우팅 로직을 가능하게함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="stomp-simple-text-oriented-messaging-protocol">STOMP (Simple Text Oriented Messaging Protocol)
&lt;/h2>&lt;ul>
&lt;li>쉽게 구현하고 이해할 수 있는, 단순한 것을 만들기 위해 탄생함&lt;/li>
&lt;li>Simplicity
&lt;ul>
&lt;li>미니멀리즘 방식으로 설계됨&lt;/li>
&lt;li>기능이 많은 프로토컬의 오버헤드와 복잡성 없이 메시징에 필요한 기본 기능만 제공&lt;/li>
&lt;li>아래와 같은 간단한 명령과 클래스가 존재함
&lt;ul>
&lt;li>Few Command
&lt;ul>
&lt;li>CONNECT, CONNECTED, SEND, SUBSCRIBE, UNSUBSCRIBE, BEGIN, COMMIT, ABORT, ACK, NACK, MESSAGE, CRECEIPT, ERROR&lt;/li>
&lt;li>풍부한 메서드 집합을 가진 AMQP와 대조됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Connection Class
&lt;ul>
&lt;li>Start, Start-Ok, Secure, Secure-Ok, Tune, Tune-Ok, Open, Open-Ok, Close, Close-Ok&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Channel Class
&lt;ul>
&lt;li>Open, Open-Ok, Flow, Flow-Ok, Close, Close-Ok&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>적은 상태관리
&lt;ul>
&lt;li>STOMP는 상태저장기능이 있지만, AMQP는 세부적인 상태 관리 기능이 없음&lt;/li>
&lt;li>AMQP는 Exchange, Queue, Binding등 다양한 속성을 지정하는 작업이 필요함&lt;/li>
&lt;li>STOMP는 대상에게 메시지를 보내기만 하면 브로커가 세부사항을 처리함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Fewer Feature By Design
&lt;ul>
&lt;li>STOMP는 일반적으로 메시징의 기본을 잘처리하는 것을 목표로 하며, AMQP에 있는 많은 고급 기능은 없거나, 더 높은 수준에서 구현됨&lt;/li>
&lt;li>사용관점 뿐만 아니라 클라이언트 구현 관점에서도 STOMP를 단순하게 만듬&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Text-Oriented
&lt;ul>
&lt;li>텍스트 기반이라 이해하고 디버깅하기 쉬움&lt;/li>
&lt;li>원시 STOMP프레임을 보면 HTTP처럼 사람이 읽을 . 수있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.cloudamqp.com/blog/rabbitmq-and-websockets-part-1-amqp-mqtt-stomp.html" target="_blank" rel="noopener"
>https://www.cloudamqp.com/blog/rabbitmq-and-websockets-part-1-amqp-mqtt-stomp.html&lt;/a>&lt;/p></description></item><item><title>Exchange and binding</title><link>https://sungho94.me/p/exchange-and-binding/</link><pubDate>Thu, 15 Aug 2024 20:35:20 +0000</pubDate><guid>https://sungho94.me/p/exchange-and-binding/</guid><description>&lt;h2 id="exchange">Exchange
&lt;/h2>&lt;ul>
&lt;li>다양한 속성을 설정할 수 있음&lt;/li>
&lt;li>가장 중요한 옵션은 name, durablity, auto-delete(마지막 대기열이 해해제되면 자동 삭제됨), argument 임&lt;/li>
&lt;/ul>
&lt;h3 id="default-exchange">Default Exchange
&lt;/h3>&lt;ul>
&lt;li>브로커가 미리 선언한 이름이 없는 direct exchange&lt;/li>
&lt;li>간단한 애플리케이션에 매우 유용한 한가지 속성이 있는데, 생성되는 모든 큐는 큐 이름과 동일한 라우팅 키를 사용하여 자동으로 바인딩됨&lt;/li>
&lt;li>예를 들어 &amp;ldquo;search-indexing-online&amp;quot;이름의 큐를 선언하는 브로커는 &amp;ldquo;search-indexing-online&amp;quot;를 사용하여 기본 exchange에 해당 큐를 바인딩함&lt;/li>
&lt;/ul>
&lt;h3 id="direct-exchange">Direct Exchange
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240812233351.png"
loading="lazy"
alt="|center|700"
>&lt;/p>
&lt;ul>
&lt;li>메시지 라우팅 키를 기반으로 메시지를 대기열에 전달함&lt;/li>
&lt;li>메시지의 유니캐스트 라우팅에 이상적이지만, 멀티캐스트 라우팅에도 사용 가능함&lt;/li>
&lt;li>라우팅 키 K를 가진 queue가 라우팅 R을 가진 새 메시지가 direct exchange에 도착하면 교환은 K=R인경우 해당 대기열로 라우팅함&lt;/li>
&lt;li>동일한 라우팅 키 K를 가진 direct exchange가 여러개 있으면, Exchange는 K=R인 모든 대기열에 라우팅함&lt;/li>
&lt;/ul>
&lt;h3 id="fanout-exchange">Fanout Exchange
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240812233932.png"
loading="lazy"
alt="|center|700"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>바인딩된 모든 대기열로 메시지를 라우팅하며, 라우팅 키는 무시됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>N개의 queue가 Fanout Exchange에 바인딩 되어 있는경우, 새 메시지가 Exchange에 publish되면, 메시지의 사본이 모든 N개의 대기열에 전달됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>브로드 캐스트 라우팅에 이상적임&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Fanout Exchange는 바인딩된 모든 queue에 메시지 사본을 전달하므로 사용 사례는 다들 비슷함&lt;/p>
&lt;ul>
&lt;li>대규모 멀티 온라인 게임에서 순위표 업데이트&lt;/li>
&lt;li>스포츠 뉴스 사이트에서 실시간으로 모바일 클라이언트에 점수 업데이트를 하는데 사용할 수 있음&lt;/li>
&lt;li>분산 시스템에서 다양한 상태 및 구성 업데이트에 사용될 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="topic-exchange">Topic Exchange
&lt;/h3>&lt;ul>
&lt;li>라우팅 키와 대기열을 exchange에 바인딩하는데 사용된 패턴의 일치 여부에 따라 메시지를 하나 또는 여러개의 대기열로 라우팅함&lt;/li>
&lt;li>다양한 pub/sub패턴을 구현하는데 자주 사용됨&lt;/li>
&lt;li>일반적으로 멀티 캐스트 라우팅에 사용됨&lt;/li>
&lt;li>수신할 메시지 유형을 선택적으로 선택하는 여러 소비자/애플리케이션에 관련된 문제가 있을 떄마다 고려할 필요가 있음&lt;/li>
&lt;/ul>
&lt;h3 id="headers-exchange">Headers Exchange
&lt;/h3>&lt;ul>
&lt;li>라우팅 키 보다는 메시지 헤더로 더 쉽게 표현되는 여러 속성에 대한 라우팅을 위해 설계됨&lt;/li>
&lt;li>Headers Exchange는 라우팅 키속성을 무시함&lt;/li>
&lt;li>라우팅에 사용되는 속성을 헤더에서 가져옴&lt;/li>
&lt;li>헤더의 값이 바인딩시 지정된 값과 같으면 바인딩함&lt;/li>
&lt;li>일치하는 헤더를 2개이상 사용하여 대기열을 헤더 교환에 바인딩 할 수 있음&lt;/li>
&lt;li>브로커는 애플리케이션으로 부터 모두 일치 또는 일부만 일치하는 메시지를 고려햐기 위해 x-match 인수가 사용됨
&lt;ul>
&lt;li>x-match가 all이면 모든 값이 일치해야함&lt;/li>
&lt;li>x-match가 any면 하나라도 일치하면 됨&lt;/li>
&lt;li>x-match를 any-with-x또는 all-with-x로 설정하면 문자열 x-로 시작하는 헤더도 일치항목을 평가하는데 사용됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="binding">Binding
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>Exchange에서 메시지를 Queue로 라우팅 하기 위해 사용하는 규칙&lt;/p>
&lt;/li>
&lt;li>
&lt;p>일부 Exchange 유형해서 사용하는 라우팅 키 속성이 있을 수 있고, Exchange E가 메시지를 Queue Q로 라우팅하도록 지시하려면, Q를 E에 바인딩해야함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>라우팅 키의 목적은 Exchange에 publish된 특정 메시지를 바인딩된 Queue로 라우팅하도록 선택하는것&lt;/p>
&lt;/li>
&lt;li>
&lt;p>라우팅 키는 필터와 같은 역할을함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>이러한 방향지정 계층이 있으면 publishing을 직접 사용하여 구현하기 불가능하거나 매우 어려운 시나리오에 대해 Queue를 라우팅 할 수 있으면 중복작업이 줄어듬&lt;/p>
&lt;/li>
&lt;li>
&lt;p>메시지가 어떤 Queue로도 라우팅 할 수 없는경우, publisher가 설정한 메시지 특성에 따라 메시지가 삭제되거나, publisher에게 되돌아감&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Queue</title><link>https://sungho94.me/p/queue/</link><pubDate>Thu, 15 Aug 2024 20:34:36 +0000</pubDate><guid>https://sungho94.me/p/queue/</guid><description>&lt;h2 id="queue">Queue
&lt;/h2>&lt;ul>
&lt;li>애플리케이션에서 소비되는 메시지를 저장하는 장소&lt;/li>
&lt;li>Queue는 일부 속성을 Exchange와 공유하지만, 몇가지 추가 속성이 있음
&lt;ul>
&lt;li>Name
&lt;ul>
&lt;li>256바이트의 UTF-8문자로 구성함&lt;/li>
&lt;li>빈 문자열을 전달시, AMQP 0-9-1 브로커는 고유한 대기열 이름을 생성함&lt;/li>
&lt;li>amq. 로 시작하는 대기열은 브로커 내부용으로 예약되어 있음
&lt;ul>
&lt;li>이 규칙을 위반하면 코드 403의 예외가 발생함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Durable(브로커 재시작 후에도 큐가 유지됨)
&lt;ul>
&lt;li>durable한지 transient한지 선언할 수 있음&lt;/li>
&lt;li>durable하다면 Queue의 메타데이터는 디스크에 저장되고, transient하다면 가능한경우 메모리에 저장됨
&lt;ul>
&lt;li>publish된 메시지도 동일&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Exclusive(하나의 연결에서만 사용되며, 해당 연결이 닫히면 큐가 삭제됨)&lt;/li>
&lt;li>Auto-delete(큐에 연결된 모든 소비자가 연결을 끊으면 자동으로 삭제됨)&lt;/li>
&lt;li>Arguemnt(optional, 메시지 TTL, 큐길이 제한과 같은 플러그인 및 브로커별 기능에서 사용)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Queue를 사용하려면 Queue을 선언해야함&lt;/li>
&lt;li>Queue를 선언하면, Queue가 존재하지 않을경우 생성
&lt;ul>
&lt;li>Queue가 이미 존재하고 속성이 동일할경우 아무 영향을 끼치지 않음&lt;/li>
&lt;li>속성이 다른경우, 코드 406의 예외가 발생함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>AMQP 0-9-1 Model</title><link>https://sungho94.me/p/amqp-0-9-1-model/</link><pubDate>Mon, 12 Aug 2024 23:17:42 +0000</pubDate><guid>https://sungho94.me/p/amqp-0-9-1-model/</guid><description>&lt;h2 id="amqp-0-9-1">AMQP 0-9-1
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>적합한 클라이언트 애플리케이션이 적합한 메시징 미들웨어 브로커와 통신할수 있도록 하는 메시징 프로토콜&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Message Broker는 publisher에게 메시지를 받아 consumer에게 라우팅함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>네트워크 프로토콜 이므로 broker, publisher, consumer는 다른 시스템에 존재할 수 있음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>메시지는 우체국이나 우편함에 비유되는 Exchange에 publish됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Exchange는 Binding이라는 규칙을 사용하여 메시지 사본을 대기열에 배포함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>broker는 Queue를 subscribe하는 consumer에게 메시지를 전달하건, consumer가 필요에따라 queue에서 메서지를 fetch/pull함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>메시지를 publishing할때, publisher는 다양한 메시지 속성을 지정할 수 있음&lt;/p>
&lt;ul>
&lt;li>일부는 브로커에서 사용할 수 있지만, 나머지는 브로커가 볼 수 없으며, 메시지를 수신하는 애플리케이션에서만 사용됨&lt;/li>
&lt;li>네트워크가 불안정하고, 어플리케이션이 메시지를 처리할 수 없을 수 있으므로 AMQP 0-9-1 모델에는 message acknowledgements라는 개념이 있음&lt;/li>
&lt;li>메시지가 소비자에게 전달되면, 소비자는 자동 또는 개발자의 선택에 따라 큐에 알림&lt;/li>
&lt;li>메시지 확인이 사용중일때, 브로커는 해당 메시지 알림을 수신할때만 큐에서 해당 메시지를 완전히 제거함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메시지가 라우팅을 확장할 수 없는경우, 특정 상황에서는 메시지가 publisher에게 반환되거나, 삭제되거나 dead letter queue에 쌓일 수 있음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>queue, exchanges, binding은 AMQP엔티티임&lt;/p>
&lt;/li>
&lt;li>
&lt;p>AMQP 엔티티는 broker 관리자 뿐만이 아니라, application에서 정의되어질 수 있기에 프로그래밍 가능한 protocol임&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="method">Method
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>HTTP메서드와 유사하게, AMQP는 몇개의 메서드가 구성되어 있음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>exchange.declare&lt;/p>
&lt;/li>
&lt;li>
&lt;p>exchange.declare-ok&lt;/p>
&lt;/li>
&lt;li>
&lt;p>exchange.delete&lt;/p>
&lt;/li>
&lt;li>
&lt;p>exchange.delete-ok&lt;/p>
&lt;/li>
&lt;li>
&lt;p>publisher나 consumer가 해당 메시지를 보내, exchange, queue, binding을 생성할 수 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.rabbitmq.com/tutorials/amqp-concepts" target="_blank" rel="noopener"
>https://www.rabbitmq.com/tutorials/amqp-concepts&lt;/a>&lt;/p></description></item><item><title>Broker</title><link>https://sungho94.me/p/broker/</link><pubDate>Sat, 10 Aug 2024 23:49:41 +0000</pubDate><guid>https://sungho94.me/p/broker/</guid><description>&lt;h2 id="broker-관련-설정-메시지-브로커-설정-심층-분석">Broker 관련 설정: 메시지 브로커 설정 심층 분석
&lt;/h2>&lt;p>&lt;strong>Broker&lt;/strong>는 메시지 중개자 역할을 수행하며, Producer와 Consumer 간의 메시지 전달을 책임지는 핵심적인 구성 요소입니다. Broker의 설정은 시스템의 성능, 안정성, 확장성에 직접적인 영향을 미치므로 신중하게 설정해야 합니다.&lt;/p>
&lt;h3 id="주요-broker-설정-항목">주요 Broker 설정 항목
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Network 설정:&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Binding:&lt;/strong> 어떤 Queue에 어떤 Exchange를 바인딩할지 설정&lt;/li>
&lt;li>&lt;strong>Virtual Host:&lt;/strong> 논리적인 분리된 환경 구성&lt;/li>
&lt;li>&lt;strong>Clustering:&lt;/strong> 여러 Broker를 연결하여 클러스터 구성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Queue 설정:&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Durability:&lt;/strong> Queue의 지속성 설정 (메시지 유실 방지)&lt;/li>
&lt;li>&lt;strong>Auto-delete:&lt;/strong> 더 이상 사용되지 않는 Queue 자동 삭제&lt;/li>
&lt;li>&lt;strong>Exclusive:&lt;/strong> 단독 소비자만 접근 가능하게 설정&lt;/li>
&lt;li>&lt;strong>Message TTL:&lt;/strong> 메시지 유효 기간 설정&lt;/li>
&lt;li>&lt;strong>Dead-Letter Exchange:&lt;/strong> 처리 실패 메시지를 보낼 DLX 설정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Exchange 설정:&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Type:&lt;/strong> Direct, Fanout, Topic, Headers 등 Exchange 타입 설정&lt;/li>
&lt;li>&lt;strong>Durability:&lt;/strong> Exchange의 지속성 설정&lt;/li>
&lt;li>&lt;strong>Auto-delete:&lt;/strong> 더 이상 사용되지 않는 Exchange 자동 삭제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Message 설정:&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Message Size:&lt;/strong> 최대 메시지 크기 설정&lt;/li>
&lt;li>&lt;strong>Message TTL:&lt;/strong> 메시지 유효 기간 설정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Performance 설정:&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Prefetch Count:&lt;/strong> 소비자가 미리 가져올 메시지 수 설정&lt;/li>
&lt;li>&lt;strong>Concurrency:&lt;/strong> 동시에 처리할 메시지 수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Security 설정:&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Authentication:&lt;/strong> 인증 메커니즘 설정&lt;/li>
&lt;li>&lt;strong>Authorization:&lt;/strong> 권한 관리 설정&lt;/li>
&lt;li>&lt;strong>SSL/TLS:&lt;/strong> 보안 통신 설정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>Monitoring 설정:&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Metrics:&lt;/strong> 메트릭 수집 (메시지 처리량, 지연 시간 등)&lt;/li>
&lt;li>&lt;strong>Logging:&lt;/strong> 로그 설정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="broker-선택-시-고려-사항">Broker 선택 시 고려 사항
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>기능:&lt;/strong> 필요한 기능 (Durable, Transactional, Exactly-Once Delivery 등) 지원 여부&lt;/li>
&lt;li>&lt;strong>성능:&lt;/strong> 처리량, 지연 시간 등 성능 요구사항 충족 여부&lt;/li>
&lt;li>&lt;strong>확장성:&lt;/strong> 시스템 부하 증가에 따른 확장성&lt;/li>
&lt;li>&lt;strong>운영 편의성:&lt;/strong> 관리 도구, 모니터링 기능 등&lt;/li>
&lt;li>&lt;strong>커뮤니티:&lt;/strong> 활발한 커뮤니티 지원 여부&lt;/li>
&lt;/ul>
&lt;h3 id="주요-메시지-브로커-종류-및-특징">주요 메시지 브로커 종류 및 특징
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>RabbitMQ:&lt;/strong> 다양한 기능, 높은 확장성, 활발한 커뮤니티&lt;/li>
&lt;li>&lt;strong>Kafka:&lt;/strong> 고성능, 분산 시스템, 스트리밍 처리에 적합&lt;/li>
&lt;li>&lt;strong>ActiveMQ:&lt;/strong> 다양한 프로토콜 지원, 안정성&lt;/li>
&lt;li>&lt;strong>Amazon SQS:&lt;/strong> 클라우드 기반, 쉽고 빠른 설정&lt;/li>
&lt;li>&lt;strong>Google Pub/Sub:&lt;/strong> 클라우드 기반, 스케일링 용이&lt;/li>
&lt;/ul></description></item><item><title>Subscriber</title><link>https://sungho94.me/p/subscriber/</link><pubDate>Sat, 10 Aug 2024 23:37:42 +0000</pubDate><guid>https://sungho94.me/p/subscriber/</guid><description>&lt;h2 id="consumer">Consumer
&lt;/h2>&lt;ul>
&lt;li>에플리케이션이 메시지를 사용할 수 없다면, Queue에 메시지를 저장하는것은 불필요함&lt;/li>
&lt;li>AMQP 0-9-1 모델에는 Subscribe과 Polling이 있음
&lt;ul>
&lt;li>애플리케이션이 메시지를 전달받도록 하는 Subscribe 방식 - 권장 옵션&lt;/li>
&lt;li>비효율적이며 대부분의 경우 피해야하는 Polling 방식&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Push API를 사용하면 애플리케이션이 특정 Queue에 Subscriber를 등록하거나, Queue에 가입해야함&lt;/li>
&lt;li>Queue에 두명 이상의 consumer를 등록하거나, exclude consumer를 등록할 수 있음&lt;/li>
&lt;li>각 consumer는 consumer tag라는 문자열로된 식별자가 존재함
&lt;ul>
&lt;li>이 식별자는 메시지 수신을 취소하는데 사용할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="rejecting-messages">Rejecting Messages
&lt;/h3>&lt;ul>
&lt;li>consumer 애피리케이션이 메시지를 받을 때, 메시지 처리가 성공 할 수도, 실패할 수도 있음&lt;/li>
&lt;li>애플리케이션은 메시지를 거부하므로써 브로커에게 메시직 처리가 실패했음을 알릴 수 있음&lt;/li>
&lt;li>메시지를 거부할 때 브로커에게 메시지를 폐기하거나, 다시 Queue에 넣도록 요청할 수 있음&lt;/li>
&lt;li>대기열에 소비자가 한명 만 있는경우, 동일 소비자의 메시지를 거부했다가 다시 queue에 넣는 무한루프를 만들지 않도록 주의해야함&lt;/li>
&lt;/ul>
&lt;h3 id="prefetching-message">Prefetching Message
&lt;/h3>&lt;ul>
&lt;li>여러 Consumer가 하나의 queue를 공유할때, 다음 ACK를 보내기전에 각 소비자가 한번에 처리할 수 있는 메시지 수를 지정하는것은 유영함&lt;/li>
&lt;li>간단히 부하분산 기술로 사용하거나, 메시지가 일괄적으로 publish되는 경항이 있는경우 처리량 개선에 사용할 수 있음&lt;/li>
&lt;li>예를들어, publisher특성상 매분 메시지를 전송하는 경우 유용함&lt;/li>
&lt;li>RabbitMQ는 채널 레벨 prefetch만 지원하고, 연결 또는 크기기반 prefetch는 지원하지 않음&lt;/li>
&lt;/ul>
&lt;h3 id="기본-설정">기본 설정
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Queue 바인딩:&lt;/strong> 어떤 Queue의 메시지를 받을지 설정&lt;/li>
&lt;li>&lt;strong>Message Listener:&lt;/strong> 메시지를 받아 처리하는 메소드 구현&lt;/li>
&lt;li>&lt;strong>Container Factory:&lt;/strong> 메시지 컨테이너 생성을 위한 팩토리 설정&lt;/li>
&lt;/ul>
&lt;h3 id="고급-설정">고급 설정
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Concurrency:&lt;/strong> 동시에 처리할 메시지 수&lt;/li>
&lt;li>&lt;strong>Error Handling:&lt;/strong> 오류 처리 (Retry, Dead-Letter Exchange, Error Queue, Circuit Breaker)&lt;/li>
&lt;li>&lt;strong>Transaction:&lt;/strong> 트랜잭션 관리&lt;/li>
&lt;li>&lt;strong>Acknowledgment:&lt;/strong> 메시지 처리 확인&lt;/li>
&lt;li>&lt;strong>Prefetch Count:&lt;/strong> 미리 가져올 메시지 수&lt;/li>
&lt;li>&lt;strong>Dead-Letter Exchange:&lt;/strong> 처리 실패 메시지 보낼 DLX 설정&lt;/li>
&lt;li>&lt;strong>Message Converter:&lt;/strong> 메시지 형식 변환&lt;/li>
&lt;/ul>
&lt;h3 id="심화-설정-및-고려사항">심화 설정 및 고려사항
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>메시지 처리 전략:&lt;/strong> Pull vs Push, Batch 처리, Parallel 처리, Message Sequencing, Deduplication, Prioritization, Asynchronous Processing&lt;/li>
&lt;li>&lt;strong>오류 처리 심화:&lt;/strong> Retry Strategies, Circuit Breaker Pattern, Bulkhead Pattern, Resilience4j&lt;/li>
&lt;li>&lt;strong>성능 최적화:&lt;/strong> Batching, Compression, Caching, Profiling&lt;/li>
&lt;li>&lt;strong>확장성:&lt;/strong> Horizontal Scaling, Sharding, Load Balancing&lt;/li>
&lt;li>&lt;strong>보안:&lt;/strong> TLS/SSL, Access Control, Authentication, Authorization&lt;/li>
&lt;li>&lt;strong>모니터링:&lt;/strong> Metrics, Logging, Alerting, Distributed Tracing&lt;/li>
&lt;li>&lt;strong>특수 기능:&lt;/strong> Delayed Messages, Scheduled Messages, Message Routing&lt;/li>
&lt;li>&lt;strong>클라우드 환경:&lt;/strong> Serverless Functions, Managed Messaging Services, Cloud-Native Patterns&lt;/li>
&lt;li>&lt;strong>테스트:&lt;/strong> Unit Test, Integration Test, Chaos Engineering, Mutation Testing&lt;/li>
&lt;li>&lt;strong>패턴:&lt;/strong> Observer Pattern, Strategy Pattern, Actor Model, CQRS&lt;/li>
&lt;/ul>
&lt;h3 id="추가-키워드">추가 키워드
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Consumer Tag:&lt;/strong> 소비자 식별&lt;/li>
&lt;li>&lt;strong>Channel:&lt;/strong> 메시지 채널&lt;/li>
&lt;li>&lt;strong>Ack:&lt;/strong> 메시지 처리 성공 확인&lt;/li>
&lt;li>&lt;strong>Nack:&lt;/strong> 메시지 처리 실패 확인&lt;/li>
&lt;li>&lt;strong>Requeue:&lt;/strong> 메시지 다시 큐에 넣기&lt;/li>
&lt;/ul></description></item><item><title>Publisher</title><link>https://sungho94.me/p/publisher/</link><pubDate>Sat, 10 Aug 2024 23:37:33 +0000</pubDate><guid>https://sungho94.me/p/publisher/</guid><description>&lt;p>지금까지 다룬 Spring Boot Publisher 설정에 대한 핵심 키워드를 정리해 드리겠습니다.&lt;/p>
&lt;h3 id="핵심-설정">핵심 설정
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>RabbitMQ 연결:&lt;/strong> 호스트, 포트, 사용자명, 비밀번호 등 RabbitMQ 서버 연결 정보&lt;/li>
&lt;li>&lt;strong>Exchange:&lt;/strong> Exchange 이름, 타입 (direct, fanout, topic, headers), 내구성, 자동 삭제 여부&lt;/li>
&lt;li>&lt;strong>Queue:&lt;/strong> Queue 이름, 내구성, 독점 여부, 자동 삭제 여부, 인자 (DLX, TTL 등)&lt;/li>
&lt;li>&lt;strong>Binding:&lt;/strong> Exchange와 Queue 바인딩, 라우팅 키&lt;/li>
&lt;li>&lt;strong>Template:&lt;/strong> mandatory, returnCallback, confirmCallback 등&lt;/li>
&lt;li>&lt;strong>ConnectionFactory:&lt;/strong> 연결 팩토리 설정 (커넥션 풀링, 재연결 등)&lt;/li>
&lt;li>&lt;strong>MessageConverter:&lt;/strong> 메시지 변환기 설정 (JSON, XML 등)&lt;/li>
&lt;/ul>
&lt;h3 id="추가-고려-사항">추가 고려 사항
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>메시지 크기 및 속도:&lt;/strong> 대용량 메시지 처리, 고속 메시지 전송&lt;/li>
&lt;li>&lt;strong>메시지 보장:&lt;/strong> 확인, 트랜잭션, QoS&lt;/li>
&lt;li>&lt;strong>보안:&lt;/strong> 인증, 암호화, 접근 제어&lt;/li>
&lt;li>&lt;strong>클러스터링:&lt;/strong> 고가용성, 부하 분산&lt;/li>
&lt;li>&lt;strong>모니터링:&lt;/strong> 메트릭, 로그&lt;/li>
&lt;li>&lt;strong>테스트:&lt;/strong> 단위 테스트, 통합 테스트, Contract Test&lt;/li>
&lt;li>&lt;strong>비동기 처리:&lt;/strong> AsyncRestTemplate, CompletableFuture&lt;/li>
&lt;li>&lt;strong>메시지 형식:&lt;/strong> Custom Message Converter, Schema Registry, Type Conversion&lt;/li>
&lt;li>&lt;strong>확장성:&lt;/strong> Dynamic Routing, Message Expiration, DLX&lt;/li>
&lt;li>&lt;strong>클라우드 환경:&lt;/strong> Cloud-Native Messaging, Kubernetes&lt;/li>
&lt;li>&lt;strong>패턴 및 관례:&lt;/strong> Builder Pattern, Template Method Pattern&lt;/li>
&lt;li>&lt;strong>Retry Mechanism:&lt;/strong> 재시도 메커니즘&lt;/li>
&lt;li>&lt;strong>Circuit Breaker:&lt;/strong> 회로 차단기&lt;/li>
&lt;li>&lt;strong>Idempotent Producer:&lt;/strong> 중복 메시지 처리&lt;/li>
&lt;/ul>
&lt;h3 id="심화-설정">심화 설정
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>메시지 형식:&lt;/strong> Custom Message Converter, Schema Registry, Type Conversion&lt;/li>
&lt;li>&lt;strong>확장성:&lt;/strong> Dynamic Routing, Message Expiration, DLX&lt;/li>
&lt;li>&lt;strong>클라우드 환경:&lt;/strong> Cloud-Native Messaging, Kubernetes&lt;/li>
&lt;li>&lt;strong>테스트 및 모니터링:&lt;/strong> Integration Test, Contract Test, Prometheus&lt;/li>
&lt;li>&lt;strong>보안 및 규정 준수:&lt;/strong> TLS/SSL, IAM, Compliance&lt;/li>
&lt;li>&lt;strong>패턴 및 관례:&lt;/strong> Builder Pattern, Template Method Pattern&lt;/li>
&lt;li>&lt;strong>Retry Mechanism:&lt;/strong> 재시도 메커니즘&lt;/li>
&lt;li>&lt;strong>Circuit Breaker:&lt;/strong> 회로 차단기&lt;/li>
&lt;li>&lt;strong>Idempotent Producer:&lt;/strong> 중복 메시지 처리&lt;/li>
&lt;li>Confirm :&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>각 키워드에 대한 자세한 설명은 이전 답변들을 참고하시거나, 궁금한 부분을 질문해주세요.&lt;/strong>&lt;/p></description></item></channel></rss>