<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OOP on Sungho's Dev BLog</title><link>https://sungho94.me/tags/oop/</link><description>Recent content in OOP on Sungho's Dev BLog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sun, 30 Jun 2024 23:17:10 +0000</lastBuildDate><atom:link href="https://sungho94.me/tags/oop/index.xml" rel="self" type="application/rss+xml"/><item><title>객체지향 프로그래밍 - Object Oriented Programming</title><link>https://sungho94.me/p/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-object-oriented-programming/</link><pubDate>Sun, 30 Jun 2024 23:17:10 +0000</pubDate><guid>https://sungho94.me/p/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-object-oriented-programming/</guid><description>&lt;h2 id="개념">개념
&lt;/h2>&lt;ul>
&lt;li>프로그래밍 패러다임의 한 종류로, 객체간의 상호작용을 통해 로직을 구성하는 방법&lt;/li>
&lt;li>객체간의 상호작용은 인간 세계의 상호작용을 바탕으로 하기에 이해하기 쉬움&lt;/li>
&lt;/ul>
&lt;h2 id="특징">특징
&lt;/h2>&lt;h3 id="캡슐화">캡슐화
&lt;/h3>&lt;ul>
&lt;li>서로 연관되어있는 속성과 기능들을 하나의 캡슐로 만들어 외부로 부터 보호하는것
&lt;ul>
&lt;li>데이터 보호 - 외부로부터 클래시에 정의된 속성과 기능들을 보호&lt;/li>
&lt;li>데이터 은닉 - 내부의 동작을 감추고 외부에는 필요한 부분만 노출&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="추상화">추상화
&lt;/h3>&lt;ul>
&lt;li>중요한 부분을 강조하기 위해 불필요한 세부사항을 제거하고, 본질적이고 공통적인 부분만 추출하여 표현하는 것&lt;/li>
&lt;/ul>
&lt;h3 id="상속">상속
&lt;/h3>&lt;ul>
&lt;li>상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 하는것
&lt;ul>
&lt;li>속성보다는 하는 행위가 같아야지 덜 복잡함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="다형성">다형성
&lt;/h3>&lt;ul>
&lt;li>어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형태를 가질 수 있는 성질
&lt;ul>
&lt;li>메서드 오버라이딩, 메서드 오버로딩&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="원칙">원칙
&lt;/h2>&lt;h3 id="단일-책임-원칙-single-responsiblity-principle">단일 책임 원칙 (Single Responsiblity Principle)
&lt;/h3>&lt;ul>
&lt;li>하나의 객체는 하나의 책임만 가져야함&lt;/li>
&lt;li>변경의 이유도 하나여야함&lt;/li>
&lt;/ul>
&lt;h3 id="개방-폐쇄-원칙-open-closed-principle">개방-폐쇄 원칙 (Open Closed Principle)
&lt;/h3>&lt;ul>
&lt;li>변경에는 닫혀있고, 확장에는 열려있어야함&lt;/li>
&lt;/ul>
&lt;h3 id="리스코프-치환-원칙-liskov-substitution-principle">리스코프 치환 원칙 (Liskov Substitution Principle)
&lt;/h3>&lt;ul>
&lt;li>프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함&lt;/li>
&lt;/ul>
&lt;h3 id="인터페이스-분리-원칙-interface-segregation-principle">인터페이스 분리 원칙 (Interface Segregation Principle)
&lt;/h3>&lt;ul>
&lt;li>필요한 인터페이스만 상속받아야함
&lt;ul>
&lt;li>특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="의존-역전-원칙-dependency-inversion-principle">의존 역전 원칙 (Dependency Inversion Principle)
&lt;/h3>&lt;ul>
&lt;li>구체화된것 보다는 추상적인것을 의존해야함&lt;/li>
&lt;/ul>
&lt;p>어떤 코드가 변경되었을때 변경되는 정도&lt;br>
결합도&lt;br>
응집도&lt;/p>
&lt;p>관심사의 분리&lt;br>
&lt;a class="link" href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html" target="_blank" rel="noopener"
>https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html&lt;/a>&lt;br>
It is what I sometimes have called &amp;ldquo;the separation of concerns&amp;rdquo;, which, even if not perfectly possible, is yet the only available technique for effective ordering of one&amp;rsquo;s thoughts, that I know of. This is what I mean by &amp;ldquo;focussing one&amp;rsquo;s attention upon some aspect&amp;rdquo;: it does not mean ignoring the other aspects, it is just doing justice to the fact that from this aspect&amp;rsquo;s point of view, the other is irrelevant. It is being one- and multiple-track minded simultaneously.&lt;/p>
&lt;p>&lt;a class="link" href="https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95" target="_blank" rel="noopener"
>https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95&lt;/a>&lt;/p>
&lt;p>#argent&lt;/p></description></item><item><title>필드를 노출시키면 안되는 이유</title><link>https://sungho94.me/p/%ED%95%84%EB%93%9C%EB%A5%BC-%EB%85%B8%EC%B6%9C%EC%8B%9C%ED%82%A4%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/</link><pubDate>Tue, 09 Apr 2024 17:03:45 +0000</pubDate><guid>https://sungho94.me/p/%ED%95%84%EB%93%9C%EB%A5%BC-%EB%85%B8%EC%B6%9C%EC%8B%9C%ED%82%A4%EB%A9%B4-%EC%95%88%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0/</guid><description>&lt;h2 id="객체의-필드를-그대로-노출하여-로직을-구하는-경우">객체의 필드를 그대로 노출하여 로직을 구하는 경우
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>캡슐화가 깨지고 결합도가 높아진다.&lt;/p>
&lt;ul>
&lt;li>다른 객체의 필드값을 가지고 로직을 구현한다면, 로직 변경되었을때 해당 로직을 가지고 있는 모든 로직을 변경해야한다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>예약이라는 객체가 있다고 생각해보자&lt;/p>
&lt;/li>
&lt;li>
&lt;p>예약이라는 객체는 capacity라는 속성이 있고, 기존에는 capacity만으로 주문 가능한 여부를 따졌다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>하지만 요구사항이 추가되어, 거리에 따라 capacity를 수정하기로 하였고, 거리마다 capacity가 다르다&lt;/p>
&lt;/li>
&lt;li>
&lt;p>이렇게 변경 시 기존에 capacity를 사용해서 마감을 확인하던 코드를 다 변경하여, 거리, capacity 두개 다 확인하도록 변경해야한다.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>협력, 책임, 역할</title><link>https://sungho94.me/p/%ED%98%91%EB%A0%A5-%EC%B1%85%EC%9E%84-%EC%97%AD%ED%95%A0/</link><pubDate>Sat, 02 Mar 2024 22:41:32 +0000</pubDate><guid>https://sungho94.me/p/%ED%98%91%EB%A0%A5-%EC%B1%85%EC%9E%84-%EC%97%AD%ED%95%A0/</guid><description>&lt;h2 id="협력">협력
&lt;/h2>&lt;p>어플리케이션의 기능을 구현하기 위해 수행하는 상호작용&lt;/p>
&lt;h2 id="책임">책임
&lt;/h2>&lt;p>객체가 협력에 참여하기 위해 수행하는 로직&lt;/p>
&lt;h2 id="역할">역할
&lt;/h2>&lt;p>객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합&lt;/p></description></item></channel></rss>