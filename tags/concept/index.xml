<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concept on Sungho's Dev BLog</title><link>https://sungho94.me/tags/concept/</link><description>Recent content in Concept on Sungho's Dev BLog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sun, 14 Jul 2024 23:01:00 +0000</lastBuildDate><atom:link href="https://sungho94.me/tags/concept/index.xml" rel="self" type="application/rss+xml"/><item><title>HTTP Client Timeout</title><link>https://sungho94.me/p/http-client-timeout/</link><pubDate>Sun, 14 Jul 2024 23:01:00 +0000</pubDate><guid>https://sungho94.me/p/http-client-timeout/</guid><description>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240715122255.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="connection-timeout">Connection Timeout
&lt;/h2>&lt;ul>
&lt;li>client가 server에 커넥션을 연결을 시도하는 최대 시간 지정
&lt;ul>
&lt;li>the time to establish the connection with the remote host&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="socket-timeout">Socket Timeout
&lt;/h2>&lt;ul>
&lt;li>server와의 연결이 완료된 시점에서, 데이터의 송수신을 할 최대 시간 지정
&lt;ul>
&lt;li>두 데이터패킷 사이 비활성화된 최대 시간&lt;/li>
&lt;li>maximum time of inactivity between two data packets&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="http-manager-timeout">HTTP Manager Timeout
&lt;/h2>&lt;ul>
&lt;li>HTTP Client 라이브러리에서는 내부적으로 HTTP 커넥션 풀을 관리함&lt;/li>
&lt;li>HTTP 커넥션 풀에서 커넥션을 가져오는데 걸리는 최대 시간 제어&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.baeldung.com/httpclient-timeout" target="_blank" rel="noopener"
>https://www.baeldung.com/httpclient-timeout&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/18184899/what-is-the-difference-between-the-setconnectiontimeout-setsotimeout-and-http" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/18184899/what-is-the-difference-between-the-setconnectiontimeout-setsotimeout-and-http&lt;/a>&lt;/p></description></item><item><title>ElasticSearch query and fetch</title><link>https://sungho94.me/p/elasticsearch-query-and-fetch/</link><pubDate>Tue, 18 Jun 2024 22:30:18 +0000</pubDate><guid>https://sungho94.me/p/elasticsearch-query-and-fetch/</guid><description>&lt;ul>
&lt;li>search쿼리는 도착지를 고정할 수 없고, 잠재적으로 매칭되는 index또는 indices안의 모든 샤드를 검색해야하기에 어려움&lt;/li>
&lt;li>일치하는 문서를 찾는 것 뿐만아니라, 검색 api는 결과를 사용자에게 표시하기 전에 통합되고 정리된 목록으로 결합해야함&lt;/li>
&lt;li>기본적으로, 엘라스틱서치는 Query Then Fetch라는 검색방법을 사용함&lt;/li>
&lt;/ul>
&lt;h2 id="단계">단계
&lt;/h2>&lt;h3 id="1-클라이언트가-elasticsearch로-쿼리-전송조정노드">1. 클라이언트가 Elasticsearch로 쿼리 전송(조정노드)
&lt;/h3>&lt;h3 id="2-쿼리를-각-샤드로-브로드캐스팅조정노드">2. 쿼리를 각 샤드로 브로드캐스팅(조정노드)
&lt;/h3>&lt;p>2-1. 조정노드는 패턴 또는 별칭으로 대상 인덱스 목록 작성&lt;/p>
&lt;ul>
&lt;li>단일인덱스도 될 수 있지만, logsash-*과같이 패턴일 수 있음&lt;/li>
&lt;li>실제 쿼리가 검색해야하는 인덱스 목록이 생성됨&lt;br>
2-2. 대상 인덱스의 distinct shard 목록을 작성함&lt;/li>
&lt;li>distinct shard목록은 primary shard와 replica shard의 집함임&lt;/li>
&lt;li>검색요청은 primary shard와 replica shard 둘 중 어&lt;br>
2-3. 각 인덱스의 라우팅옵션에 따라 모든 샤드로 갈지, 하나의 샤드로 갈지 결정함&lt;/li>
&lt;li>대부분의 쿼리는 모든 별개의 샤드로 가지만, 특정 라우팅으로 하나의 샤드에 모든 document가 있다는것을 보증한다면, 하나의 샤드로만 쿼리함&lt;br>
2-4. 조정노드는 관롼된 각 샤드에 대해 쿼리할 실제 샤드를 선택함&lt;/li>
&lt;li>일반적으로 무작위로 선택되지만, 최근 쿼리에서 가장 성능이 좋은 샤드를 결정하는 등 최적화가 이루어지기도 함&lt;/li>
&lt;/ul>
&lt;h3 id="3-로컬-용어빈도를-사용해-일치하는-모든-문서-찾기-및-점수계산">3. 로컬 용어/빈도를 사용해 일치하는 모든 문서 찾기 및 점수계산
&lt;/h3>&lt;ul>
&lt;li>아래의 작업이 발생함
&lt;ul>
&lt;li>ElasticSearch level에서 매핑
&lt;ul>
&lt;li>인덱스 시점의 매핑과 유사함&lt;/li>
&lt;li>쿼리 필드를 기본 Lucoene데이터 필드 및 구조에 매핑하여, 각 세그먼트(Lucene index)가 실행할 수 있는 Lucene호환 쿼리를 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Lucene에서의 분석&lt;/li>
&lt;li>Lucene에서 검색&lt;/li>
&lt;li>Lucone에서 Scoring&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>쿼리의 텍스트 부분은 동일한 analyzer를 통해 tokenzing됨
&lt;ul>
&lt;li>이로인해 쿼리 텍스트가 색인된 방식과 일치하게 됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="4-결과의-우선순위-큐-구축정렬-페이지네이션-등">4. 결과의 우선순위 큐 구축(정렬, 페이지네이션 등)
&lt;/h3>&lt;h3 id="5-조정-노드에-결과에-대한-메타데이터를-반환함">5. 조정 노드에 결과에 대한 메타데이터를 반환함
&lt;/h3>&lt;ul>
&lt;li>실제 문서가 아닌 document ID와 점수를 반환함&lt;/li>
&lt;/ul>
&lt;h3 id="6-모든-샤드의-점수가-조정-노드에서-병합-및-정렬되고-쿼리-기준에-따라-문서가-선택됨">6. 모든 샤드의 점수가 조정 노드에서 병합 및 정렬되고, 쿼리 기준에 따라 문서가 선택됨
&lt;/h3>&lt;h3 id="7-끝으로-실제-문서가-있는-개별-샤드에서-실제-문서가-검색됨">7. 끝으로, 실제 문서가 있는 개별 샤드에서 실제 문서가 검색됨
&lt;/h3>&lt;h3 id="8-결과를-클라이언트에-반환조정노드">8. 결과를 클라이언트에 반환(조정노드)
&lt;/h3>&lt;ul>
&lt;li>조정 노드는 1,2,8단계에서 사용됨&lt;/li>
&lt;/ul>
&lt;h2 id="query-phase3456">Query Phase(3,4,5,6)
&lt;/h2>&lt;ul>
&lt;li>검색 쿼리는 모든 샤드에 전성되어 로컬 실행이 시작되고, 일치하는 문서가 포함된 우선순위 대기열이 생성됨&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240618223803.png"
loading="lazy"
alt="|center"
>&lt;/p>
&lt;h2 id="fetch-phase7">Fetch Phase(7)
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>query Phase가 연관된 문서를 확인하는 반면에, Fetch phase에서는 각각의 샤드에서 실제 문서를 가져오는 역할을 담당함&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240618223931.png"
loading="lazy"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>이 분할방식은 분산된 환경에서 효과적이고 확장가능한 검색작업을 보장함&lt;/p>
&lt;ul>
&lt;li>Query phase에서는 검색 커리가 각 샤드 복사본을 탐색하여 로컬 검색을 시작하고, 일치하는 문서의 우선순위가 지정된 목록을 컴파일함
&lt;ul>
&lt;li>이 단계는 검색 결과를 구체화 하는 초기단계임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Fetch phase에서는 원하는 검색 결과를 제공함
&lt;ul>
&lt;li>이 단계는 쿼리 실행과 검색 결과 사이의 가교 역할을 하며 검색 프로세스의 철저함을 보장함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="추가-정보">추가 정보
&lt;/h2>&lt;ul>
&lt;li>Elasticsearch의 query와 fetch phases에서 slow logs를 enable하면, 검색 성능을 모니터링 및 최적화가 가능함&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HTTp" data-lang="HTTp">&lt;span class="line">&lt;span class="cl">&lt;span class="err">PUT *,-.*/_settings
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">{
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;#34;index.search.slowlog.threshold.query.warn&amp;#34;: &amp;#34;1s&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;#34;index.search.slowlog.threshold.fetch.warn&amp;#34;: &amp;#34;100ms&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#or with curl
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">curl -XPUT &amp;#34;http://localhost:9200/*,-.*/_settings&amp;#34; -H &amp;#34;Content-Type: application/json&amp;#34; -d&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">{
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;#34;index.search.slowlog.threshold.query.warn&amp;#34;: &amp;#34;1s&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;#34;index.search.slowlog.threshold.fetch.warn&amp;#34;: &amp;#34;100ms&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;a class="link" href="https://medium.com/@musabdogan/elasticsearchs-distributed-search-query-and-fetch-phases-df869d35f4b3" target="_blank" rel="noopener"
>https://medium.com/@musabdogan/elasticsearchs-distributed-search-query-and-fetch-phases-df869d35f4b3&lt;/a>&lt;br>
&lt;a class="link" href="https://steve-mushero.medium.com/elasticsearch-search-data-flow-2a5f799aac6a" target="_blank" rel="noopener"
>https://steve-mushero.medium.com/elasticsearch-search-data-flow-2a5f799aac6a&lt;/a>&lt;/p></description></item><item><title>인증, 인가</title><link>https://sungho94.me/p/%EC%9D%B8%EC%A6%9D-%EC%9D%B8%EA%B0%80/</link><pubDate>Tue, 28 May 2024 23:21:08 +0000</pubDate><guid>https://sungho94.me/p/%EC%9D%B8%EC%A6%9D-%EC%9D%B8%EA%B0%80/</guid><description>&lt;p>인증과 인가는 보안 시스템에서 중요한 개념으로, 사용자의 신원을 확인하고 자원에 대한 접근 권한을 관리하는 데 사용됩니다. 이 두 개념은 종종 혼동되지만, 서로 다른 목적을 가지고 있습니다.&lt;/p>
&lt;h2 id="인증-authentication">인증 (Authentication)
&lt;/h2>&lt;ul>
&lt;li>사용자가 자신이 주장하는 신원임을 확인하는 과정&lt;/li>
&lt;li>사용자가 로그인할 때 시스템은 사용자의 신원을 확인하기 위한 방법&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>무엇을 알고 있는가 (What you know): 패스워드, PIN 등.&lt;/li>
&lt;li>무엇을 가지고 있는가 (What you have): 스마트 카드, 보안 토큰 등.&lt;/li>
&lt;li>무엇인가 (What you are): 지문, 얼굴 인식, 홍채 스캔 등 생체 인식.&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>사용자나 시스템이 제공하는 정보가 신뢰할 수 있는지를 확인하는 절차로, 이 단계에서 사용자는 본인임을 증명해야 합니다.&lt;/li>
&lt;/ul>
&lt;h2 id="인가-authorization">인가 (Authorization)
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>인증을 거친 사용자가 특정 자원에 접근할 수 있는 권한이 있는지를 결정하는 과정&lt;/p>
&lt;/li>
&lt;li>
&lt;p>인증이 사용자의 신원을 확인하는 것이라면, 인가는 그 사용자가 특정 작업을 수행할 수 있는지를 결정하는 것&lt;/p>
&lt;ul>
&lt;li>사용자가 시스템에 로그인을 해서 인증이 완료된 후, 그 사용자가 특정 파일을 읽거나 쓸 수 있는지, 또는 특정 애플리케이션을 실행할 수 있는지 등을 결정하는 것이 인가입니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>인가 시스템은 주로 다음과 같은 정보를 바탕으로 작동함&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>역할 기반 접근 제어 (Role-Based Access Control, RBAC): 사용자에게 특정 역할을 부여하고, 그 역할에 따라 접근 권한을 결정합니다.&lt;/li>
&lt;li>정책 기반 접근 제어 (Policy-Based Access Control, PBAC): 조직의 보안 정책에 따라 접근 권한을 결정합니다.&lt;/li>
&lt;li>속성 기반 접근 제어 (Attribute-Based Access Control, ABAC): 사용자, 자원, 환경 등의 속성에 따라 접근 권한을 결정합니다.&lt;/li>
&lt;/ol>
&lt;h3 id="요약">요약
&lt;/h3>&lt;ul>
&lt;li>인증: 사용자가 누구인지 확인하는 과정.&lt;/li>
&lt;li>인가: 확인된 사용자가 어떤 자원에 접근할 수 있는지를 결정하는 과정.&lt;/li>
&lt;/ul></description></item><item><title>11-분산락(Distributed lock)</title><link>https://sungho94.me/p/11-%EB%B6%84%EC%82%B0%EB%9D%BDdistributed-lock/</link><pubDate>Thu, 02 May 2024 22:41:32 +0000</pubDate><guid>https://sungho94.me/p/11-%EB%B6%84%EC%82%B0%EB%9D%BDdistributed-lock/</guid><description>&lt;ul>
&lt;li>
&lt;p>named lock&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mysql, redis 등 named lock을 지원하는 저장소에서 사용가능&lt;/p>
&lt;/li>
&lt;li>
&lt;p>redis서버가 없는 상황에서 mysql named lock도 유용한 선택지임&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mysql은 connection 끊기면 lock도 풀림&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>분산락은 자원에대한 락이 아닌 작업,행위에 대한 락&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>하나의 작업이 한번만 실행되게 할때 유용함&lt;/p>
&lt;ul>
&lt;li>따닥 방지&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터베이스에 부하가 가지않음&lt;/p>
&lt;ul>
&lt;li>but, 실제로 작업하는 row가 db lock이 걸려있을시 처리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>실제로 사용하기 위해 멱등성 보장이 필요할 수 있음&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener"
>https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>URL, URN, URI</title><link>https://sungho94.me/p/url-urn-uri/</link><pubDate>Tue, 09 Apr 2024 22:31:29 +0000</pubDate><guid>https://sungho94.me/p/url-urn-uri/</guid><description>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240409223209.png"
loading="lazy"
alt="|center|600"
>&lt;/p>
&lt;h2 id="uriuniform-resource-identifier">URI(Uniform Resource Identifier)
&lt;/h2>&lt;ul>
&lt;li>통합 자원 식별자&lt;/li>
&lt;li>인터넷에 있는 자원을 나타내는 유일한 주소&lt;/li>
&lt;li>URN과 URL을 포괄하는 개념&lt;/li>
&lt;li>URL은 URI가 될 수 없지만, URI는 URL이 될 수 있음&lt;/li>
&lt;li>&lt;em>제한적인 URL과 URN보다는 URI라는 용어를 쓰자&lt;/em>&lt;/li>
&lt;li>예시
&lt;ul>
&lt;li>data:text/plain;base64,SGVsbG8gV29ybGQh&lt;/li>
&lt;li>data:image/jpeg;base64,/9j/4AAQSkZJRgAB…&lt;/li>
&lt;li>tel:+1234567890&lt;/li>
&lt;li>tel:555–123–4567&lt;/li>
&lt;li>file:///path/to/file.txt&lt;/li>
&lt;li>file:///C:/Documents/document.docx&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="urluniform-resource-locator">URL(Uniform Resource Locator)
&lt;/h2>&lt;ul>
&lt;li>통합 자원 위치&lt;/li>
&lt;li>인터넷에서 웹페이지, 이미지, 비디오 등 리소스의 위치를 가르키는 문자열&lt;/li>
&lt;li>자원를 식별하는것 뿐만아니라 수단을 제공&lt;/li>
&lt;li>예시
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.example.com/index.html" target="_blank" rel="noopener"
>https://www.example.com/index.html&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://api.example.com/data" target="_blank" rel="noopener"
>http://api.example.com/data&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="ftp://ftp.example.com/files/document.pdf" >ftp://ftp.example.com/files/document.pdf&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="mailto:info@example.com" >info@example.com&lt;/a>&lt;/li>
&lt;li>mailto:user@example.com?subject=Hello&amp;amp;body=Hi%20there&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="urnuniform-resource-name">URN(Uniform Resource Name)
&lt;/h2>&lt;ul>
&lt;li>통합 자원 이름&lt;/li>
&lt;li>지속적이고, 위치에 독립적인 리소스 식별자&lt;/li>
&lt;li>예시
&lt;ul>
&lt;li>urn:isbn:0–486–27557–4&lt;/li>
&lt;li>urn:ietf:rfc:3986&lt;/li>
&lt;li>urn:oid:2.16.840&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3" target="_blank" rel="noopener"
>https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3&lt;/a>&lt;br>
&lt;a class="link" href="https://blog.bytebytego.com/i/132279282/url-uri-urn-do-you-know-the-differences" target="_blank" rel="noopener"
>https://blog.bytebytego.com/i/132279282/url-uri-urn-do-you-know-the-differences&lt;/a>&lt;br>
&lt;a class="link" href="https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-URL-URI-%EC%B0%A8%EC%9D%B4" target="_blank" rel="noopener"
>https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-URL-URI-%EC%B0%A8%EC%9D%B4&lt;/a>&lt;br>
&lt;a class="link" href="https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9" target="_blank" rel="noopener"
>https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9&lt;/a>_%EC%9E%90%EC%9B%90_%EC%8B%9D%EB%B3%84%EC%9E%90&lt;/p></description></item><item><title>0-Coroutine</title><link>https://sungho94.me/p/0-coroutine/</link><pubDate>Sun, 03 Mar 2024 22:41:01 +0000</pubDate><guid>https://sungho94.me/p/0-coroutine/</guid><description>&lt;ul>
&lt;li>작은 쓰레드, 하나의 쓰레드를 어떻게 효율적으로 처리할것인가에 대한 방안 중 하나&lt;/li>
&lt;li>block작업(io요청)이 발생했을때, thread를 block하지않고 해당 작업을 suspend시키고 다른작업을 처리함&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Asynchronous or non-blocking programming is an important part of the development landscape. When creating server-side, desktop, or mobile applications, it&amp;rsquo;s important to provide an experience that is not only fluid from the user&amp;rsquo;s perspective, but also scalable when needed.&lt;/p>
&lt;p>Kotlin solves this problem in a flexible way by providing coroutine support at the language level and delegating most of the functionality to libraries.&lt;/p>
&lt;p>In addition to opening the doors to asynchronous programming, coroutines also provide a wealth of other possibilities, such as concurrency and actors.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a class="link" href="https://kotlinlang.org/docs/coroutines-overview.html" target="_blank" rel="noopener"
>https://kotlinlang.org/docs/coroutines-overview.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>10-Isolation level(격리 수준)</title><link>https://sungho94.me/p/10-isolation-level%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80/</link><pubDate>Sat, 02 Mar 2024 22:41:32 +0000</pubDate><guid>https://sungho94.me/p/10-isolation-level%EA%B2%A9%EB%A6%AC-%EC%88%98%EC%A4%80/</guid><description>&lt;ul>
&lt;li>여러 트랜잭션이 동시에 변경을 수행하고 쿼리를 수행할 때 성능과 안정성, 일관성 및 결과 재현성 간의 균형을 미세 조정하는 설정&lt;/li>
&lt;/ul>
&lt;h2 id="read-uncommitted">Read Uncommitted
&lt;/h2>&lt;ul>
&lt;li>가장 낮은 격리 수준&lt;/li>
&lt;li>커밋되지 않은 다른 트랜잭션의 변경 내용을 읽을 수 있음&lt;/li>
&lt;li>어떤 트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK과 상관없이 다른 트랜잭션에서 보여짐&lt;/li>
&lt;/ul>
&lt;h2 id="read-committed">Read Committed
&lt;/h2>&lt;ul>
&lt;li>다른 트랜잭션에서 커밋되지 않은 데이터는 읽을수 없음&lt;/li>
&lt;li>Dirty Read(더티 리드)문제는 해결되지만, Phantom Read(유령 읽기) 문제는 발생함&lt;/li>
&lt;/ul>
&lt;h2 id="repeatable-read">REPEATABLE READ
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>한 트랜잭션 내에서 같은 쿼리를 여러 번 실행했을 때, 항상 동일한 결과를 얻을 수 있음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>첫번째 읽기 작업이 이루어진 때를 기준으로 스냅샷을 생성함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>InnoDB의 default isolation level임&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="serializablehttpsdevmysqlcomdocrefman80englossaryhtmlglos_serializable">&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_serializable" target="_blank" rel="noopener"
>Serializable&lt;/a>
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>어떤 한 트랜잭션이 데이터를 읽었다면, lock을 걸어 이 트랜잭션이 끝날때까지 다른트랜잭션이 읽기, 쓰기가 불가능하도록 하는 level&lt;/p>
&lt;/li>
&lt;li>
&lt;p>autocommit이 활성화 되어있지 않으면, select 문을 select &amp;hellip; for share 문으로 변경함&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Mysql doc을 보고 작성했으며, ANSI Isolation level이 궁금하다면 &lt;a class="link" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf" target="_blank" rel="noopener"
>참고&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos&lt;/a>_isolation_level&lt;br>
&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos&lt;/a>_serializable&lt;/p></description></item><item><title>Test</title><link>https://sungho94.me/p/test/</link><pubDate>Sat, 02 Mar 2024 22:41:32 +0000</pubDate><guid>https://sungho94.me/p/test/</guid><description>&lt;ol>
&lt;li>기능에 대한 명세이다&lt;/li>
&lt;li>내가 개발한 기능의 동작방법 및 현재 잘 동작하는것을 보증한다&lt;/li>
&lt;li>다른사람이 수정시 기존의 동작을 보장&lt;/li>
&lt;li>코드 퀄리티에 대한 보장이다
&lt;ul>
&lt;li>코드가 복잡하면 테스트짜기 어렵기 때문이다&lt;/li>
&lt;li>하나의 메서드에 대해 테스트가 너무 많다면 해당 메서드가 기능이 너무 많지 않은지 확인&lt;/li>
&lt;li>객체에 모킹할게 너무 많다면 객체가 너무 많은 일을 하고 있는지 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>#eventually-update&lt;/p></description></item><item><title>9-Record Locks</title><link>https://sungho94.me/p/9-record-locks/</link><pubDate>Sat, 02 Mar 2024 22:41:04 +0000</pubDate><guid>https://sungho94.me/p/9-record-locks/</guid><description>&lt;ul>
&lt;li>record의 index에 거는 lock&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>primary index가 없는 테이블에도 가능&lt;br>
primary index가 없더라도 mysql에서는 hidden clustered index를 생성하기 때문&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Mysql Doc에는 row락이라는 용어가 등장하지 않음,&lt;br>
스택오버플로우에는 record lock과 row lock이 동일 하다는 이야기가 있음&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/74967004/row-level-locks-vs-index-record-locks" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/74967004/row-level-locks-vs-index-record-locks&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/InnoDB-locking.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/InnoDB-locking.html&lt;/a>&lt;/p></description></item><item><title>8-Intention shared lock, exclusive lock</title><link>https://sungho94.me/p/8-intention-shared-lock-exclusive-lock/</link><pubDate>Sat, 02 Mar 2024 22:41:03 +0000</pubDate><guid>https://sungho94.me/p/8-intention-shared-lock-exclusive-lock/</guid><description>&lt;ul>
&lt;li>
&lt;p>IS, IX lock과 S,X Lock과의 차이는 테이블까지 락이 걸림&lt;/p>
&lt;/li>
&lt;li>
&lt;p>IS, IX lock을 걸면 해당 테이블에도 락이 걸림&lt;/p>
&lt;/li>
&lt;li>
&lt;p>해당 테이블에 대해 다른 트래잭션에서 같은 테이블의 다른 row에 IS,IX락은 걸 수 있지만, 같은 테이블에 대해 S,X Lock을 걸 수 없음(실험완료)&lt;/p>
&lt;ul>
&lt;li>S,X와 같이, IS가 걸려있으면 해당 테이블에 대해 S락은 가능, X락은 불가&lt;/li>
&lt;li>S,X와 같이, IX가 걸려있으면 해당 테이블에 대해 S,X락 둘다 불가&lt;/li>
&lt;li>읽기나 쓰기 도중 테이블이 변경되는것을 막기 위함이라고 추측함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>SELECT ... FOR SHARE&lt;/code>로 S Lock을, &lt;code>SELECT ... FOR UPDATE&lt;/code>로 X락을 걸 수 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>IS lock추가&lt;br>
- select .. lock in share mode ;&lt;br>
- select .. for share ;&lt;br>
- 현재(8.0 기준) for share가 lock in share mode를 대체 하려하나 하위호환성 보장을 위해 lock in share mode를 유지하는중&lt;br>
- 그러나, for share를 사용하면 OF table_name, NOWAIT, and SKIP LOCKED를 사용할 수 있음&lt;/li>
&lt;/ul>
&lt;p>SELECT &amp;hellip; FOR SHARE is a replacement for SELECT &amp;hellip; LOCK IN SHARE MODE, but LOCK IN SHARE MODE remains available for backward compatibility. The statements are equivalent. However, FOR SHARE supports OF table_name, NOWAIT, and SKIP LOCKED options. See Locking Read Concurrency with NOWAIT and SKIP LOCKED.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos&lt;/a>_shared_lock&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/InnoDB-locking.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/InnoDB-locking.html&lt;/a>&lt;/p></description></item><item><title>7-Shared Lock(S-lock)</title><link>https://sungho94.me/p/7-shared-locks-lock/</link><pubDate>Sat, 02 Mar 2024 22:41:02 +0000</pubDate><guid>https://sungho94.me/p/7-shared-locks-lock/</guid><description>&lt;ul>
&lt;li>특정 행을 읽기위해 거는 락&lt;/li>
&lt;li>어떤 object에 S-lock이 걸려있다면 다른 트랜잭션에서 읽기는 가능하지만 변경은 불가능함&lt;/li>
&lt;li>S-lock이 걸려있는 object에 S-lock를 또 걸 수 있지만 X-lock은 걸 수 없음&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/InnoDB-locking.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/InnoDB-locking.html&lt;/a>&lt;/p></description></item><item><title>6-Exclusive Lock(X-Lock)</title><link>https://sungho94.me/p/6-exclusive-lockx-lock/</link><pubDate>Sat, 02 Mar 2024 22:41:01 +0000</pubDate><guid>https://sungho94.me/p/6-exclusive-lockx-lock/</guid><description>&lt;p>1- X-Lock이 걸린 객체에 대해 다른 트랜잭션에서 읽기, 쓰기 불가능&lt;/p>
&lt;ul>
&lt;li>
&lt;p>X-Lock이 걸린 객체에 대해 다른 객체에서 S-Lock, X-Lock 걸수 없음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>변경 또는 삭제를 위해 락을 걸떄 활용&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mysql의 Repeatable-Read는 Constent Read 기술을 사용해여 X-Lock걸린 row를 읽도록 함으로써 효율을 높임&lt;/p>
&lt;ul>
&lt;li>X-Lock이 걸리기 전의 값을 읽음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/InnoDB-locking.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/InnoDB-locking.html&lt;/a>&lt;/p></description></item><item><title>4-Consistent Read(일관된 읽기)</title><link>https://sungho94.me/p/4-consistent-read%EC%9D%BC%EA%B4%80%EB%90%9C-%EC%9D%BD%EA%B8%B0/</link><pubDate>Fri, 01 Mar 2024 22:41:05 +0000</pubDate><guid>https://sungho94.me/p/4-consistent-read%EC%9D%BC%EA%B4%80%EB%90%9C-%EC%9D%BD%EA%B8%B0/</guid><description>&lt;ul>
&lt;li>
&lt;p>첫번째 읽을때 스냅샷을 생성함으로써, 다른 트랜잭션에서 발생한 변경과는 무관하게, 스냅샷을 생성했을 때의 데이터를 읽을수 있는 것을 말함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>다른 트랜잭션에서 데이터를 변경해도, undo log에 기록되어 변경전 데이터를 읽을 수 있음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>이로인해 동시성 문제를 해결&lt;/p>
&lt;ul>
&lt;li>undo log를 사용하지 않는다면, 어떤 row를 읽은 트랜잭션이 있다면 해당 트랜잭션이 끝날때 까지 해당 row를 접근하지 못하게 해야 일관된 읽기를 달성할 수 있음&lt;/li>
&lt;li>하지만 undo log를 사용함으로 각각의 트랜잭션에서는 데이터를 자유롭게 변경해도, 변경전 데이터가 undo log에 있으므로, 변경된 데이터에 대해서는 undo log를 읽어와 일관된 읽기를 달성할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>REPEATABLE READ와 READ COMMITTED에서 기본으로 사용됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p> ALTER TABLE문과 DROP TABLE문에서는 작동하지 않음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="참고자료">참고자료
&lt;/h3>&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos&lt;/a>_consistent_read&lt;br>
&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/InnoDB-consistent-read.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/InnoDB-consistent-read.html&lt;/a>&lt;/p></description></item><item><title>3-Critical section(임계영역)</title><link>https://sungho94.me/p/3-critical-section%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD/</link><pubDate>Fri, 01 Mar 2024 22:41:04 +0000</pubDate><guid>https://sungho94.me/p/3-critical-section%EC%9E%84%EA%B3%84%EC%98%81%EC%97%AD/</guid><description>&lt;ul>
&lt;li>동시성을 가지는 작업들이 공유하는 자원&lt;/li>
&lt;li>여러 작업에서 하나의 자원에 대해 동시에 접근하면, 예기치 못한 동작이나 오류가 발생할 수 있음&lt;/li>
&lt;li>여러 작업에서 하나의 자원을 동시에 엑세스를 방지하도록 보호해야함&lt;/li>
&lt;li>엑세스를 방지해야하는 자원을 임계영역이라고 부름&lt;/li>
&lt;/ul>
&lt;h3 id="참고자료">참고자료
&lt;/h3>&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/Critical" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Critical&lt;/a>_section&lt;/p>
&lt;p>#Concurrency&lt;/p></description></item><item><title>2-Semaphore</title><link>https://sungho94.me/p/2-semaphore/</link><pubDate>Fri, 01 Mar 2024 22:41:03 +0000</pubDate><guid>https://sungho94.me/p/2-semaphore/</guid><description>&lt;ul>
&lt;li>
&lt;p>임계영역을 보호하는 방법&lt;/p>
&lt;/li>
&lt;li>
&lt;p>여러 스레드의 임계영역에 대한 엑세스를 제어&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Mutex와의 차이점은 Mutex는 하나의 자원에 대한 엑세스를 제어하는 반면, Semaphore는 여러자원에 대한 엑세스를 제어&lt;/p>
&lt;/li>
&lt;li>
&lt;p>화장실이 3개이고 키도 3개일때&lt;/p>
&lt;/li>
&lt;li>
&lt;p>키가 하나도 없다면 화장실 이용불가&lt;/p>
&lt;/li>
&lt;li>
&lt;p>키가 1개 있다면 화장실 이용가능&lt;/p>
&lt;/li>
&lt;li>
&lt;p>키가 2개 있어도 화장실 이용가능&lt;/p>
&lt;/li>
&lt;li>
&lt;p>but, 어느 화장실 칸이 비었는지 모르기에 추가적인 정보가 더 필요함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://barrgroup.com/embedded-systems/how-to/rtos-mutex-semaphore" target="_blank" rel="noopener"
>추가적인 정보가 궁금하다면 여기&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="참고자료">참고자료
&lt;/h3>&lt;p>&lt;a class="link" href="https://ko.wikipedia.org/wiki/%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94_%EC%B2%A0%ED%95%99%EC%9E%90%EB%93%A4_%EB%AC%B8%EC%A0%9C" target="_blank" rel="noopener"
>식사하는 철학자들 문제&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/a/2332868/22483906" target="_blank" rel="noopener"
>https://stackoverflow.com/a/2332868/22483906&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/2350544/in-what-situation-do-you-use-a-semaphore-over-a-mutex-in-c/2350628#2350628" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/2350544/in-what-situation-do-you-use-a-semaphore-over-a-mutex-in-c/2350628#2350628&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/34519/what-is-a-semaphore/40238#40238" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/34519/what-is-a-semaphore/40238#40238&lt;/a>&lt;/p>
&lt;p>#Concurrency&lt;/p></description></item><item><title>1-Mutex(Lock)</title><link>https://sungho94.me/p/1-mutexlock/</link><pubDate>Fri, 01 Mar 2024 22:41:02 +0000</pubDate><guid>https://sungho94.me/p/1-mutexlock/</guid><description>&lt;ul>
&lt;li>&lt;strong>Mut&lt;/strong>ual &lt;strong>ex&lt;/strong>clusion의 약자&lt;/li>
&lt;li>프로세스 간 동기화에 사용할 수도 있는 동기화 기본 형식입니다.&lt;/li>
&lt;li>둘 이상의 스레드가 동시에 공유 리소스에 액세스해야 하는 경우 시스템은 한 번에 하나의 스레드만 리소스를 사용하도록 하기 위한 동기화 메커니즘&lt;/li>
&lt;li>공유 리소스에 대한 단독 액세스 권한을 하나의 스레드에만 부여하는 동기화 기본 형식입니다.&lt;/li>
&lt;li>스레드가 뮤텍스를 획득하면 첫 번째 스레드가 뮤텍스를 해제할 때까지 해당 뮤텍스를 획득하려는 두 번째 스레드가 일시 중단됩니다.&lt;/li>
&lt;/ul>
&lt;h3 id="화장실-비유">화장실 비유
&lt;/h3>&lt;ul>
&lt;li>화장실에 가고싶은데 키가 하나밖에 없는경우&lt;/li>
&lt;li>키가 있어야만 화장실에 갈 수 있음&lt;/li>
&lt;li>화장실에 아무도 없다면 키를 가져갈 수 있음&lt;/li>
&lt;li>화장실에 사람이 있다면, 사람이 나와 키를 줄때까지 기다려야함&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Mutex와 Lock은 동일한 개념임&lt;br>
Mutex는 Lock보다는 시스템 전체에 적용될 수 있음&lt;/p>
&lt;/blockquote>
&lt;h3 id="참고자료">참고자료
&lt;/h3>&lt;p>&lt;a class="link" href="https://learn.microsoft.com/ko-kr/dotnet/api/system.threading.mutex?view=net-7.0#remarks" target="_blank" rel="noopener"
>https://learn.microsoft.com/ko-kr/dotnet/api/system.threading.mutex?view=net-7.0#remarks&lt;/a>&lt;br>
&lt;a class="link" href="https://en.wikipedia.org/wiki/Lock" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Lock&lt;/a>_(computer_science)&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/2332765/what-is-the-difference-between-lock-mutex-and-semaphore" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/2332765/what-is-the-difference-between-lock-mutex-and-semaphore&lt;/a>&lt;/p></description></item><item><title>0-동시성(Concurrency)</title><link>https://sungho94.me/p/0-%EB%8F%99%EC%8B%9C%EC%84%B1concurrency/</link><pubDate>Fri, 01 Mar 2024 22:41:01 +0000</pubDate><guid>https://sungho94.me/p/0-%EB%8F%99%EC%8B%9C%EC%84%B1concurrency/</guid><description>&lt;h2 id="개념">개념
&lt;/h2>&lt;ul>
&lt;li>프로그램, 알고리즘, 또는 문제의 부분이나 단위 등이, 결과에 영향을 주지 않고 특정한 순서없이 실행되거나 부분적인 순서만을 가지고 실행될 수 있는 성질 &lt;a class="link" href="https://en.wikipedia.org/wiki/Concurrency_%5c%28computer_science%5c%29" target="_blank" rel="noopener"
>링크&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>하나의 작업을 정말 빠르게 처리하면 되지 않을까?&lt;/p>
&lt;ul>
&lt;li>대부분의 서비스에서는 cpu bound보다는 io bound가 많은 일을 처리하기에 동시성이 중요&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>동시성은 한번에 많은일을 처리하는것,&lt;br>
병렬성은 한번에 많은 일을 하는것을 의미&lt;/p>
&lt;/blockquote>
&lt;h2 id="왜-중요한가">왜 중요한가?
&lt;/h2>&lt;ul>
&lt;li>한번에 여러가지 일을 처리하니 한번에 많은일을 처리할 수 있음
&lt;ul>
&lt;li>성능이 증대됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="but-무결성의-문제">But, 무결성의 문제
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>하나의 자원을 가지고 하나이상의 작업이 수행될때 자원의 무결성의 문제&lt;/strong>&lt;/li>
&lt;li>Lost Update Problem(write-write conflict)
&lt;ul>
&lt;li>하나의 로우에 동시에 여러번 변경이 발생했을 때 발생하는 문제&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231218230909.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Unrepeatable Read Problem
&lt;ul>
&lt;li>다른 트랜잭션에서 변경이 되어, 같은 조회 쿼리에서 다른 데이터가 오는 현상&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231218231144.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Temporary Update Problem( dirty read problem)
&lt;ul>
&lt;li>커밋되지 않은 데이터를 읽어서 발생하는 문제&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231218231800.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Phantom Read Problem
&lt;ul>
&lt;li>데이터가 삭제되어 같은 트랜잭션에서 데이터를 못가져오는 문제&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231218231610.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="해결책">해결책
&lt;/h2>&lt;ul>
&lt;li>동시성 문제는 어떻게 동시에 처리하지 않을까에 대한 고민&lt;/li>
&lt;li>추상화한것들 어떻게 구체화 할것인가&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>
&lt;p>개념&lt;/p>
&lt;ul>
&lt;li>critical section&lt;/li>
&lt;li>mutex&lt;/li>
&lt;li>semaphore&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>JAVA에서 코드레벨 lock &lt;a class="link" href="https://www.baeldung.com/java-mutex" target="_blank" rel="noopener"
>참고자료&lt;/a>&lt;/p>
&lt;ul>
&lt;li>synchronized&lt;/li>
&lt;li>lock&lt;/li>
&lt;li>Semaphore&lt;/li>
&lt;li>Guava’s  Monitor&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>데이터베이스에서 동시성 문제 처리&lt;/p>
&lt;ul>
&lt;li>lock mode
&lt;ul>
&lt;li>Shared Lock&lt;/li>
&lt;li>Exclusive Lock&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>lock type
&lt;ul>
&lt;li>row lock&lt;/li>
&lt;li>Record Lock&lt;/li>
&lt;li>Gap Lock&lt;/li>
&lt;li>Next-key Lock&lt;/li>
&lt;li>auto increment lock&lt;/li>
&lt;li>table lock&lt;/li>
&lt;li>insert intention lock&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>isolation level&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Named Lock&lt;/p>
&lt;ul>
&lt;li>redis&lt;/li>
&lt;li>database&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="참고자료">참고자료
&lt;/h3>&lt;p>&lt;a class="link" href="https://medium.com/@bindubc/distributed-system-concurrency-problem-in-relational-database-59866069ca7c" target="_blank" rel="noopener"
>https://medium.com/@bindubc/distributed-system-concurrency-problem-in-relational-database-59866069ca7c&lt;/a>&lt;/p></description></item><item><title>Handler</title><link>https://sungho94.me/p/handler/</link><pubDate>Sun, 28 Jan 2024 10:42:53 +0000</pubDate><guid>https://sungho94.me/p/handler/</guid><description>&lt;p>먼저 Handler란, 특정 유형의 데이터에 특화되어 있거나, 특정한 작업에 초점에 맞춘 루틴/함수/메서드입니다.&lt;/p>
&lt;p>스프링에서 handlerAdaptor를 제공하는데, handlerAdaptor는 HTTP요청을 쉽게 처리할 수 있는 인터페이스입니다.&lt;/p>
&lt;p>HandlerMapping으로 특정 URL에 매핑됩니다.&lt;/p>
&lt;p>DispatcherServlet은 handlerAdaptor를 통해 Handler를 실행하고, 이로인해 DispatcherServlet과 Handler는 느슨한 연결을 유지할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">public interface HandlerAdapter {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> boolean supports(Object handler);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ModelAndView handle(
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> HttpServletRequest request,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> HttpServletResponse response,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Object handler) throws Exception;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> long getLastModified(HttpServletRequest request, Object handler);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>support메서드는 handle메서드를 호출하기 전, 인자로 받은 handler를 처리할 수 있는지 여부를 판단합니다&lt;/p>
&lt;p>handle메서드는 실제로 HTTP요청을 처리하는 부분입니다.&lt;/p>
&lt;p>getLastModified는 Deprecated되었습니다&lt;/p>
&lt;p>&lt;a class="link" href="https://stackoverflow.com/questions/195357/what-is-a-handler" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/195357/what-is-a-handler&lt;/a>&lt;br>
&lt;a class="link" href="https://www.baeldung.com/spring-mvc-handler-adapters" target="_blank" rel="noopener"
>https://www.baeldung.com/spring-mvc-handler-adapters&lt;/a>&lt;br>
&lt;a class="link" href="https://www.baeldung.com/spring-handler-mappings" target="_blank" rel="noopener"
>https://www.baeldung.com/spring-handler-mappings&lt;/a>&lt;br>
&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerAdapter.html#getLastModified%28jakarta.servlet.http.HttpServletRequest,java.lang.Object%29" target="_blank" rel="noopener"
>https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/HandlerAdapter.html#getLastModified(jakarta.servlet.http.HttpServletRequest,java.lang.Object)&lt;/a>&lt;/p></description></item><item><title>HandlerMethodArgumentResolver</title><link>https://sungho94.me/p/handlermethodargumentresolver/</link><pubDate>Sat, 27 Jan 2024 23:38:07 +0000</pubDate><guid>https://sungho94.me/p/handlermethodargumentresolver/</guid><description>&lt;ul>
&lt;li>주어진 요청의 컨텍스트 내에서 메서드 매개 변수를 인수 값으로 해석하는 전략을 제공하는 Spring의 인터페이스&lt;/li>
&lt;li>아래의 두 메서드가 있음&lt;/li>
&lt;/ul>
&lt;h3 id="supportsparameter">supportsParameter
&lt;/h3>&lt;ul>
&lt;li>해당 파라미터가 다른 변경이 일어나야 하는지 여부를 판단하는 파라미터입니다
&lt;ul>
&lt;li>해당 파라미터를 변경여부를 판단&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="resolveargument">resolveArgument
&lt;/h3>&lt;ul>
&lt;li>메서드의 주어진 파라미터를 resolve함
&lt;ul>
&lt;li>handler의 파라미터를 변경함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html" target="_blank" rel="noopener"
>https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/method/support/HandlerMethodArgumentResolver.html&lt;/a>&lt;/p></description></item><item><title>Interceptor</title><link>https://sungho94.me/p/interceptor/</link><pubDate>Sat, 27 Jan 2024 23:13:55 +0000</pubDate><guid>https://sungho94.me/p/interceptor/</guid><description>&lt;p>handlerMapping의 구현으로 특정요청에 대해 특정 기능을 적용할때 사용합니다&lt;br>
아래 3가지 메소드가 존재합니다&lt;/p>
&lt;h3 id="prehandle">preHandle
&lt;/h3>&lt;ul>
&lt;li>핸들러가 실행되기 전 실행됩니다&lt;/li>
&lt;li>boolean을 리턴하는데, true를 리턴하면 이후 실행이 계속되지만, false나 예외를 리턴하면 이후의 interceptor 및 핸들러를 실행하지 않습니다&lt;/li>
&lt;/ul>
&lt;h3 id="posthandle">postHandle
&lt;/h3>&lt;ul>
&lt;li>핸들러가 실행된 후 실행됩니다&lt;/li>
&lt;/ul>
&lt;h3 id="aftercompletion">afterCompletion
&lt;/h3>&lt;ul>
&lt;li>모든 완료된 후 실행됩니다&lt;/li>
&lt;/ul>
&lt;h2 id="vs-filter">vs Filter
&lt;/h2>&lt;ul>
&lt;li>Filter와의 차이점으로 Filter는 Dispatcher Servlet이 실행되기전 적용됩니다&lt;/li>
&lt;li>Interceptor는 Dispatcher Servlet이 실행된 후 호출이 됩니다&lt;/li>
&lt;li>Filter는 전체 수명주기를 대상으로하는 작업에 적합함&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>deep-dive&lt;br>
&lt;a class="link" href="https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest/filters-and-interceptors.html" target="_blank" rel="noopener"
>https://eclipse-ee4j.github.io/jersey.github.io/documentation/latest/filters-and-interceptors.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>webflux에서는 webfilter가 동일한 기능을 제공함&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet/handlermapping-interceptor.html" target="_blank" rel="noopener"
>https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet/handlermapping-interceptor.html&lt;/a>&lt;br>
&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-config/interceptors.html" target="_blank" rel="noopener"
>https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-config/interceptors.html&lt;/a>&lt;br>
&lt;a class="link" href="https://gngsn.tistory.com/153" target="_blank" rel="noopener"
>https://gngsn.tistory.com/153&lt;/a>&lt;br>
&lt;a class="link" href="https://docs.spring.io/spring-framework/reference/web/webflux/reactive-spring.html#webflux-filters" target="_blank" rel="noopener"
>https://docs.spring.io/spring-framework/reference/web/webflux/reactive-spring.html#webflux-filters&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/35856454/difference-between-interceptor-and-filter-in-spring-mvc" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/35856454/difference-between-interceptor-and-filter-in-spring-mvc&lt;/a>&lt;/p>
&lt;p>#Spring&lt;/p></description></item><item><title>DLQ(Dead Letter Queue)</title><link>https://sungho94.me/p/dlqdead-letter-queue/</link><pubDate>Sat, 07 Oct 2023 16:59:28 +0000</pubDate><guid>https://sungho94.me/p/dlqdead-letter-queue/</guid><description>&lt;ul>
&lt;li>오류 또는 수신 서버의 변경로 인해 처리할 수 없는 메시지를 임시로 저장하는 곳&lt;/li>
&lt;li>임시로 저장해놨다가 retry하거나, retry로 해결이 안되면 관리자에게 알림을 구성할 수 있음&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://aws.amazon.com/ko/what-is/dead-letter-queue/" target="_blank" rel="noopener"
>https://aws.amazon.com/ko/what-is/dead-letter-queue/&lt;/a>&lt;/p></description></item><item><title>Forward Proxy, Reverse Proxy</title><link>https://sungho94.me/p/forward-proxy-reverse-proxy/</link><pubDate>Tue, 03 Oct 2023 22:58:54 +0000</pubDate><guid>https://sungho94.me/p/forward-proxy-reverse-proxy/</guid><description>&lt;h2 id="forward-proxy">Forward Proxy
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231003225905.png"
loading="lazy"
alt="Pasted image 20231003225905"
>&lt;/p>
&lt;blockquote>
&lt;p>A: 사용자의 가정용 컴퓨터&lt;br>
B: 정방향 프록시 서버&lt;br>
C: 웹 사이트의 원본 서버(웹 사이트 데이터가 저장되는 곳)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>일반적으로 사용되는 프록시 서버를 의미&lt;/li>
&lt;li>프록시가 없다면 A가 C로 직접 요청&lt;/li>
&lt;li>Forward Proxy가 있다면 A가 B로 요청하고 B가 다시 C로 호출함,
&lt;ul>
&lt;li>응답은 C-&amp;gt;B-&amp;gt;A순&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>사용이유
&lt;ul>
&lt;li>주 당국 또는 기관의 검색 제한을 피하기 위해&lt;/li>
&lt;li>온라인에서 자신의 신원을 보호하기 위해&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="reverse-proxy">Reverse Proxy
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231003225917.png"
loading="lazy"
alt="Pasted image 20231003225917"
>&lt;/p>
&lt;blockquote>
&lt;p>D: 사용자의 가정용 컴퓨터&lt;br>
E: 역방향 프록시 서버&lt;br>
F: 웹 사이트의 원본 서버(웹 사이트 데이터가 저장되는 곳)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>인터넷과 서버를 연결할 때 대신 요청을 받아 처리&lt;/li>
&lt;li>Forward Proxy는 클라이언트 보호가 목적이었다면, Reverse Proxy는 서버 보호가 목적&lt;/li>
&lt;li>사용이유
&lt;ul>
&lt;li>부하분산&lt;/li>
&lt;li>캐싱&lt;/li>
&lt;li>SSL 암호화&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.cloudflare.com/ko-kr/learning/cdn/glossary/reverse-proxy/" target="_blank" rel="noopener"
>https://www.cloudflare.com/ko-kr/learning/cdn/glossary/reverse-proxy/&lt;/a>&lt;/p>
&lt;p>#Concept&lt;/p></description></item><item><title>SPI(Service Provider Interface)</title><link>https://sungho94.me/p/spiservice-provider-interface/</link><pubDate>Tue, 03 Oct 2023 22:54:00 +0000</pubDate><guid>https://sungho94.me/p/spiservice-provider-interface/</guid><description>&lt;p>서비스를 확장, 구현하기위한 인터페이스&lt;/p>
&lt;p>api는 서비스를 사용하기위한 인터페이스라면, spi는 해당 서비스의 기능을 확장, 구현하기위한 인터페이스임&lt;br>
spi는 인터페이스, 클래스 혹은 추상클래스로 나타남&lt;br>
spi를 사용하므로서 클라이언트는 실제 구현을 신경쓰지 않고, 사용가능&lt;br>
ex) jdbc&lt;/p>
&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/Service_provider_interface" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Service_provider_interface&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/2954372/difference-between-spi-and-api" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/2954372/difference-between-spi-and-api&lt;/a>&lt;/p>
&lt;p>#Concept&lt;br>
#Definition&lt;/p></description></item><item><title>CPU bound, IO bound</title><link>https://sungho94.me/p/cpu-bound-io-bound/</link><pubDate>Tue, 03 Oct 2023 22:47:20 +0000</pubDate><guid>https://sungho94.me/p/cpu-bound-io-bound/</guid><description>&lt;h2 id="cpu-bound">Cpu Bound
&lt;/h2>&lt;ul>
&lt;li>CPU가 빨라지면 작업이 빨라지는 작업&lt;/li>
&lt;li>CPU를 사용하는것이 주요한 작업일 경우&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>π값 계산&lt;/p>
&lt;/blockquote>
&lt;h2 id="io-bound">I/O bound
&lt;/h2>&lt;ul>
&lt;li>I/O 작업이 많은것&lt;/li>
&lt;li>ex) 네트워크, 파일읽기&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>거대한 파일에서 특정 데이터 찾기&lt;/p>
&lt;/blockquote>
&lt;p>#Concept&lt;br>
#ComputerScience&lt;/p></description></item><item><title>Concurrency vs Parallelism</title><link>https://sungho94.me/p/concurrency-vs-parallelism/</link><pubDate>Tue, 03 Oct 2023 22:45:35 +0000</pubDate><guid>https://sungho94.me/p/concurrency-vs-parallelism/</guid><description>&lt;h3 id="concurrency동시성">Concurrency(동시성)
&lt;/h3>&lt;ul>
&lt;li>두개이상의 작업이 겹치는 기간에 시작, 실행, 완료될 수 있다는 것&lt;br>
ex) multitasking on a single-core machine.&lt;/li>
&lt;/ul>
&lt;h3 id="parallelism병렬성">Parallelism(병렬성)
&lt;/h3>&lt;ul>
&lt;li>말그대로 여러 task가 동시에 실행되는것&lt;br>
ex) multicore processor.&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://freecontent.manning.com/concurrency-vs-parallelism/" target="_blank" rel="noopener"
>https://freecontent.manning.com/concurrency-vs-parallelism/&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/1050222/what-is-the-difference-between-concurrency-and-parallelism" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/1050222/what-is-the-difference-between-concurrency-and-parallelism&lt;/a>&lt;/p>
&lt;p>#ComputerScience&lt;br>
#Concept&lt;/p></description></item><item><title>TSID(Sorted Unique Identifiers)</title><link>https://sungho94.me/p/tsidsorted-unique-identifiers/</link><pubDate>Tue, 03 Oct 2023 10:13:23 +0000</pubDate><guid>https://sungho94.me/p/tsidsorted-unique-identifiers/</guid><description>&lt;p>최근에 id 생성 관려해서 정보를 찾아보던중 TSID라는 것을 알게되었다&lt;br>&lt;br>twitter에서 개발한 snowflake id generator가 있다 &lt;br>분산처리환경에서 id를 생성하기 위해 만든 id 생성기인데 time값을 기반으로한다&lt;br>&lt;br>time값을 기반으로해서 시간순 정렬도 되고, +순차적인 정보라서 값이 겹칠일이 매우 적다.&lt;br>&lt;br>time값을 기반으로한 64비트 id generator인데 &lt;br>처음 1비트는 0 &lt;br>다음 41비트는 타임 스탬프값, &lt;br>다음 10비트는 machine과 관련된 정보(node id 같은것들?) &lt;br>다음 12비트는 같은 milisecond에 받은 순차적인정보로 이루어진다.&lt;br>&lt;br>java에서 snowflake를 구현한 라이브러리가 없는지 찾아봤는데 있긴한데 스타수가 적기도하고 마지막 업데이트가 4년전이라 쓰기도 약간 부담스러워 검색을 해보니 TSID아이디 generator라는걸 찾았다&lt;br>&lt;br>TSID는 snowflake_id와 ulid에서 아이디어를 얻어 만들었다고 한다.&lt;br>&lt;br>snowflake와 마찬가지로 처음 42비트는 시간 기반 값, 이후 22비트는 랜덤값(node id+counter)라고 한다.&lt;br>&lt;br>개인적으로 UUID보다 TSID가 퍼포먼스가 더 낫고, 다양한 상황에서 더 좋을거라 생각된다 &lt;br>단, star 수가 적고 다양한 환경에서 테스트가 안된점이 아쉽지만 시간이 해결해 줄 문제라고 생각한다&lt;br>&lt;br>UUID를 잘 사용하는법 &lt;br>&lt;a class="link" href="https://www.percona.com/blog/uuids-are-popular-but-bad-for-performance-lets-discuss/" target="_blank" rel="noopener"
>https://www.percona.com/blog/uuids-are-popular-but-bad-for-performance-lets-discuss/&lt;/a> &lt;br>&lt;a class="link" href="https://www.percona.com/blog/store-uuid-optimized-way/" target="_blank" rel="noopener"
>https://www.percona.com/blog/store-uuid-optimized-way/&lt;/a> &lt;br>&lt;a class="link" href="https://vladmihalcea.com/uuid-database-primary-key/" target="_blank" rel="noopener"
>https://vladmihalcea.com/uuid-database-primary-key/&lt;/a>&lt;br>&lt;br>&lt;a class="link" href="https://discord.com/developers/docs/reference#snowflakes" target="_blank" rel="noopener"
>https://discord.com/developers/docs/reference#snowflakes&lt;/a> &lt;br>&lt;a class="link" href="https://github.com/callicoder/java-snowflake" target="_blank" rel="noopener"
>https://github.com/callicoder/java-snowflake&lt;/a> &lt;br>&lt;a class="link" href="https://github.com/f4b6a3/tsid-creator" target="_blank" rel="noopener"
>https://github.com/f4b6a3/tsid-creator&lt;/a> &lt;br>&lt;a class="link" href="https://en.wikipedia.org/wiki/Snowflake_ID" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Snowflake_ID&lt;/a>|&lt;/p>
&lt;p>#Concept&lt;/p></description></item><item><title>동기 &amp; 비동기, 블로킹 &amp; 논블로킹</title><link>https://sungho94.me/p/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/</link><pubDate>Sat, 30 Sep 2023 14:47:58 +0000</pubDate><guid>https://sungho94.me/p/%EB%8F%99%EA%B8%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9/</guid><description>&lt;ul>
&lt;li>동기
&lt;ul>
&lt;li>서비스처리가 완료된 이후에 처리 결과를 확인하는 방식을 동기식 호출(결과가 올때까지 대기해야함)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비동기
&lt;ul>
&lt;li>서비스처리가 완료되기전에 우선 응답을 전달하는 방식(대기하는것을 방지)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>블로킹
&lt;ul>
&lt;li>요청한 작업이 성공하거나 에러가 발생하기 전까지는 응답을 돌려주지않는 것을 의미 (ServerSocket, Socket 클래스)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&amp;ldquo;Blocking&amp;rdquo; means that the caller waits until the callee finishes its processing.&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>논블로킹
&lt;ul>
&lt;li>요청한 작업의 성공여부와 상관없이 바로 결과를 돌려줌 (ServerSocketChannel, SocketChannel 클래스)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="왜-block-io보다-nonblock-io가-느릴까">왜 Block IO보다 NonBlock IO가 느릴까?
&lt;/h2>&lt;h2 id="block-io">Block I/O
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231105204457.png"
loading="lazy"
alt="Pasted image 20231105204457"
>&lt;/p>
&lt;ul>
&lt;li>데이터가 커널로 들어오면 데이터가 바로 커널스페이스에서 유저스페이스로 이동함&lt;/li>
&lt;/ul>
&lt;h2 id="non-block-io">Non Block I/O
&lt;/h2>&lt;ul>
&lt;li>방법이 2가지 있음&lt;/li>
&lt;/ul>
&lt;h3 id="데이터가-들어왔는지-반복해서-확인">데이터가 들어왔는지 반복해서 확인
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231105204700.png"
loading="lazy"
alt="Pasted image 20231105204700"
>&lt;/p>
&lt;ul>
&lt;li>우선 반복적으로 확인하기 때문에 cpu 자원낭비가 됨&lt;/li>
&lt;li>데이터가 들어온시점과 반복적으로 확인한 시점 사이에 시간차가 발생할 수 밖에 없기 때문에 Block I/O보다 느림&lt;/li>
&lt;/ul>
&lt;h3 id="데이터가-들어오면-알려-줌">데이터가 들어오면 알려 줌
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231105205052.png"
loading="lazy"
alt="Pasted image 20231105205052"
>&lt;/p>
&lt;ul>
&lt;li>데이터가 들어오면 커널에서 알려줌&lt;/li>
&lt;li>알려주면 쓰레드에서 read syscall을 날려서 데이터를 읽음&lt;/li>
&lt;li>커널에서 데이터가 들어온걸 알려주고, 쓰레드가 확인해서 해당 데이터를 가져오기 까지 시간 텀이 발생함&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.youtube.com/watch?v=mb-QHxVfmcs" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=mb-QHxVfmcs&lt;/a>&amp;amp;t=757s&lt;br>
&lt;a class="link" href="https://nesoy.github.io/articles/2017-01/Synchronized" target="_blank" rel="noopener"
>https://nesoy.github.io/articles/2017-01/Synchronized&lt;/a>&lt;br>
&lt;a class="link" href="https://d2.naver.com/helloworld/47667" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/47667&lt;/a>&lt;/p>
&lt;p>#Non-Blocking-IO&lt;/p></description></item><item><title>Static vs Dynamic,Strong vs Weak</title><link>https://sungho94.me/p/static-vs-dynamicstrong-vs-weak/</link><pubDate>Sat, 30 Sep 2023 14:44:40 +0000</pubDate><guid>https://sungho94.me/p/static-vs-dynamicstrong-vs-weak/</guid><description>&lt;h3 id="정적타입">정적타입
&lt;/h3>&lt;ul>
&lt;li>자료형을 컴파일시에 확인&lt;/li>
&lt;li>타입에러를 컴파일 시에 확인가능&lt;/li>
&lt;li>java, c&lt;/li>
&lt;/ul>
&lt;h3 id="동적타입">동적타입
&lt;/h3>&lt;ul>
&lt;li>자료형을 런타임시에 확인&lt;/li>
&lt;li>타입에 대한 고민을 뒤로 넘길 수 있음&lt;/li>
&lt;li>메서드가 다양한 기능을 할 수 있음&amp;hellip;&lt;/li>
&lt;li>런타임에 타입에러 발생 가능&lt;/li>
&lt;li>python, javascript&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="강타입">강타입
&lt;/h3>&lt;ul>
&lt;li>연관이 없는 타입끼리 형변환이 불가, 형변환시 명시적으로 선언해야함&lt;/li>
&lt;/ul>
&lt;h3 id="약타입">약타입
&lt;/h3>&lt;ul>
&lt;li>연관이 없는 타입끼리 암시적으로 형변환이 가능&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>&lt;a class="link" href="https://www.educative.io/answers/statically-v-dynamically-v-strongly-v-weakly-typed-languages" target="_blank" rel="noopener"
>https://www.educative.io/answers/statically-v-dynamically-v-strongly-v-weakly-typed-languages&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/11889602/difference-between-strong-vs-static-typing-and-weak-vs-dynamic-typing" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/11889602/difference-between-strong-vs-static-typing-and-weak-vs-dynamic-typing&lt;/a>&lt;/p></description></item></channel></rss>