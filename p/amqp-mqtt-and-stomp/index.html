<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="웹에서 실시간 상효작용을 위한 접근법 Polling 브라우저에서 반복적으로 서버를 호출하여 새로운 데이터가 있는지 확인함 효율적이지 못하며, 데이터 변경이 빈번하지 않을때 필요없는 요청이 너무 많이 발생함 Server-Sent Envent(SSEs) 폴링처럼 주기적으로 서버를 호출하는 대신, 개방형 연결(open connection)을 유지하여 서버가 데이터를 사용할 수 있을때, 클라이언트로 데이터를 전송함 불필요한 여러 요청과 응답으로 인한 오버헤드를 줄일 수 있음 SSE의 주요단점은 단방향임 서버는 데이터를 푸시할 수 있지만, 클라이언트는 동일한 연결을 통해 응답할 수 없기에, SSE는 일방적인 서버 업데이터에 이상적임 WebSocket 데이터를 반복적으로 요청하는 대신, 브라오저와 서버간에 통신라인을 열어둠 이로인해 웹소켓은 양방향 통신을 가능하게함 MQTT (Message Queuing Telemetry Transport) 배경 과거에는 거대한 외딴 지역의 데이터를 모니터링을 하는데 어려움이 있었음 불안정하고 대역폭이 낮은 네트워크, 모니터링 장치는 배터리로 작동하기 때문에 에너지절약이 필수적이 었음 이로인해 지속적인 통신이나 높은 네트워크 사용은 실용적이지 않았음 Light weight MQTT는 간결한 메시지와 컴팩트한 페이로드를 사용하여 네트워크를 통해 전송해야 하는 데이터 양을 줄인 최소한의 프로토콜로 설계됨 pub/sub이라는 단 하나의 메시지 패턴에만 집중함 QoS QoS레벨이 존재, 메시지 게시 시 QoS수준을 선택할 수 있음 QoS 0은 대역폭 사용량이 낮지만, 전송 보장도 낮음 QoS 2는 가장 높은 대역폭 사용량과 가장 높은 전송 보장을 제공 Last Will and Testament 연결의 불안정한 특성을 고려할때, 예기치 않은 연결이 발생할때 브로커가 전송한 last will(마지막 유언)을 설정할 수 있음 이 정보를 통해, subscriber는 유연한 대처가 가능함 일반적으로 connection time에 클라이언트에 의해 지정됨 Retained Message MQTT브로커는 Topic에 대해 마지막으로 알려진 메시지를 유지하여, 다운타임후 온라인 상태가 된 모든 드바이스다 즉시 최신메시지를 받을수 있도록 보장함 위와 같은 특성에서 MQTT는 다양한 시나리오에서 사용가능했음 현재 IoT 사용시에 이상적인 선택임 AMQP (Advanced Message Queuing Protocol) 모든 벤더가 구현할수 있는 프로토콜을 통해 서로 다른 시스템과 제품간의 상호 운영성을 보장한다는 비전을 바탕으로 탄생함 Open Standard 처음부터 개방형 표준으로 설계되었기에, 사양을 공개적으로 사용 가능함 모든 벤더나 개발자는 이러한 사양을 사용하여 제품이나 시스템에 AMQP를 구현할 수 있음 Reliable Message Deliveries 신뢰성을 보장하는 주요 메커니즘 중 하나는 승인임 메시지가 소비되면 브로커에게 확인을 전송하여 메시지가 처리되었음을 확인함 Flexibility 메시지가 먼저 Exchange로 이동한 다음 Queue로 이동함 Queue는 특정 패턴이나 기준에 따라 Exchange에 바인딩됨 이러한 바인딩 메커니즘은 다양한 Exchange유형과 결함되어 복잡한 라우팅 로직을 가능하게함 STOMP (Simple Text Oriented Messaging Protocol) 쉽게 구현하고 이해할 수 있는, 단순한 것을 만들기 위해 탄생함 Simplicity 미니멀리즘 방식으로 설계됨 기능이 많은 프로토컬의 오버헤드와 복잡성 없이 메시징에 필요한 기본 기능만 제공 아래와 같은 간단한 명령과 클래스가 존재함 Few Command CONNECT, CONNECTED, SEND, SUBSCRIBE, UNSUBSCRIBE, BEGIN, COMMIT, ABORT, ACK, NACK, MESSAGE, CRECEIPT, ERROR 풍부한 메서드 집합을 가진 AMQP와 대조됨 Connection Class Start, Start-Ok, Secure, Secure-Ok, Tune, Tune-Ok, Open, Open-Ok, Close, Close-Ok Channel Class Open, Open-Ok, Flow, Flow-Ok, Close, Close-Ok 적은 상태관리 STOMP는 상태저장기능이 있지만, AMQP는 세부적인 상태 관리 기능이 없음 AMQP는 Exchange, Queue, Binding등 다양한 속성을 지정하는 작업이 필요함 STOMP는 대상에게 메시지를 보내기만 하면 브로커가 세부사항을 처리함 Fewer Feature By Design STOMP는 일반적으로 메시징의 기본을 잘처리하는 것을 목표로 하며, AMQP에 있는 많은 고급 기능은 없거나, 더 높은 수준에서 구현됨 사용관점 뿐만 아니라 클라이언트 구현 관점에서도 STOMP를 단순하게 만듬 Text-Oriented 텍스트 기반이라 이해하고 디버깅하기 쉬움 원시 STOMP프레임을 보면 HTTP처럼 사람이 읽을 . 수있음 https://www.cloudamqp.com/blog/rabbitmq-and-websockets-part-1-amqp-mqtt-stomp.html\n"><title>AMQP, MQTT, and STOMP</title>
<link rel=canonical href=https://sungho94.me/p/amqp-mqtt-and-stomp/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="AMQP, MQTT, and STOMP"><meta property='og:description' content="웹에서 실시간 상효작용을 위한 접근법 Polling 브라우저에서 반복적으로 서버를 호출하여 새로운 데이터가 있는지 확인함 효율적이지 못하며, 데이터 변경이 빈번하지 않을때 필요없는 요청이 너무 많이 발생함 Server-Sent Envent(SSEs) 폴링처럼 주기적으로 서버를 호출하는 대신, 개방형 연결(open connection)을 유지하여 서버가 데이터를 사용할 수 있을때, 클라이언트로 데이터를 전송함 불필요한 여러 요청과 응답으로 인한 오버헤드를 줄일 수 있음 SSE의 주요단점은 단방향임 서버는 데이터를 푸시할 수 있지만, 클라이언트는 동일한 연결을 통해 응답할 수 없기에, SSE는 일방적인 서버 업데이터에 이상적임 WebSocket 데이터를 반복적으로 요청하는 대신, 브라오저와 서버간에 통신라인을 열어둠 이로인해 웹소켓은 양방향 통신을 가능하게함 MQTT (Message Queuing Telemetry Transport) 배경 과거에는 거대한 외딴 지역의 데이터를 모니터링을 하는데 어려움이 있었음 불안정하고 대역폭이 낮은 네트워크, 모니터링 장치는 배터리로 작동하기 때문에 에너지절약이 필수적이 었음 이로인해 지속적인 통신이나 높은 네트워크 사용은 실용적이지 않았음 Light weight MQTT는 간결한 메시지와 컴팩트한 페이로드를 사용하여 네트워크를 통해 전송해야 하는 데이터 양을 줄인 최소한의 프로토콜로 설계됨 pub/sub이라는 단 하나의 메시지 패턴에만 집중함 QoS QoS레벨이 존재, 메시지 게시 시 QoS수준을 선택할 수 있음 QoS 0은 대역폭 사용량이 낮지만, 전송 보장도 낮음 QoS 2는 가장 높은 대역폭 사용량과 가장 높은 전송 보장을 제공 Last Will and Testament 연결의 불안정한 특성을 고려할때, 예기치 않은 연결이 발생할때 브로커가 전송한 last will(마지막 유언)을 설정할 수 있음 이 정보를 통해, subscriber는 유연한 대처가 가능함 일반적으로 connection time에 클라이언트에 의해 지정됨 Retained Message MQTT브로커는 Topic에 대해 마지막으로 알려진 메시지를 유지하여, 다운타임후 온라인 상태가 된 모든 드바이스다 즉시 최신메시지를 받을수 있도록 보장함 위와 같은 특성에서 MQTT는 다양한 시나리오에서 사용가능했음 현재 IoT 사용시에 이상적인 선택임 AMQP (Advanced Message Queuing Protocol) 모든 벤더가 구현할수 있는 프로토콜을 통해 서로 다른 시스템과 제품간의 상호 운영성을 보장한다는 비전을 바탕으로 탄생함 Open Standard 처음부터 개방형 표준으로 설계되었기에, 사양을 공개적으로 사용 가능함 모든 벤더나 개발자는 이러한 사양을 사용하여 제품이나 시스템에 AMQP를 구현할 수 있음 Reliable Message Deliveries 신뢰성을 보장하는 주요 메커니즘 중 하나는 승인임 메시지가 소비되면 브로커에게 확인을 전송하여 메시지가 처리되었음을 확인함 Flexibility 메시지가 먼저 Exchange로 이동한 다음 Queue로 이동함 Queue는 특정 패턴이나 기준에 따라 Exchange에 바인딩됨 이러한 바인딩 메커니즘은 다양한 Exchange유형과 결함되어 복잡한 라우팅 로직을 가능하게함 STOMP (Simple Text Oriented Messaging Protocol) 쉽게 구현하고 이해할 수 있는, 단순한 것을 만들기 위해 탄생함 Simplicity 미니멀리즘 방식으로 설계됨 기능이 많은 프로토컬의 오버헤드와 복잡성 없이 메시징에 필요한 기본 기능만 제공 아래와 같은 간단한 명령과 클래스가 존재함 Few Command CONNECT, CONNECTED, SEND, SUBSCRIBE, UNSUBSCRIBE, BEGIN, COMMIT, ABORT, ACK, NACK, MESSAGE, CRECEIPT, ERROR 풍부한 메서드 집합을 가진 AMQP와 대조됨 Connection Class Start, Start-Ok, Secure, Secure-Ok, Tune, Tune-Ok, Open, Open-Ok, Close, Close-Ok Channel Class Open, Open-Ok, Flow, Flow-Ok, Close, Close-Ok 적은 상태관리 STOMP는 상태저장기능이 있지만, AMQP는 세부적인 상태 관리 기능이 없음 AMQP는 Exchange, Queue, Binding등 다양한 속성을 지정하는 작업이 필요함 STOMP는 대상에게 메시지를 보내기만 하면 브로커가 세부사항을 처리함 Fewer Feature By Design STOMP는 일반적으로 메시징의 기본을 잘처리하는 것을 목표로 하며, AMQP에 있는 많은 고급 기능은 없거나, 더 높은 수준에서 구현됨 사용관점 뿐만 아니라 클라이언트 구현 관점에서도 STOMP를 단순하게 만듬 Text-Oriented 텍스트 기반이라 이해하고 디버깅하기 쉬움 원시 STOMP프레임을 보면 HTTP처럼 사람이 읽을 . 수있음 https://www.cloudamqp.com/blog/rabbitmq-and-websockets-part-1-amqp-mqtt-stomp.html\n"><meta property='og:url' content='https://sungho94.me/p/amqp-mqtt-and-stomp/'><meta property='og:site_name' content="Sungho's Dev BLog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Infrastructure'><meta property='article:tag' content='RabbitMQ'><meta property='article:tag' content='MessagQueue'><meta property='article:tag' content='Protocol'><meta property='article:tag' content='hugo_blog'><meta property='article:published_time' content='2024-08-15T23:32:47+00:00'><meta property='article:modified_time' content='2024-09-05T01:29:28+00:00'><meta name=twitter:title content="AMQP, MQTT, and STOMP"><meta name=twitter:description content="웹에서 실시간 상효작용을 위한 접근법 Polling 브라우저에서 반복적으로 서버를 호출하여 새로운 데이터가 있는지 확인함 효율적이지 못하며, 데이터 변경이 빈번하지 않을때 필요없는 요청이 너무 많이 발생함 Server-Sent Envent(SSEs) 폴링처럼 주기적으로 서버를 호출하는 대신, 개방형 연결(open connection)을 유지하여 서버가 데이터를 사용할 수 있을때, 클라이언트로 데이터를 전송함 불필요한 여러 요청과 응답으로 인한 오버헤드를 줄일 수 있음 SSE의 주요단점은 단방향임 서버는 데이터를 푸시할 수 있지만, 클라이언트는 동일한 연결을 통해 응답할 수 없기에, SSE는 일방적인 서버 업데이터에 이상적임 WebSocket 데이터를 반복적으로 요청하는 대신, 브라오저와 서버간에 통신라인을 열어둠 이로인해 웹소켓은 양방향 통신을 가능하게함 MQTT (Message Queuing Telemetry Transport) 배경 과거에는 거대한 외딴 지역의 데이터를 모니터링을 하는데 어려움이 있었음 불안정하고 대역폭이 낮은 네트워크, 모니터링 장치는 배터리로 작동하기 때문에 에너지절약이 필수적이 었음 이로인해 지속적인 통신이나 높은 네트워크 사용은 실용적이지 않았음 Light weight MQTT는 간결한 메시지와 컴팩트한 페이로드를 사용하여 네트워크를 통해 전송해야 하는 데이터 양을 줄인 최소한의 프로토콜로 설계됨 pub/sub이라는 단 하나의 메시지 패턴에만 집중함 QoS QoS레벨이 존재, 메시지 게시 시 QoS수준을 선택할 수 있음 QoS 0은 대역폭 사용량이 낮지만, 전송 보장도 낮음 QoS 2는 가장 높은 대역폭 사용량과 가장 높은 전송 보장을 제공 Last Will and Testament 연결의 불안정한 특성을 고려할때, 예기치 않은 연결이 발생할때 브로커가 전송한 last will(마지막 유언)을 설정할 수 있음 이 정보를 통해, subscriber는 유연한 대처가 가능함 일반적으로 connection time에 클라이언트에 의해 지정됨 Retained Message MQTT브로커는 Topic에 대해 마지막으로 알려진 메시지를 유지하여, 다운타임후 온라인 상태가 된 모든 드바이스다 즉시 최신메시지를 받을수 있도록 보장함 위와 같은 특성에서 MQTT는 다양한 시나리오에서 사용가능했음 현재 IoT 사용시에 이상적인 선택임 AMQP (Advanced Message Queuing Protocol) 모든 벤더가 구현할수 있는 프로토콜을 통해 서로 다른 시스템과 제품간의 상호 운영성을 보장한다는 비전을 바탕으로 탄생함 Open Standard 처음부터 개방형 표준으로 설계되었기에, 사양을 공개적으로 사용 가능함 모든 벤더나 개발자는 이러한 사양을 사용하여 제품이나 시스템에 AMQP를 구현할 수 있음 Reliable Message Deliveries 신뢰성을 보장하는 주요 메커니즘 중 하나는 승인임 메시지가 소비되면 브로커에게 확인을 전송하여 메시지가 처리되었음을 확인함 Flexibility 메시지가 먼저 Exchange로 이동한 다음 Queue로 이동함 Queue는 특정 패턴이나 기준에 따라 Exchange에 바인딩됨 이러한 바인딩 메커니즘은 다양한 Exchange유형과 결함되어 복잡한 라우팅 로직을 가능하게함 STOMP (Simple Text Oriented Messaging Protocol) 쉽게 구현하고 이해할 수 있는, 단순한 것을 만들기 위해 탄생함 Simplicity 미니멀리즘 방식으로 설계됨 기능이 많은 프로토컬의 오버헤드와 복잡성 없이 메시징에 필요한 기본 기능만 제공 아래와 같은 간단한 명령과 클래스가 존재함 Few Command CONNECT, CONNECTED, SEND, SUBSCRIBE, UNSUBSCRIBE, BEGIN, COMMIT, ABORT, ACK, NACK, MESSAGE, CRECEIPT, ERROR 풍부한 메서드 집합을 가진 AMQP와 대조됨 Connection Class Start, Start-Ok, Secure, Secure-Ok, Tune, Tune-Ok, Open, Open-Ok, Close, Close-Ok Channel Class Open, Open-Ok, Flow, Flow-Ok, Close, Close-Ok 적은 상태관리 STOMP는 상태저장기능이 있지만, AMQP는 세부적인 상태 관리 기능이 없음 AMQP는 Exchange, Queue, Binding등 다양한 속성을 지정하는 작업이 필요함 STOMP는 대상에게 메시지를 보내기만 하면 브로커가 세부사항을 처리함 Fewer Feature By Design STOMP는 일반적으로 메시징의 기본을 잘처리하는 것을 목표로 하며, AMQP에 있는 많은 고급 기능은 없거나, 더 높은 수준에서 구현됨 사용관점 뿐만 아니라 클라이언트 구현 관점에서도 STOMP를 단순하게 만듬 Text-Oriented 텍스트 기반이라 이해하고 디버깅하기 쉬움 원시 STOMP프레임을 보면 HTTP처럼 사람이 읽을 . 수있음 https://www.cloudamqp.com/blog/rabbitmq-and-websockets-part-1-amqp-mqtt-stomp.html\n"><link rel="shortcut icon" href=/favicon.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-PTKY5BPR7H"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PTKY5BPR7H")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu1582294339771580780.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Sungho's Dev BLog</a></h1><h2 class=site-description>백엔드 개발자 황성호입니다.</h2></div></header><ol class=menu-social><li><a href=https://github.com/Star-ho target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/starho/ target=_blank title=LinkedIn rel=me><svg fill="#000" width="800" height="800" viewBox="0 0 24 24"><path d="M6.975 20.667H3.117V9.059H6.975zM5.072 3.462a2.011 2.011.0 10-.051 4.012h.026a2.012 2.012.0 10.025-4.012zM9.111 20.667h3.858V14.185a2.639 2.639.0 01.127-.941 2.111 2.111.0 011.98-1.411c1.4.0 1.955 1.064 1.955 2.625v6.209h3.858V14.011c0-3.565-1.9-5.225-4.442-5.225A3.828 3.828.0 0012.97 10.7V9.059H9.111c.051 1.089.0 11.609.0 11.609z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#웹에서-실시간-상효작용을-위한-접근법>웹에서 실시간 상효작용을 위한 접근법</a></li><li><a href=#mqtt-message-queuing-telemetry-transport>MQTT (Message Queuing Telemetry Transport)</a></li><li><a href=#amqp-advanced-message-queuing-protocol>AMQP (Advanced Message Queuing Protocol)</a></li><li><a href=#stomp-simple-text-oriented-messaging-protocol>STOMP (Simple Text Oriented Messaging Protocol)</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/rabbitmq/>RabbitMQ</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/amqp-mqtt-and-stomp/>AMQP, MQTT, and STOMP</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 15, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>3 분 정도</time></div></footer></div></header><section class=article-content><h2 id=웹에서-실시간-상효작용을-위한-접근법>웹에서 실시간 상효작용을 위한 접근법</h2><ul><li>Polling<ul><li>브라우저에서 반복적으로 서버를 호출하여 새로운 데이터가 있는지 확인함</li><li>효율적이지 못하며, 데이터 변경이 빈번하지 않을때 필요없는 요청이 너무 많이 발생함</li></ul></li><li>Server-Sent Envent(SSEs)<ul><li>폴링처럼 주기적으로 서버를 호출하는 대신, 개방형 연결(open connection)을 유지하여 서버가 데이터를 사용할 수 있을때, 클라이언트로 데이터를 전송함</li><li>불필요한 여러 요청과 응답으로 인한 오버헤드를 줄일 수 있음</li><li>SSE의 주요단점은 단방향임</li><li>서버는 데이터를 푸시할 수 있지만, 클라이언트는 동일한 연결을 통해 응답할 수 없기에, SSE는 일방적인 서버 업데이터에 이상적임</li></ul></li><li>WebSocket<ul><li>데이터를 반복적으로 요청하는 대신, 브라오저와 서버간에 통신라인을 열어둠</li><li>이로인해 웹소켓은 양방향 통신을 가능하게함</li></ul></li></ul><h2 id=mqtt-message-queuing-telemetry-transport>MQTT (Message Queuing Telemetry Transport)</h2><ul><li>배경<ul><li>과거에는 거대한 외딴 지역의 데이터를 모니터링을 하는데 어려움이 있었음</li><li>불안정하고 대역폭이 낮은 네트워크, 모니터링 장치는 배터리로 작동하기 때문에 에너지절약이 필수적이 었음</li><li>이로인해 지속적인 통신이나 높은 네트워크 사용은 실용적이지 않았음</li></ul></li><li>Light weight<ul><li>MQTT는 간결한 메시지와 컴팩트한 페이로드를 사용하여 네트워크를 통해 전송해야 하는 데이터 양을 줄인 최소한의 프로토콜로 설계됨</li><li>pub/sub이라는 단 하나의 메시지 패턴에만 집중함</li></ul></li><li>QoS<ul><li>QoS레벨이 존재, 메시지 게시 시 QoS수준을 선택할 수 있음</li><li>QoS 0은 대역폭 사용량이 낮지만, 전송 보장도 낮음</li><li>QoS 2는 가장 높은 대역폭 사용량과 가장 높은 전송 보장을 제공</li></ul></li><li>Last Will and Testament<ul><li>연결의 불안정한 특성을 고려할때, 예기치 않은 연결이 발생할때 브로커가 전송한 last will(마지막 유언)을 설정할 수 있음</li><li>이 정보를 통해, subscriber는 유연한 대처가 가능함</li><li>일반적으로 connection time에 클라이언트에 의해 지정됨</li></ul></li><li>Retained Message<ul><li>MQTT브로커는 Topic에 대해 마지막으로 알려진 메시지를 유지하여, 다운타임후 온라인 상태가 된 모든 드바이스다 즉시 최신메시지를 받을수 있도록 보장함</li></ul></li><li>위와 같은 특성에서 MQTT는 다양한 시나리오에서 사용가능했음</li><li>현재 IoT 사용시에 이상적인 선택임</li></ul><h2 id=amqp-advanced-message-queuing-protocol>AMQP (Advanced Message Queuing Protocol)</h2><ul><li>모든 벤더가 구현할수 있는 프로토콜을 통해 서로 다른 시스템과 제품간의 상호 운영성을 보장한다는 비전을 바탕으로 탄생함</li><li>Open Standard<ul><li>처음부터 개방형 표준으로 설계되었기에, 사양을 공개적으로 사용 가능함</li><li>모든 벤더나 개발자는 이러한 사양을 사용하여 제품이나 시스템에 AMQP를 구현할 수 있음</li></ul></li><li>Reliable Message Deliveries<ul><li>신뢰성을 보장하는 주요 메커니즘 중 하나는 승인임</li><li>메시지가 소비되면 브로커에게 확인을 전송하여 메시지가 처리되었음을 확인함</li></ul></li><li>Flexibility<ul><li>메시지가 먼저 Exchange로 이동한 다음 Queue로 이동함</li><li>Queue는 특정 패턴이나 기준에 따라 Exchange에 바인딩됨</li><li>이러한 바인딩 메커니즘은 다양한 Exchange유형과 결함되어 복잡한 라우팅 로직을 가능하게함</li></ul></li></ul><h2 id=stomp-simple-text-oriented-messaging-protocol>STOMP (Simple Text Oriented Messaging Protocol)</h2><ul><li>쉽게 구현하고 이해할 수 있는, 단순한 것을 만들기 위해 탄생함</li><li>Simplicity<ul><li>미니멀리즘 방식으로 설계됨</li><li>기능이 많은 프로토컬의 오버헤드와 복잡성 없이 메시징에 필요한 기본 기능만 제공</li><li>아래와 같은 간단한 명령과 클래스가 존재함<ul><li>Few Command<ul><li>CONNECT, CONNECTED, SEND, SUBSCRIBE, UNSUBSCRIBE, BEGIN, COMMIT, ABORT, ACK, NACK, MESSAGE, CRECEIPT, ERROR</li><li>풍부한 메서드 집합을 가진 AMQP와 대조됨</li></ul></li><li>Connection Class<ul><li>Start, Start-Ok, Secure, Secure-Ok, Tune, Tune-Ok, Open, Open-Ok, Close, Close-Ok</li></ul></li><li>Channel Class<ul><li>Open, Open-Ok, Flow, Flow-Ok, Close, Close-Ok</li></ul></li></ul></li><li>적은 상태관리<ul><li>STOMP는 상태저장기능이 있지만, AMQP는 세부적인 상태 관리 기능이 없음</li><li>AMQP는 Exchange, Queue, Binding등 다양한 속성을 지정하는 작업이 필요함</li><li>STOMP는 대상에게 메시지를 보내기만 하면 브로커가 세부사항을 처리함</li></ul></li><li>Fewer Feature By Design<ul><li>STOMP는 일반적으로 메시징의 기본을 잘처리하는 것을 목표로 하며, AMQP에 있는 많은 고급 기능은 없거나, 더 높은 수준에서 구현됨</li><li>사용관점 뿐만 아니라 클라이언트 구현 관점에서도 STOMP를 단순하게 만듬</li></ul></li></ul></li><li>Text-Oriented<ul><li>텍스트 기반이라 이해하고 디버깅하기 쉬움</li><li>원시 STOMP프레임을 보면 HTTP처럼 사람이 읽을 . 수있음</li></ul></li></ul><p><a class=link href=https://www.cloudamqp.com/blog/rabbitmq-and-websockets-part-1-amqp-mqtt-stomp.html target=_blank rel=noopener>https://www.cloudamqp.com/blog/rabbitmq-and-websockets-part-1-amqp-mqtt-stomp.html</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/infrastructure/>Infrastructure</a>
<a href=/tags/rabbitmq/>RabbitMQ</a>
<a href=/tags/messagqueue/>MessagQueue</a>
<a href=/tags/protocol/>Protocol</a>
<a href=/tags/hugo_blog/>Hugo_blog</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>마지막 수정: Sep 05, 2024 01:29 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/queue/><div class=article-details><h2 class=article-title>Queue</h2></div></a></article><article><a href=/p/amqp-0-9-1-model/><div class=article-details><h2 class=article-title>AMQP 0-9-1 Model</h2></div></a></article><article><a href=/p/subscriber/><div class=article-details><h2 class=article-title>Subscriber</h2></div></a></article><article><a href=/p/publisher/><div class=article-details><h2 class=article-title>Publisher</h2></div></a></article><article><a href=/p/exchange-and-binding/><div class=article-details><h2 class=article-title>Exchange and binding</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=Star-ho/star-ho.github.io issue-term=pathname label=Comments crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Sungho's Dev BLog</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>