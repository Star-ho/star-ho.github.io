<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content=' suspend함수는 Continuation을 다른 suspend함수에 전달해야 함 일반함수에서 suspend를 호출 할 수 없음 어디서 suspend함수를 호출해야 하는가? Coroutine builder 일반세계와 \bsuspend세계를 연결하는 다리역할 launch 개념적으로 새로운 쓰레드를 생성하는 것과 유사함 코루틴을 시작하고, 독립적으로 실행함 1 2 3 4 5 6 7 8 9 10 11 12 public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -> Unit ): Job { val newContext = newCoroutineContext(context) val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) coroutine.start(start, coroutine, block) return coroutine } CoroutineScope의 extension function임 coroutine context를 받아, 해당 context내에서 3번쨰 인자로 받은 block을 실행시킴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun main() { GlobalScope.launch { delay(1000L) println("World!") } GlobalScope.launch { delay(1000L) println("World!") } println("Hello,") Thread.sleep(1500L) }// Hello, // (1 sec) // World! // World! main 함수에서 Thread.sleep()을 호출하지 않는다면, Hello만 출력됨 launch내의 delay는 실제로 쓰레드를 block하지 않음 async 1 2 3 4 5 6 7 8 9 10 11 12 public fun <T> CoroutineScope.async( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -> T ): Deferred<T> { val newContext = newCoroutineContext(context) val coroutine = if (start.isLazy) LazyDeferredCoroutine(newContext, block) else DeferredCoroutine<T>(newContext, active = true) coroutine.start(start, coroutine, block) return coroutine } launch와 비슷하지만 async는 값을 Deferred로 감싸서 return함 Deferred는 suspending method await를 가짐 값이 준비되면 Deferred에 저장되고, await호출시 값을 리턴함\x1c 값이 준비되기전 await호출 시, 값이 준비될 떄까지 suspend됨 runBlocking 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Throws(InterruptedException::class) public actual fun <T> runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -> T): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } val currentThread = Thread.currentThread() val contextInterceptor = context[ContinuationInterceptor] val eventLoop: EventLoop? val newContext: CoroutineContext if (contextInterceptor == null) { // create or use private event loop if no dispatcher is specified eventLoop = ThreadLocalEventLoop.eventLoop newContext = GlobalScope.newCoroutineContext(context + eventLoop) } else { // See if context&#39;s interceptor is an event loop that we shall use (to support TestContext) // or take an existing thread-local event loop if present to avoid blocking it (but don&#39;t create one) eventLoop = (contextInterceptor as? EventLoop)?.takeIf { it.shouldBeProcessedFromContext() } ?: ThreadLocalEventLoop.currentOrNull() newContext = GlobalScope.newCoroutineContext(context) } val coroutine = BlockingCoroutine<T>(newContext, currentThread, eventLoop) coroutine.start(CoroutineStart.DEFAULT, coroutine, block) return coroutine.joinBlocking() } coroutine의 일반적인 규칙은 thread를 block하지 않는다 이지만, runblocking은 다른 coroutine builder와는 다르게 쓰레드를 block함 main function과 같이, 쓰레드를 block하지마 않으면 프로세스가 종료되기 때문에 이러한 경우 runBlocking을 사용해야함 runBlocking은 새로운 코루틴을 실행하고, 현재 쓰레드를 코루틴이 완료될 때 까지 block함 runBlocking인자로 Dispatcher를 전달하여 다른 쓰레드에서 runBlocking을 실행하게 할 수 있음 다른 쓰레드에서 runBlocking을 실행해도 runBlocking을 실행한 쓰레드를 Block함 Dispatcher는 코루틴을 실행할 쓰레드를 선택하는 것으로, 현재 쓰레드를 block하는 것을 막을 수 없음 CoroutineScope의 확장함수가 아님, CoroutineScope외부에서 사용 가능 완료될때까지 쓰레드를 block하므로 CoroutineScope외부에서 사용하는건 권장하지 않음 Structured Concurrency launch와 async함수는 CoroutineScope의 extenstion함수 임\n'><title>6-Coroutine builder</title>
<link rel=canonical href=https://sungho94.me/p/6-coroutine-builder/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="6-Coroutine builder"><meta property='og:description' content=' suspend함수는 Continuation을 다른 suspend함수에 전달해야 함 일반함수에서 suspend를 호출 할 수 없음 어디서 suspend함수를 호출해야 하는가? Coroutine builder 일반세계와 \bsuspend세계를 연결하는 다리역할 launch 개념적으로 새로운 쓰레드를 생성하는 것과 유사함 코루틴을 시작하고, 독립적으로 실행함 1 2 3 4 5 6 7 8 9 10 11 12 public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -> Unit ): Job { val newContext = newCoroutineContext(context) val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) coroutine.start(start, coroutine, block) return coroutine } CoroutineScope의 extension function임 coroutine context를 받아, 해당 context내에서 3번쨰 인자로 받은 block을 실행시킴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun main() { GlobalScope.launch { delay(1000L) println("World!") } GlobalScope.launch { delay(1000L) println("World!") } println("Hello,") Thread.sleep(1500L) }// Hello, // (1 sec) // World! // World! main 함수에서 Thread.sleep()을 호출하지 않는다면, Hello만 출력됨 launch내의 delay는 실제로 쓰레드를 block하지 않음 async 1 2 3 4 5 6 7 8 9 10 11 12 public fun <T> CoroutineScope.async( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -> T ): Deferred<T> { val newContext = newCoroutineContext(context) val coroutine = if (start.isLazy) LazyDeferredCoroutine(newContext, block) else DeferredCoroutine<T>(newContext, active = true) coroutine.start(start, coroutine, block) return coroutine } launch와 비슷하지만 async는 값을 Deferred로 감싸서 return함 Deferred는 suspending method await를 가짐 값이 준비되면 Deferred에 저장되고, await호출시 값을 리턴함\x1c 값이 준비되기전 await호출 시, 값이 준비될 떄까지 suspend됨 runBlocking 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Throws(InterruptedException::class) public actual fun <T> runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -> T): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } val currentThread = Thread.currentThread() val contextInterceptor = context[ContinuationInterceptor] val eventLoop: EventLoop? val newContext: CoroutineContext if (contextInterceptor == null) { // create or use private event loop if no dispatcher is specified eventLoop = ThreadLocalEventLoop.eventLoop newContext = GlobalScope.newCoroutineContext(context + eventLoop) } else { // See if context&#39;s interceptor is an event loop that we shall use (to support TestContext) // or take an existing thread-local event loop if present to avoid blocking it (but don&#39;t create one) eventLoop = (contextInterceptor as? EventLoop)?.takeIf { it.shouldBeProcessedFromContext() } ?: ThreadLocalEventLoop.currentOrNull() newContext = GlobalScope.newCoroutineContext(context) } val coroutine = BlockingCoroutine<T>(newContext, currentThread, eventLoop) coroutine.start(CoroutineStart.DEFAULT, coroutine, block) return coroutine.joinBlocking() } coroutine의 일반적인 규칙은 thread를 block하지 않는다 이지만, runblocking은 다른 coroutine builder와는 다르게 쓰레드를 block함 main function과 같이, 쓰레드를 block하지마 않으면 프로세스가 종료되기 때문에 이러한 경우 runBlocking을 사용해야함 runBlocking은 새로운 코루틴을 실행하고, 현재 쓰레드를 코루틴이 완료될 때 까지 block함 runBlocking인자로 Dispatcher를 전달하여 다른 쓰레드에서 runBlocking을 실행하게 할 수 있음 다른 쓰레드에서 runBlocking을 실행해도 runBlocking을 실행한 쓰레드를 Block함 Dispatcher는 코루틴을 실행할 쓰레드를 선택하는 것으로, 현재 쓰레드를 block하는 것을 막을 수 없음 CoroutineScope의 확장함수가 아님, CoroutineScope외부에서 사용 가능 완료될때까지 쓰레드를 block하므로 CoroutineScope외부에서 사용하는건 권장하지 않음 Structured Concurrency launch와 async함수는 CoroutineScope의 extenstion함수 임\n'><meta property='og:url' content='https://sungho94.me/p/6-coroutine-builder/'><meta property='og:site_name' content="Sungho's Dev BLog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='hugo_blog'><meta property='article:tag' content='Coroutine'><meta property='article:tag' content='JVM'><meta property='article:published_time' content='2024-03-03T22:41:07+00:00'><meta property='article:modified_time' content='2024-09-22T07:06:53+00:00'><meta name=twitter:title content="6-Coroutine builder"><meta name=twitter:description content=' suspend함수는 Continuation을 다른 suspend함수에 전달해야 함 일반함수에서 suspend를 호출 할 수 없음 어디서 suspend함수를 호출해야 하는가? Coroutine builder 일반세계와 \bsuspend세계를 연결하는 다리역할 launch 개념적으로 새로운 쓰레드를 생성하는 것과 유사함 코루틴을 시작하고, 독립적으로 실행함 1 2 3 4 5 6 7 8 9 10 11 12 public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -> Unit ): Job { val newContext = newCoroutineContext(context) val coroutine = if (start.isLazy) LazyStandaloneCoroutine(newContext, block) else StandaloneCoroutine(newContext, active = true) coroutine.start(start, coroutine, block) return coroutine } CoroutineScope의 extension function임 coroutine context를 받아, 해당 context내에서 3번쨰 인자로 받은 block을 실행시킴 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fun main() { GlobalScope.launch { delay(1000L) println("World!") } GlobalScope.launch { delay(1000L) println("World!") } println("Hello,") Thread.sleep(1500L) }// Hello, // (1 sec) // World! // World! main 함수에서 Thread.sleep()을 호출하지 않는다면, Hello만 출력됨 launch내의 delay는 실제로 쓰레드를 block하지 않음 async 1 2 3 4 5 6 7 8 9 10 11 12 public fun <T> CoroutineScope.async( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -> T ): Deferred<T> { val newContext = newCoroutineContext(context) val coroutine = if (start.isLazy) LazyDeferredCoroutine(newContext, block) else DeferredCoroutine<T>(newContext, active = true) coroutine.start(start, coroutine, block) return coroutine } launch와 비슷하지만 async는 값을 Deferred로 감싸서 return함 Deferred는 suspending method await를 가짐 값이 준비되면 Deferred에 저장되고, await호출시 값을 리턴함\x1c 값이 준비되기전 await호출 시, 값이 준비될 떄까지 suspend됨 runBlocking 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Throws(InterruptedException::class) public actual fun <T> runBlocking(context: CoroutineContext, block: suspend CoroutineScope.() -> T): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } val currentThread = Thread.currentThread() val contextInterceptor = context[ContinuationInterceptor] val eventLoop: EventLoop? val newContext: CoroutineContext if (contextInterceptor == null) { // create or use private event loop if no dispatcher is specified eventLoop = ThreadLocalEventLoop.eventLoop newContext = GlobalScope.newCoroutineContext(context + eventLoop) } else { // See if context&#39;s interceptor is an event loop that we shall use (to support TestContext) // or take an existing thread-local event loop if present to avoid blocking it (but don&#39;t create one) eventLoop = (contextInterceptor as? EventLoop)?.takeIf { it.shouldBeProcessedFromContext() } ?: ThreadLocalEventLoop.currentOrNull() newContext = GlobalScope.newCoroutineContext(context) } val coroutine = BlockingCoroutine<T>(newContext, currentThread, eventLoop) coroutine.start(CoroutineStart.DEFAULT, coroutine, block) return coroutine.joinBlocking() } coroutine의 일반적인 규칙은 thread를 block하지 않는다 이지만, runblocking은 다른 coroutine builder와는 다르게 쓰레드를 block함 main function과 같이, 쓰레드를 block하지마 않으면 프로세스가 종료되기 때문에 이러한 경우 runBlocking을 사용해야함 runBlocking은 새로운 코루틴을 실행하고, 현재 쓰레드를 코루틴이 완료될 때 까지 block함 runBlocking인자로 Dispatcher를 전달하여 다른 쓰레드에서 runBlocking을 실행하게 할 수 있음 다른 쓰레드에서 runBlocking을 실행해도 runBlocking을 실행한 쓰레드를 Block함 Dispatcher는 코루틴을 실행할 쓰레드를 선택하는 것으로, 현재 쓰레드를 block하는 것을 막을 수 없음 CoroutineScope의 확장함수가 아님, CoroutineScope외부에서 사용 가능 완료될때까지 쓰레드를 block하므로 CoroutineScope외부에서 사용하는건 권장하지 않음 Structured Concurrency launch와 async함수는 CoroutineScope의 extenstion함수 임\n'><link rel="shortcut icon" href=/favicon.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-PTKY5BPR7H"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PTKY5BPR7H")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu1582294339771580780.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Sungho's Dev BLog</a></h1><h2 class=site-description>백엔드 개발자 황성호입니다.</h2></div></header><ol class=menu-social><li><a href=https://github.com/Star-ho target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/starho/ target=_blank title=LinkedIn rel=me><svg fill="#000" width="800" height="800" viewBox="0 0 24 24"><path d="M6.975 20.667H3.117V9.059H6.975zM5.072 3.462a2.011 2.011.0 10-.051 4.012h.026a2.012 2.012.0 10.025-4.012zM9.111 20.667h3.858V14.185a2.639 2.639.0 01.127-.941 2.111 2.111.0 011.98-1.411c1.4.0 1.955 1.064 1.955 2.625v6.209h3.858V14.011c0-3.565-1.9-5.225-4.442-5.225A3.828 3.828.0 0012.97 10.7V9.059H9.111c.051 1.089.0 11.609.0 11.609z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#launch>launch</a></li><li><a href=#async>async</a></li><li><a href=#runblocking>runBlocking</a></li><li><a href=#structured-concurrency>Structured Concurrency</a></li><li><a href=#withcontext>withContext</a></li><li><a href=#coroutinestart>CoroutineStart</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/coroutine/>Coroutine
</a><a href=/categories/coroutine-series/>Coroutine-Series</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/6-coroutine-builder/>6-Coroutine builder</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 03, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>5 분 정도</time></div></footer></div></header><section class=article-content><ul><li>suspend함수는 Continuation을 다른 suspend함수에 전달해야 함</li><li>일반함수에서 suspend를 호출 할 수 없음</li><li>어디서 suspend함수를 호출해야 하는가?</li><li><strong>Coroutine builder</strong></li><li>일반세계와 suspend세계를 연결하는 다리역할</li></ul><h2 id=launch>launch</h2><ul><li>개념적으로 새로운 쓰레드를 생성하는 것과 유사함</li><li>코루틴을 시작하고, 독립적으로 실행함</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>public</span> <span class=k>fun</span> <span class=nf>CoroutineScope</span><span class=p>.</span><span class=n>launch</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=p>:</span> <span class=n>CoroutineContext</span> <span class=p>=</span> <span class=n>EmptyCoroutineContext</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>    <span class=n>start</span><span class=p>:</span> <span class=n>CoroutineStart</span> <span class=p>=</span> <span class=nc>CoroutineStart</span><span class=p>.</span><span class=n>DEFAULT</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>    <span class=n>block</span><span class=p>:</span> <span class=k>suspend</span> <span class=nc>CoroutineScope</span><span class=p>.()</span> <span class=o>-&gt;</span> <span class=n>Unit</span>  
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>Job</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>newContext</span> <span class=p>=</span> <span class=n>newCoroutineContext</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>coroutine</span> <span class=p>=</span> <span class=k>if</span> <span class=p>(</span><span class=n>start</span><span class=p>.</span><span class=n>isLazy</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=n>LazyStandaloneCoroutine</span><span class=p>(</span><span class=n>newContext</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span> <span class=k>else</span>  
</span></span><span class=line><span class=cl>        <span class=n>StandaloneCoroutine</span><span class=p>(</span><span class=n>newContext</span><span class=p>,</span> <span class=n>active</span> <span class=p>=</span> <span class=k>true</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=n>coroutine</span><span class=p>.</span><span class=n>start</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>coroutine</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>coroutine</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>CoroutineScope의 extension function임</li><li>coroutine context를 받아, 해당 context내에서 3번쨰 인자로 받은 block을 실행시킴</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=nc>GlobalScope</span><span class=p>.</span><span class=n>launch</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>delay</span><span class=p>(</span><span class=m>1000L</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;World!&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>      
</span></span><span class=line><span class=cl>    <span class=nc>GlobalScope</span><span class=p>.</span><span class=n>launch</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>delay</span><span class=p>(</span><span class=m>1000L</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;World!&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>(</span><span class=s2>&#34;Hello,&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=nc>Thread</span><span class=p>.</span><span class=n>sleep</span><span class=p>(</span><span class=m>1500L</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=p>}</span><span class=c1>// Hello,  
</span></span></span><span class=line><span class=cl><span class=c1>// (1 sec)  
</span></span></span><span class=line><span class=cl><span class=c1>// World!  
</span></span></span><span class=line><span class=cl><span class=c1>// World!  
</span></span></span></code></pre></td></tr></table></div></div><ul><li>main 함수에서 Thread.sleep()을 호출하지 않는다면, Hello만 출력됨<ul><li>launch내의 delay는 실제로 쓰레드를 block하지 않음</li></ul></li></ul><h2 id=async>async</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>public</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>CoroutineScope</span><span class=p>.</span><span class=n>async</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=p>:</span> <span class=n>CoroutineContext</span> <span class=p>=</span> <span class=n>EmptyCoroutineContext</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>    <span class=n>start</span><span class=p>:</span> <span class=n>CoroutineStart</span> <span class=p>=</span> <span class=nc>CoroutineStart</span><span class=p>.</span><span class=n>DEFAULT</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>    <span class=n>block</span><span class=p>:</span> <span class=k>suspend</span> <span class=nc>CoroutineScope</span><span class=p>.()</span> <span class=o>-&gt;</span> <span class=n>T</span>  
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>Deferred</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>newContext</span> <span class=p>=</span> <span class=n>newCoroutineContext</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>coroutine</span> <span class=p>=</span> <span class=k>if</span> <span class=p>(</span><span class=n>start</span><span class=p>.</span><span class=n>isLazy</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=n>LazyDeferredCoroutine</span><span class=p>(</span><span class=n>newContext</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span> <span class=k>else</span>  
</span></span><span class=line><span class=cl>        <span class=n>DeferredCoroutine</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;(</span><span class=n>newContext</span><span class=p>,</span> <span class=n>active</span> <span class=p>=</span> <span class=k>true</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=n>coroutine</span><span class=p>.</span><span class=n>start</span><span class=p>(</span><span class=n>start</span><span class=p>,</span> <span class=n>coroutine</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>coroutine</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>launch와 비슷하지만 async는 값을 Deferred로 감싸서 return함</li><li>Deferred는 suspending method await를 가짐<ul><li>값이 준비되면 Deferred에 저장되고, await호출시 값을 리턴함</li><li>값이 준비되기전 await호출 시, 값이 준비될 떄까지 suspend됨</li></ul></li></ul><h2 id=runblocking>runBlocking</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nd>@Throws</span><span class=p>(</span><span class=n>InterruptedException</span><span class=o>::</span><span class=k>class</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>actual</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>runBlocking</span><span class=p>(</span><span class=n>context</span><span class=p>:</span> <span class=n>CoroutineContext</span><span class=p>,</span> <span class=n>block</span><span class=p>:</span> <span class=k>suspend</span> <span class=nc>CoroutineScope</span><span class=p>.()</span> <span class=o>-&gt;</span> <span class=n>T</span><span class=p>):</span> <span class=n>T</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>contract</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>callsInPlace</span><span class=p>(</span><span class=n>block</span><span class=p>,</span> <span class=nc>InvocationKind</span><span class=p>.</span><span class=n>EXACTLY_ONCE</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>currentThread</span> <span class=p>=</span> <span class=nc>Thread</span><span class=p>.</span><span class=n>currentThread</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>contextInterceptor</span> <span class=p>=</span> <span class=n>context</span><span class=p>[</span><span class=n>ContinuationInterceptor</span><span class=p>]</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>eventLoop</span><span class=p>:</span> <span class=n>EventLoop</span><span class=p>?</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>newContext</span><span class=p>:</span> <span class=n>CoroutineContext</span>  
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>contextInterceptor</span> <span class=o>==</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// create or use private event loop if no dispatcher is specified  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>eventLoop</span> <span class=p>=</span> <span class=nc>ThreadLocalEventLoop</span><span class=p>.</span><span class=n>eventLoop</span>  
</span></span><span class=line><span class=cl>        <span class=n>newContext</span> <span class=p>=</span> <span class=nc>GlobalScope</span><span class=p>.</span><span class=n>newCoroutineContext</span><span class=p>(</span><span class=n>context</span> <span class=p>+</span> <span class=n>eventLoop</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// See if context&#39;s interceptor is an event loop that we shall use (to support TestContext)  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// or take an existing thread-local event loop if present to avoid blocking it (but don&#39;t create one)        
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>eventLoop</span> <span class=p>=</span> <span class=p>(</span><span class=n>contextInterceptor</span> <span class=k>as</span><span class=p>?</span> <span class=n>EventLoop</span><span class=p>)</span><span class=o>?.</span><span class=n>takeIf</span> <span class=p>{</span> <span class=k>it</span><span class=p>.</span><span class=n>shouldBeProcessedFromContext</span><span class=p>()</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl>            <span class=o>?:</span> <span class=nc>ThreadLocalEventLoop</span><span class=p>.</span><span class=n>currentOrNull</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>        <span class=n>newContext</span> <span class=p>=</span> <span class=nc>GlobalScope</span><span class=p>.</span><span class=n>newCoroutineContext</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>coroutine</span> <span class=p>=</span> <span class=n>BlockingCoroutine</span><span class=p>&lt;</span><span class=n>T</span><span class=p>&gt;(</span><span class=n>newContext</span><span class=p>,</span> <span class=n>currentThread</span><span class=p>,</span> <span class=n>eventLoop</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=n>coroutine</span><span class=p>.</span><span class=n>start</span><span class=p>(</span><span class=nc>CoroutineStart</span><span class=p>.</span><span class=n>DEFAULT</span><span class=p>,</span> <span class=n>coroutine</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>coroutine</span><span class=p>.</span><span class=n>joinBlocking</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>coroutine의 일반적인 규칙은 thread를 block하지 않는다 이지만, runblocking은 다른 coroutine builder와는 다르게 쓰레드를 block함</li><li>main function과 같이, 쓰레드를 block하지마 않으면 프로세스가 종료되기 때문에 이러한 경우 runBlocking을 사용해야함<ul><li>runBlocking은 새로운 코루틴을 실행하고, 현재 쓰레드를 코루틴이 완료될 때 까지 block함</li></ul></li><li>runBlocking인자로 Dispatcher를 전달하여 다른 쓰레드에서 runBlocking을 실행하게 할 수 있음<ul><li>다른 쓰레드에서 runBlocking을 실행해도 runBlocking을 실행한 쓰레드를 Block함</li><li>Dispatcher는 코루틴을 실행할 쓰레드를 선택하는 것으로, 현재 쓰레드를 block하는 것을 막을 수 없음</li></ul></li><li>CoroutineScope의 확장함수가 아님, CoroutineScope외부에서 사용 가능<ul><li>완료될때까지 쓰레드를 block하므로 CoroutineScope외부에서 사용하는건 권장하지 않음</li></ul></li></ul><h2 id=structured-concurrency>Structured Concurrency</h2><ul><li><p>launch와 async함수는 CoroutineScope의 extenstion함수 임</p></li><li><p>따로 CoroutineScope를 지정하지 않는다면, 해당 함수를 실행한 CoroutineScope의 확장함수로 동작</p><ul><li>부모-자식관계 형성</li></ul></li><li><p>부모자식 관계가 형성된다면 아래와 같은 관계가 됨</p><ul><li>자식 코루틴은 부모 코루틴으로부터 context를 상속 받음</li><li>부모 코루틴은 자식 코루틴이 끝날때까지 suspend됨</li><li>부모 코루틴이 cancel되면 자식 코루틴도 cancel됨</li><li>자식 코루틴에서 에러 발생시 부모 코루틴에도 전파됨</li></ul></li><li><p>CoroutineScope를 따로 지정한다면 부모-자식 관계가 아니므로 launch와 async의 종료를 기다리지 않음</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>fun</span> <span class=nf>main</span><span class=p>(){</span>  
</span></span><span class=line><span class=cl>    <span class=n>runBlocking</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;start&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=n>CoroutineScope</span><span class=p>(</span><span class=n>EmptyCoroutineContext</span><span class=p>).</span><span class=n>launch</span><span class=p>(</span><span class=n>CoroutineName</span><span class=p>(</span><span class=s2>&#34;123&#34;</span><span class=p>))</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>            <span class=n>delay</span><span class=p>(</span><span class=m>100</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>            <span class=n>println</span><span class=p>(</span><span class=s2>&#34;another scope!&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>  
</span></span><span class=line><span class=cl>        <span class=n>println</span><span class=p>(</span><span class=s2>&#34;end&#34;</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//start  
</span></span></span><span class=line><span class=cl><span class=c1>//end
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>suspend 함수 내부에서 launch, async를 호출할떄는 coroutineScope{}로 코루틴스코프를 새로 생성 후 호출해야함</p></blockquote><h2 id=withcontext>withContext</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>public</span> <span class=k>suspend</span> <span class=k>fun</span> <span class=p>&lt;</span><span class=nc>T</span><span class=p>&gt;</span> <span class=nf>withContext</span><span class=p>(</span>  
</span></span><span class=line><span class=cl>    <span class=n>context</span><span class=p>:</span> <span class=n>CoroutineContext</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>    <span class=n>block</span><span class=p>:</span> <span class=k>suspend</span> <span class=nc>CoroutineScope</span><span class=p>.()</span> <span class=o>-&gt;</span> <span class=n>T</span>  
</span></span><span class=line><span class=cl><span class=p>):</span> <span class=n>T</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>    <span class=n>contract</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=n>callsInPlace</span><span class=p>(</span><span class=n>block</span><span class=p>,</span> <span class=nc>InvocationKind</span><span class=p>.</span><span class=n>EXACTLY_ONCE</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>suspendCoroutineUninterceptedOrReturn</span> <span class=n>sc</span><span class=err>@</span> <span class=p>{</span> <span class=n>uCont</span> <span class=o>-&gt;</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// compute new context  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>val</span> <span class=py>oldContext</span> <span class=p>=</span> <span class=n>uCont</span><span class=p>.</span><span class=n>context</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// Copy CopyableThreadContextElement if necessary  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>val</span> <span class=py>newContext</span> <span class=p>=</span> <span class=n>oldContext</span><span class=p>.</span><span class=n>newCoroutineContext</span><span class=p>(</span><span class=n>context</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// always check for cancellation of new context  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>newContext</span><span class=p>.</span><span class=n>ensureActive</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// FAST PATH #1 -- new context is the same as the old one  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>newContext</span> <span class=o>===</span> <span class=n>oldContext</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>            <span class=k>val</span> <span class=py>coroutine</span> <span class=p>=</span> <span class=n>ScopeCoroutine</span><span class=p>(</span><span class=n>newContext</span><span class=p>,</span> <span class=n>uCont</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=nd>@sc</span> <span class=n>coroutine</span><span class=p>.</span><span class=n>startUndispatchedOrReturn</span><span class=p>(</span><span class=n>coroutine</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// FAST PATH #2 -- the new dispatcher is the same as the old one (something else changed)  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// `equals` is used by design (see equals implementation is wrapper context like ExecutorCoroutineDispatcher)        
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>newContext</span><span class=p>[</span><span class=n>ContinuationInterceptor</span><span class=p>]</span> <span class=o>==</span> <span class=n>oldContext</span><span class=p>[</span><span class=n>ContinuationInterceptor</span><span class=p>])</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>            <span class=k>val</span> <span class=py>coroutine</span> <span class=p>=</span> <span class=n>UndispatchedCoroutine</span><span class=p>(</span><span class=n>newContext</span><span class=p>,</span> <span class=n>uCont</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>            <span class=c1>// There are changes in the context, so this thread needs to be updated  
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>withCoroutineContext</span><span class=p>(</span><span class=n>coroutine</span><span class=p>.</span><span class=n>context</span><span class=p>,</span> <span class=k>null</span><span class=p>)</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>                <span class=k>return</span><span class=nd>@sc</span> <span class=n>coroutine</span><span class=p>.</span><span class=n>startUndispatchedOrReturn</span><span class=p>(</span><span class=n>coroutine</span><span class=p>,</span> <span class=n>block</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>            <span class=p>}</span>  
</span></span><span class=line><span class=cl>        <span class=p>}</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// SLOW PATH -- use new dispatcher  
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>val</span> <span class=py>coroutine</span> <span class=p>=</span> <span class=n>DispatchedCoroutine</span><span class=p>(</span><span class=n>newContext</span><span class=p>,</span> <span class=n>uCont</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=n>block</span><span class=p>.</span><span class=n>startCoroutineCancellable</span><span class=p>(</span><span class=n>coroutine</span><span class=p>,</span> <span class=n>coroutine</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>        <span class=n>coroutine</span><span class=p>.</span><span class=n>getResult</span><span class=p>()</span>  
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>결과를 리턴한점에서 async와 많이 비교됨</li><li>withContext는 block이 끝날때까지 현재 coroutine을 suspend함</li><li>async와의 차이점<ul><li>인자로 CoroutineStart을 받지않는 것<ul><li>즉시 실행되므로 CoroutineStart가 필요없음</li></ul></li><li>context의 디폴트 값이 없는 것<ul><li>withContext는 현재 Context가 아닌 다른 Context로 실행할경우 사용하는것이기에, Context를 인자로 받아야함</li></ul></li><li>CoroutineScope의 확장함수가 아니라는 것<ul><li>CoroutineScope</li></ul></li></ul></li></ul><h2 id=coroutinestart>CoroutineStart</h2><ul><li>코루틴 빌더의 시작 옵션을 설정</li><li>DEFAULT <ul><li>해당 컨텍스트에 코루틴을 실행하도록 즉시 예약함</li></ul></li><li>LAZY<ul><li>해당 코루틴이 필요할때까지, 코루틴 시작을 늦춤</li></ul></li><li>ATOMIC <ul><li>해당 컨텍스트에 실행할 코루틴을 원자적으로(취소할 수 없는 방식으로) 예약함</li></ul></li><li>UNDISPATCHED<ul><li>현재 쓰레드애 첫번째 suspension point를 만날때까지 즉시 코루틴을 실행함</li></ul></li></ul><p><a class=link href=https://medium.com/@wind.orca.pe/kotlin-coroutines-coroutine-builders-korean-recap-24a36300513b target=_blank rel=noopener>https://medium.com/@wind.orca.pe/kotlin-coroutines-coroutine-builders-korean-recap-24a36300513b</a><br><a class=link href=https://kotlinlang.org/docs/coroutines-basics.html#an-explicit-job target=_blank rel=noopener>https://kotlinlang.org/docs/coroutines-basics.html#an-explicit-job</a><br><a class=link href=https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/ target=_blank rel=noopener>https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/hugo_blog/>Hugo_blog</a>
<a href=/tags/coroutine/>Coroutine</a>
<a href=/tags/jvm/>JVM</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>마지막 수정: Sep 22, 2024 07:06 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/7-job/><div class=article-details><h2 class=article-title>7-Job</h2></div></a></article><article><a href=/p/5-coroutine-cps/><div class=article-details><h2 class=article-title>5-Coroutine CPS</h2></div></a></article><article><a href=/p/4-coroutine-suspend/><div class=article-details><h2 class=article-title>4-Coroutine suspend</h2></div></a></article><article><a href=/p/3-coroutindispatcher/><div class=article-details><h2 class=article-title>3-CoroutinDispatcher</h2></div></a></article><article><a href=/p/2-coroutinescope/><div class=article-details><h2 class=article-title>2-CoroutineScope</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=Star-ho/star-ho.github.io issue-term=pathname label=Comments crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Sungho's Dev BLog</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>