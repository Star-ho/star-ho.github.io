<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='Threading and Scheduler Flux나 Mono를 얻는다고 실행되지 않음 따로 지정하지 않으면 Reactor는 subscribe가 발생한 쓰레드에서 모든 연산자가 실행됨 Reactor가 실행되는 위치는 스케줄러에 의해 정해짐 Schedulers.immediate() 직접적으로 현재 실행되고 있는 쓰레드에서 실행됨 Schedulers.single() 쓰레드를 생성하여 스케줄러가 dispose될때까지 모든 호출자에 대해 동일한 쓰레드를 재사용 호출별 새로운 쓰레드를 생성하고 싶다면 Schedulers.newSingle()을 사용해야함 Schedulers.elastic() 배압 문제를 숨기고 너무많은 쓰레드를 생성하기에 Schedulers.boundedElastic()가 도입된 이후로 잘 사용되지 않음 Schedulers.boundedElastic() 필요에 따라 워커풀을 생성하고, idle한 워커풀이 있다면 재사용함 워커풀이 일정시간 사용되지 않으면 삭제됨(기본 60초) Schedulers.elastic()과 달리 워커풀 생성에 제한이 있음(기본 cpu core*\\10) 한도에 도달한다면 최대 100,000 작업이 큐에 추가됨 쓰레드가 다시 재사용 될때 큐에 추가됨 100,000이 넘게 추가되면 에러발생 블로킹\b프로세스에 자체 쓰레드를 부여하여 다른 리소스 묶이지 않도록 할 수 있음 링크참고 Schedulers.parallel() 병렬 작업에 맞게 고정된 워커풀을 생성 CPU Core개수만큼 워커풀을 생성함 추가 Schedulers.fromExecutorService(ExecutorService)를 사용하여 ExecutorService를 Scheduler로 사용할 수 있음 newXXX를 사용하여 다양한 스케줄러 타입의 인스턴스를 생성할 수 있음 boundedElastic()은 single과 parallel과 다르게 피할 수 없는 legacy blocking콜을 사용하는데 single과 perallel을 사용한다면 blocking api(block(),\u00a0blockFirst(),\u00a0blockLast())를 사용하면 IllegalStateException을 발생시킴 어떤 연산자는 기본으로 특정 Schduler를 사용함 ex) Flux.interval는 Schedulers.parallel()을 사용함 변경가능함 publishOn, subscribeOn Reactor에서는 Reactor chain 내에서 실행 컨택스트를 바꿀 수 있는 publishOn과 subscribeOn을 제공함 publishOn 다른 오퍼레이터들과 같이 체인 내에서 적용될 수 있음 연관된 Scheduler의 worker에서 콜백이 실행되는 동안 업스트림에서 신호를 받아, 다운스트림으로 재생해줌 따라서 후속 오퍼레이터가 실행되는 곳에 영향을 미침 스케줄러에서 선택된 하나의 쓰레드로 실행 컨텍스트를 변경함 시퀀스 내에서 onNext를 호출하면 선택된 쓰레드로 실행됨 이후 특정 스케줄러를 지정하지 않는 한, publishOn 이후의 연산자는 동일한 쓰레드에서 실행됨 1 2 3 4 5 6 7 8 9 Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); 1번 쓰레드 final Flux<String> flux = Flux .range(1, 2) // 2번 쓰레드로 실행 .map(i -> 10 + i) // 2번 쓰레드로 실행 .publishOn(s) .map(i -> "value " + i); // 1번 쓰레드로 실행 new Thread(() -> flux.subscribe(System.out::println)); - 2번 쓰레드 subscribeOn backward chain이 구성될때, 구독처리과정에서 subscribeOn을 적용함 중간 연산자가 실행컨택스트에 영향을 줄 수 있으므로 데이터 소스 바로 뒤에 적용하는 것이 좋음 publishOn동작에는 영향을 미치지 않음 구독하는 전체 체인의 Scheduler의 쓰레드를 변경함 스케줄러에서 하나의 쓰레드를 선택함 1 2 3 4 5 6 7 8 9 Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); - 1번 쓰레드 final Flux<String> flux = Flux .range(1, 2) .map(i -> 10 + i) // 1번쓰레드로 실행 .subscribeOn(s) // 1번쓰레드로 실행 .map(i -> "value " + i); // 1번쓰레드로 실행 new Thread(() -> flux.subscribe(System.out::println)); - 2번쓰레드 subscribeOn이 있다면 어디서 구독하든 subscribeOn의 Scheduler를 사용하여 시작함\n'><title>11-Reactor Java(2)</title>
<link rel=canonical href=https://sungho94.me/p/11-reactor-java2/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="11-Reactor Java(2)"><meta property='og:description' content='Threading and Scheduler Flux나 Mono를 얻는다고 실행되지 않음 따로 지정하지 않으면 Reactor는 subscribe가 발생한 쓰레드에서 모든 연산자가 실행됨 Reactor가 실행되는 위치는 스케줄러에 의해 정해짐 Schedulers.immediate() 직접적으로 현재 실행되고 있는 쓰레드에서 실행됨 Schedulers.single() 쓰레드를 생성하여 스케줄러가 dispose될때까지 모든 호출자에 대해 동일한 쓰레드를 재사용 호출별 새로운 쓰레드를 생성하고 싶다면 Schedulers.newSingle()을 사용해야함 Schedulers.elastic() 배압 문제를 숨기고 너무많은 쓰레드를 생성하기에 Schedulers.boundedElastic()가 도입된 이후로 잘 사용되지 않음 Schedulers.boundedElastic() 필요에 따라 워커풀을 생성하고, idle한 워커풀이 있다면 재사용함 워커풀이 일정시간 사용되지 않으면 삭제됨(기본 60초) Schedulers.elastic()과 달리 워커풀 생성에 제한이 있음(기본 cpu core*\\10) 한도에 도달한다면 최대 100,000 작업이 큐에 추가됨 쓰레드가 다시 재사용 될때 큐에 추가됨 100,000이 넘게 추가되면 에러발생 블로킹\b프로세스에 자체 쓰레드를 부여하여 다른 리소스 묶이지 않도록 할 수 있음 링크참고 Schedulers.parallel() 병렬 작업에 맞게 고정된 워커풀을 생성 CPU Core개수만큼 워커풀을 생성함 추가 Schedulers.fromExecutorService(ExecutorService)를 사용하여 ExecutorService를 Scheduler로 사용할 수 있음 newXXX를 사용하여 다양한 스케줄러 타입의 인스턴스를 생성할 수 있음 boundedElastic()은 single과 parallel과 다르게 피할 수 없는 legacy blocking콜을 사용하는데 single과 perallel을 사용한다면 blocking api(block(),\u00a0blockFirst(),\u00a0blockLast())를 사용하면 IllegalStateException을 발생시킴 어떤 연산자는 기본으로 특정 Schduler를 사용함 ex) Flux.interval는 Schedulers.parallel()을 사용함 변경가능함 publishOn, subscribeOn Reactor에서는 Reactor chain 내에서 실행 컨택스트를 바꿀 수 있는 publishOn과 subscribeOn을 제공함 publishOn 다른 오퍼레이터들과 같이 체인 내에서 적용될 수 있음 연관된 Scheduler의 worker에서 콜백이 실행되는 동안 업스트림에서 신호를 받아, 다운스트림으로 재생해줌 따라서 후속 오퍼레이터가 실행되는 곳에 영향을 미침 스케줄러에서 선택된 하나의 쓰레드로 실행 컨텍스트를 변경함 시퀀스 내에서 onNext를 호출하면 선택된 쓰레드로 실행됨 이후 특정 스케줄러를 지정하지 않는 한, publishOn 이후의 연산자는 동일한 쓰레드에서 실행됨 1 2 3 4 5 6 7 8 9 Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); 1번 쓰레드 final Flux<String> flux = Flux .range(1, 2) // 2번 쓰레드로 실행 .map(i -> 10 + i) // 2번 쓰레드로 실행 .publishOn(s) .map(i -> "value " + i); // 1번 쓰레드로 실행 new Thread(() -> flux.subscribe(System.out::println)); - 2번 쓰레드 subscribeOn backward chain이 구성될때, 구독처리과정에서 subscribeOn을 적용함 중간 연산자가 실행컨택스트에 영향을 줄 수 있으므로 데이터 소스 바로 뒤에 적용하는 것이 좋음 publishOn동작에는 영향을 미치지 않음 구독하는 전체 체인의 Scheduler의 쓰레드를 변경함 스케줄러에서 하나의 쓰레드를 선택함 1 2 3 4 5 6 7 8 9 Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); - 1번 쓰레드 final Flux<String> flux = Flux .range(1, 2) .map(i -> 10 + i) // 1번쓰레드로 실행 .subscribeOn(s) // 1번쓰레드로 실행 .map(i -> "value " + i); // 1번쓰레드로 실행 new Thread(() -> flux.subscribe(System.out::println)); - 2번쓰레드 subscribeOn이 있다면 어디서 구독하든 subscribeOn의 Scheduler를 사용하여 시작함\n'><meta property='og:url' content='https://sungho94.me/p/11-reactor-java2/'><meta property='og:site_name' content="Sungho's Dev BLog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Server-History'><meta property='article:tag' content='hugo_blog'><meta property='article:tag' content='Reactive'><meta property='article:tag' content='Server'><meta property='article:published_time' content='2024-03-05T22:41:02+00:00'><meta property='article:modified_time' content='2024-09-22T07:08:11+00:00'><meta name=twitter:title content="11-Reactor Java(2)"><meta name=twitter:description content='Threading and Scheduler Flux나 Mono를 얻는다고 실행되지 않음 따로 지정하지 않으면 Reactor는 subscribe가 발생한 쓰레드에서 모든 연산자가 실행됨 Reactor가 실행되는 위치는 스케줄러에 의해 정해짐 Schedulers.immediate() 직접적으로 현재 실행되고 있는 쓰레드에서 실행됨 Schedulers.single() 쓰레드를 생성하여 스케줄러가 dispose될때까지 모든 호출자에 대해 동일한 쓰레드를 재사용 호출별 새로운 쓰레드를 생성하고 싶다면 Schedulers.newSingle()을 사용해야함 Schedulers.elastic() 배압 문제를 숨기고 너무많은 쓰레드를 생성하기에 Schedulers.boundedElastic()가 도입된 이후로 잘 사용되지 않음 Schedulers.boundedElastic() 필요에 따라 워커풀을 생성하고, idle한 워커풀이 있다면 재사용함 워커풀이 일정시간 사용되지 않으면 삭제됨(기본 60초) Schedulers.elastic()과 달리 워커풀 생성에 제한이 있음(기본 cpu core*\\10) 한도에 도달한다면 최대 100,000 작업이 큐에 추가됨 쓰레드가 다시 재사용 될때 큐에 추가됨 100,000이 넘게 추가되면 에러발생 블로킹\b프로세스에 자체 쓰레드를 부여하여 다른 리소스 묶이지 않도록 할 수 있음 링크참고 Schedulers.parallel() 병렬 작업에 맞게 고정된 워커풀을 생성 CPU Core개수만큼 워커풀을 생성함 추가 Schedulers.fromExecutorService(ExecutorService)를 사용하여 ExecutorService를 Scheduler로 사용할 수 있음 newXXX를 사용하여 다양한 스케줄러 타입의 인스턴스를 생성할 수 있음 boundedElastic()은 single과 parallel과 다르게 피할 수 없는 legacy blocking콜을 사용하는데 single과 perallel을 사용한다면 blocking api(block(),\u00a0blockFirst(),\u00a0blockLast())를 사용하면 IllegalStateException을 발생시킴 어떤 연산자는 기본으로 특정 Schduler를 사용함 ex) Flux.interval는 Schedulers.parallel()을 사용함 변경가능함 publishOn, subscribeOn Reactor에서는 Reactor chain 내에서 실행 컨택스트를 바꿀 수 있는 publishOn과 subscribeOn을 제공함 publishOn 다른 오퍼레이터들과 같이 체인 내에서 적용될 수 있음 연관된 Scheduler의 worker에서 콜백이 실행되는 동안 업스트림에서 신호를 받아, 다운스트림으로 재생해줌 따라서 후속 오퍼레이터가 실행되는 곳에 영향을 미침 스케줄러에서 선택된 하나의 쓰레드로 실행 컨텍스트를 변경함 시퀀스 내에서 onNext를 호출하면 선택된 쓰레드로 실행됨 이후 특정 스케줄러를 지정하지 않는 한, publishOn 이후의 연산자는 동일한 쓰레드에서 실행됨 1 2 3 4 5 6 7 8 9 Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); 1번 쓰레드 final Flux<String> flux = Flux .range(1, 2) // 2번 쓰레드로 실행 .map(i -> 10 + i) // 2번 쓰레드로 실행 .publishOn(s) .map(i -> "value " + i); // 1번 쓰레드로 실행 new Thread(() -> flux.subscribe(System.out::println)); - 2번 쓰레드 subscribeOn backward chain이 구성될때, 구독처리과정에서 subscribeOn을 적용함 중간 연산자가 실행컨택스트에 영향을 줄 수 있으므로 데이터 소스 바로 뒤에 적용하는 것이 좋음 publishOn동작에는 영향을 미치지 않음 구독하는 전체 체인의 Scheduler의 쓰레드를 변경함 스케줄러에서 하나의 쓰레드를 선택함 1 2 3 4 5 6 7 8 9 Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); - 1번 쓰레드 final Flux<String> flux = Flux .range(1, 2) .map(i -> 10 + i) // 1번쓰레드로 실행 .subscribeOn(s) // 1번쓰레드로 실행 .map(i -> "value " + i); // 1번쓰레드로 실행 new Thread(() -> flux.subscribe(System.out::println)); - 2번쓰레드 subscribeOn이 있다면 어디서 구독하든 subscribeOn의 Scheduler를 사용하여 시작함\n'><link rel="shortcut icon" href=/favicon.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-PTKY5BPR7H"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PTKY5BPR7H")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu1582294339771580780.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Sungho's Dev BLog</a></h1><h2 class=site-description>백엔드 개발자 황성호입니다.</h2></div></header><ol class=menu-social><li><a href=https://github.com/Star-ho target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/starho/ target=_blank title=LinkedIn rel=me><svg fill="#000" width="800" height="800" viewBox="0 0 24 24"><path d="M6.975 20.667H3.117V9.059H6.975zM5.072 3.462a2.011 2.011.0 10-.051 4.012h.026a2.012 2.012.0 10.025-4.012zM9.111 20.667h3.858V14.185a2.639 2.639.0 01.127-.941 2.111 2.111.0 011.98-1.411c1.4.0 1.955 1.064 1.955 2.625v6.209h3.858V14.011c0-3.565-1.9-5.225-4.442-5.225A3.828 3.828.0 0012.97 10.7V9.059H9.111c.051 1.089.0 11.609.0 11.609z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><ol><li><a href=#schedulersimmediate>Schedulers.immediate()</a></li><li><a href=#schedulerssingle>Schedulers.single()</a></li><li><a href=#schedulerselastic>Schedulers.elastic()</a></li><li><a href=#schedulersboundedelastic>Schedulers.boundedElastic()</a></li><li><a href=#schedulersparallel>Schedulers.parallel()</a></li><li><a href=#추가>추가</a></li></ol></li><li><a href=#publishon-subscribeon>publishOn, subscribeOn</a><ol><li><a href=#publishon>publishOn</a></li><li><a href=#subscribeon>subscribeOn</a></li></ol></li><li><a href=#sink>Sink</a></li><li><a href=#hot-vs-cold>Hot vs Cold</a><ol><li><a href=#cold>Cold</a></li><li><a href=#hot>Hot</a></li></ol></li><li><a href=#default-scheduler-변경방법>default scheduler 변경방법</a></li><li><a href=#context>Context</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/server-history-series/>Server-History-Series</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/11-reactor-java2/>11-Reactor Java(2)</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 05, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>5 분 정도</time></div></footer></div></header><section class=article-content><h1 id=threading-and-scheduler>Threading and Scheduler</h1><ul><li>Flux나 Mono를 얻는다고 실행되지 않음</li><li>따로 지정하지 않으면 Reactor는 subscribe가 발생한 쓰레드에서 모든 연산자가 실행됨</li><li>Reactor가 실행되는 위치는 스케줄러에 의해 정해짐</li></ul><h3 id=schedulersimmediate>Schedulers.immediate()</h3><ul><li>직접적으로 현재 실행되고 있는 쓰레드에서 실행됨</li></ul><h3 id=schedulerssingle>Schedulers.single()</h3><ul><li>쓰레드를 생성하여 스케줄러가 dispose될때까지 모든 호출자에 대해 동일한 쓰레드를 재사용</li><li>호출별 새로운 쓰레드를 생성하고 싶다면 Schedulers.newSingle()을 사용해야함</li></ul><h3 id=schedulerselastic>Schedulers.elastic()</h3><ul><li>배압 문제를 숨기고 너무많은 쓰레드를 생성하기에 Schedulers.boundedElastic()가 도입된 이후로 잘 사용되지 않음</li></ul><h3 id=schedulersboundedelastic>Schedulers.boundedElastic()</h3><ul><li>필요에 따라 워커풀을 생성하고, idle한 워커풀이 있다면 재사용함</li><li>워커풀이 일정시간 사용되지 않으면 삭제됨(기본 60초)</li><li>Schedulers.elastic()과 달리 워커풀 생성에 제한이 있음(기본 cpu core*\10)</li><li>한도에 도달한다면 최대 100,000 작업이 큐에 추가됨</li><li>쓰레드가 다시 재사용 될때 큐에 추가됨<ul><li>100,000이 넘게 추가되면 에러발생</li></ul></li><li>블로킹프로세스에 자체 쓰레드를 부여하여 다른 리소스 묶이지 않도록 할 수 있음<ul><li><a class=link href=https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking target=_blank rel=noopener>링크</a>참고</li></ul></li></ul><h3 id=schedulersparallel>Schedulers.parallel()</h3><ul><li>병렬 작업에 맞게 고정된 워커풀을 생성</li><li>CPU Core개수만큼 워커풀을 생성함</li></ul><h3 id=추가>추가</h3><ul><li><code>Schedulers.fromExecutorService(ExecutorService)</code>를 사용하여 ExecutorService를 Scheduler로 사용할 수 있음</li><li><code>newXXX</code>를 사용하여 다양한 스케줄러 타입의 인스턴스를 생성할 수 있음</li><li>boundedElastic()은 single과 parallel과 다르게 피할 수 없는 legacy blocking콜을 사용하는데<ul><li>single과 perallel을 사용한다면 blocking api(block(), blockFirst(), blockLast())를 사용하면 IllegalStateException을 발생시킴</li></ul></li><li>어떤 연산자는 기본으로 특정 Schduler를 사용함<ul><li>ex) Flux.interval는 Schedulers.parallel()을 사용함<ul><li>변경가능함</li></ul></li></ul></li></ul><h2 id=publishon-subscribeon>publishOn, subscribeOn</h2><ul><li>Reactor에서는 Reactor chain 내에서 실행 컨택스트를 바꿀 수 있는 publishOn과 subscribeOn을 제공함</li></ul><h3 id=publishon>publishOn</h3><ul><li>다른 오퍼레이터들과 같이 체인 내에서 적용될 수 있음</li><li>연관된 Scheduler의 worker에서 콜백이 실행되는 동안 업스트림에서 신호를 받아, 다운스트림으로 재생해줌<ul><li>따라서 후속 오퍼레이터가 실행되는 곳에 영향을 미침</li></ul></li><li>스케줄러에서 선택된 하나의 쓰레드로 실행 컨텍스트를 변경함</li><li>시퀀스 내에서 onNext를 호출하면 선택된 쓰레드로 실행됨</li><li>이후 특정 스케줄러를 지정하지 않는 한, publishOn 이후의 연산자는 동일한 쓰레드에서 실행됨</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Scheduler s = Schedulers.newParallel(&#34;parallel-scheduler&#34;, 4); 1번 쓰레드
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>final Flux&lt;String&gt; flux = Flux 
</span></span><span class=line><span class=cl>	.range(1, 2) // 2번 쓰레드로 실행
</span></span><span class=line><span class=cl>	.map(i -&gt; 10 + i) // 2번 쓰레드로 실행 
</span></span><span class=line><span class=cl>	.publishOn(s) 
</span></span><span class=line><span class=cl>	.map(i -&gt; &#34;value &#34; + i); // 1번 쓰레드로 실행
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>new Thread(() -&gt; flux.subscribe(System.out::println)); - 2번 쓰레드
</span></span></code></pre></td></tr></table></div></div><h3 id=subscribeon>subscribeOn</h3><ul><li>backward chain이 구성될때, 구독처리과정에서 subscribeOn을 적용함</li><li>중간 연산자가 실행컨택스트에 영향을 줄 수 있으므로 데이터 소스 바로 뒤에 적용하는 것이 좋음</li><li>publishOn동작에는 영향을 미치지 않음</li><li>구독하는 전체 체인의 Scheduler의 쓰레드를 변경함</li><li>스케줄러에서 하나의 쓰레드를 선택함</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Scheduler s = Schedulers.newParallel(&#34;parallel-scheduler&#34;, 4); - 1번 쓰레드
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>final Flux&lt;String&gt; flux = Flux 
</span></span><span class=line><span class=cl>	.range(1, 2) 
</span></span><span class=line><span class=cl>	.map(i -&gt; 10 + i) // 1번쓰레드로 실행
</span></span><span class=line><span class=cl>	.subscribeOn(s) // 1번쓰레드로 실행
</span></span><span class=line><span class=cl>	.map(i -&gt; &#34;value &#34; + i); // 1번쓰레드로 실행
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>new Thread(() -&gt; flux.subscribe(System.out::println)); - 2번쓰레드
</span></span></code></pre></td></tr></table></div></div><ul><li><p>subscribeOn이 있다면 어디서 구독하든 subscribeOn의 Scheduler를 사용하여 시작함</p></li><li><p>스케줄러 공부자료 <a class=link href=https://wiki.terzeron.com/Programming/Java/Reactor_Flux%EC%9D%98_publishOn_subscribeOn%EC%9D%84_%EC%9D%B4%EC%9A%A9%ED%95%9C_%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81 target=_blank rel=noopener>링크</a>참고</p></li></ul><h2 id=sink>Sink</h2><ul><li>signal을 수동으로 트리거 할 수 있는 구조</li><li>여러 Subscriber를 처리할 수 있는 Publisher구조를 가짐<ul><li>unicast()는 아님</li></ul></li></ul><h2 id=hot-vs-cold>Hot vs Cold</h2><h3 id=cold>Cold</h3><p><img src=/image/real-resource-image/Pasted%20image%2020231218210001.png loading=lazy alt=center|400></p><ul><li>구독이 생성될때마다 새로운 데이터를 생성</li><li>구독이 생성되지 않으면, 데이터를 생성하지 않음</li><li>HTTP 요청에 비유하면, 구독이 생성될때마다 HTTP 요청을 보냄</li></ul><h3 id=hot>Hot</h3><p><img src=/image/real-resource-image/Pasted%20image%2020231218210038.png loading=lazy alt=center|400></p><ul><li>구독자의 수에 영향을 받지 않음</li><li>즉시 데이터를 publishing 할 수 있음</li><li>구독하기 전에 실제로 어떠한 일이 발생할 수 있음</li><li>데이터 생성 중간에 새로운 구독자가 들어오면, 새로온 구독자는 그전의 데이터를 알지 못하고, 구독 이후에 데이터만 전달받음</li><li>Hot publisher의 예시로 just가 있는데 어셈블리 시점에 데이터를 캡처하고, 나중에 오는 구독자에게 이를 생성함</li><li>HTTP요청에 비유하면, 인스턴스화 할때 네트워크 요청이 한번 실행되고 구독자에게 이 결과를 전달함<ul><li>구독이 늘어난다고 해서 HTTP요청을 여러번 실행하지 않음</li></ul></li></ul><blockquote><p>just를 cold publisher로 변환하려면 defer를 사용하면 됨<br>share 또는 replay를 사용한다면 cold publisher를 hot publisher로 전환가능</p><ul><li><a class=link href=https://binux.tistory.com/135 target=_blank rel=noopener>관련공부자료</a></li></ul></blockquote><h2 id=default-scheduler-변경방법>default scheduler 변경방법</h2><ul><li>Schedulers.Factory를 사용하여 가능</li><li><a class=link href=https://projectreactor.io/docs/core/release/reference/#scheduler-factory target=_blank rel=noopener>링크</a> 참고</li></ul><h2 id=context>Context</h2><ul><li>명령형 프로그래밍에서 사용하는 Thread Local의 대안</li><li>세부사항<ul><li>Map자료 구조와 유사함</li><li>key와 value가 Object, Object타입으로 다양한 값들을 넣을 수 있음<ul><li>다양한 라이브러리들과 호환 위해</li></ul></li><li>불변임, put 또는 putAll이 발생한다면 새로운 인스턴스가 생성됨</li><li>ContextView인 read only api는 write와 관련된 메서드를 제공하지 않음</li></ul></li><li>실제로 체인에 있는 구독자에게 연결됨</li><li>구독 전파매커니즘을 통해 최종 구독자로부터 위로 올라가면서 각각의 operator가 Context를 사용하게 해줌</li><li><em>inner sequence에서 외부의 context를 읽을 수 있음</em></li><li>thread local 데이터를 자동으로 context에 넣어주는 Context-Propagation관련 기능도 있음 <a class=link href=https://projectreactor.io/docs/core/release/reference/#context.propagation target=_blank rel=noopener>링크</a>참고</li><li>context 공부 예제 <a class=link href=https://devfunny.tistory.com/916 target=_blank rel=noopener>링크</a> 참고</li></ul><p><a class=link href=https://projectreactor.io/docs/core/release/reference/index.html target=_blank rel=noopener>https://projectreactor.io/docs/core/release/reference/index.html</a><br><a class=link href=https://brunch.co.kr/@springboot/153 target=_blank rel=noopener>https://brunch.co.kr/@springboot/153</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/server-history/>Server-History</a>
<a href=/tags/hugo_blog/>Hugo_blog</a>
<a href=/tags/reactive/>Reactive</a>
<a href=/tags/server/>Server</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>마지막 수정: Sep 22, 2024 07:08 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/15-%EA%B0%80%EC%83%81%EC%8A%A4%EB%A0%88%EB%93%9C-vs-%EB%A6%AC%EC%95%A1%ED%8B%B0%EB%B8%8C-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%A6%88-vs-%EC%BD%94%EB%A3%A8%ED%8B%B4/><div class=article-details><h2 class=article-title>15 - 가상스레드 vs 리액티브 스트림즈 vs 코루틴</h2></div></a></article><article><a href=/p/10-reactor-java1/><div class=article-details><h2 class=article-title>10-Reactor Java(1)</h2></div></a></article><article><a href=/p/12-reactor-schedulerboundedelasticscheduler/><div class=article-details><h2 class=article-title>12-Reactor Scheduler(BoundedElasticScheduler)</h2></div></a></article><article><a href=/p/9-reactive-streams/><div class=article-details><h2 class=article-title>9-Reactive Streams</h2></div></a></article><article><a href=/p/7-reactive-manifesto/><div class=article-details><h2 class=article-title>7-Reactive Manifesto</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=Star-ho/star-ho.github.io issue-term=pathname label=Comments crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Sungho's Dev BLog</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>