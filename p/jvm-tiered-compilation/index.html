<!doctype html><html lang=ko-kr dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Java 언어의 특징 Java는 컴파일 + 인터프리터 두가지 특징을 다 가지고 있음 Java코드를 컴파일하면 .class파일(byte Code)이 되고, JVM은 .class파일을 가지고 os에 맞게 machine code로 변환함 .class파일은 특정 실행횟수가 지나면 최적화가 됨 Tiered Compilation JVM의 JIT Compiler는 자주 실행되는 부분의 코드를 native code로 변환함 JIT compiler에는 2개의 java byte code interpreter가 존재함 Client compiler 메소드를 빠르게 컴파일 하지만 Server compiler보다 덜 최적화된 machine code를 생성함 빠른\x1f 시작에 사용함 Server compiler 동일한 메서드르 컴파일하는데 더 많은 시간이 듬 Client compiler보다 더 많은 시간 및 메모리를 소요하지만, 더 최적화된 machine code를 생성함 Tiered Compilation은 Client compiler를 첫번째 계\x1c으로 사용하여 서버 VM시작 속도를 향상시킴 서버 vm은 인터프리터를 사용하여 컴파일러에 공급되는 메서드에 대한 프로파일링 정보를 수집함 Tiered Compilation에서는 인터프리터 외에도 client compiler가 자신에 대한 프로파일링 정보를 수집하는 메서드의 컴파일된 버전을 생성함 컴파일된 코드가 인터프리터 보다 후러씬 빠르기 때문에, 이 프로파일 단계에서 프로그램이 더 뛰어난 성능으로 실행됨 애플리케이션 초기화 된계에서 server compiler가 생성한 최종 코드를 사용할 수 있기때문에 시작이 더 빠른 경우도 종종 존재함 Tier level 서로 다른 컴파일러와 인터프리터의 결합으로 아래와 같은 5개의 최적화 수준이 생성됨 Level Compiler 0 Interpreter JVM은 모든 자바 코드를 0 level을 사용함\n워밍업 단계가 끝나면 JIT 컴파일러가 시작되어 런타임에 코드를 최적화함\nJIT 컴파일러는 0 level에서 수집한 프로파일링 정보로 최적화 수행 1 C1 without profiling C1컴파일러를 사용하여 코드를 컴파일하지만, 프로파일 정보는 수집하지 않음\n사소한 것으로 간주되는 메서드(ex. getter)에 대해 level1 컴파일을 수행함\n메서드 복잡성이 낮아 C2컴파일하지 않음 2 C1 with basic profiling JVM은 라이트 프로파일링이 포함된 C1컴파일러를 사용하여 컴파일함\nC2큐가 가득차면 level2를 사용함\n목표는 성능개선을 위해 가능한 빠르게 코드를 컴파일 하는것\n나중에 JVM은 전체 프로파일링을 사용하여 level3으로 코드를 다시 컴파일함\n마지막으로, C2 대기열이 짧아지면, JVM은 level4에서 코드를 다시 컴파일함 3 C1 with full profiling JVM은 전체 프로파일링이 포함된 C1컴파일러를 사용하여 코드를 컴파일함\nlevel3은 기본 compilation path임\nJVM은 사소한 메서드와 컴파일러 대기열이 가득찬 경우를 제외한 모든 경우에 사용함\nJIT컴파일러에서 가장 일반적인 시나리오는 해석된 코드가 레벨 0에서 레벨3으로 바로 점프하는 것임 4 C2 full optimizing, no profiling 장기적인 성능을 극대화 하기 위해 JVM이 C2컴파일러를 사용하여 코드를 컴파일함\nlevel 4는 기본 compilation path임\nJVM은 사소한 메서드를 제외한 모든 메서드를 level4로 컴파일함\nlevel4코드는 완전히 최적화된 것으로 간주되므로 프로파일링 정보 수집을 중단함\n그럼에도, 코드 최적화를 해제하고 레벨 0으로 돌려보낼 수 있음 일반적으로 메서드는 interperter안에서 생성되며 메서드가 실행되는동안 계측을 통해 메서드의 프로파일이 수집됨 수집된 프로파일은 휴리스틱에 의해 사용되며 컴파일될지, 다시 다른 수준에서 컴파일 될지, 어떤 최적화를 수행할지 절정함 메서드를 실행하는 동안 HotSpot이 수집하는 가장 기본적인 두 가지 정보는 메서드가 실행된 횟수와 메서드의 루프가 반복된 휫수임 이 정보는 컴파일 정책에서 메서드를 컴파일 할지 여부와 컴파일 수준을 결정하는데 사용됨 컴파일 정책에서는 현재 compile중인 메서드에 대해 컴파일 요청을 레벨 3에서 설정하기 위해 공식을 사용함 현재 3레벨 컴파일로 실행중인 메서드를 레벨 4로 컴파일 하기 위한 요청을 생성할지 여부를 결정하는 데도 동일한 공식이 사용됨 1 2 3 (Executions > TierXInvocationThreshold * Scale) (Executions\u00a0> TierXMinInvocationThreshold * Scale\u00a0AND\u00a0Executions + Iterations > TierXCompileThreshold * Scale) TierXInvocationThreshold\n"><title>JVM Tiered Compilation</title>
<link rel=canonical href=https://sungho94.me/p/jvm-tiered-compilation/><link rel=stylesheet href=/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="JVM Tiered Compilation"><meta property='og:description' content="Java 언어의 특징 Java는 컴파일 + 인터프리터 두가지 특징을 다 가지고 있음 Java코드를 컴파일하면 .class파일(byte Code)이 되고, JVM은 .class파일을 가지고 os에 맞게 machine code로 변환함 .class파일은 특정 실행횟수가 지나면 최적화가 됨 Tiered Compilation JVM의 JIT Compiler는 자주 실행되는 부분의 코드를 native code로 변환함 JIT compiler에는 2개의 java byte code interpreter가 존재함 Client compiler 메소드를 빠르게 컴파일 하지만 Server compiler보다 덜 최적화된 machine code를 생성함 빠른\x1f 시작에 사용함 Server compiler 동일한 메서드르 컴파일하는데 더 많은 시간이 듬 Client compiler보다 더 많은 시간 및 메모리를 소요하지만, 더 최적화된 machine code를 생성함 Tiered Compilation은 Client compiler를 첫번째 계\x1c으로 사용하여 서버 VM시작 속도를 향상시킴 서버 vm은 인터프리터를 사용하여 컴파일러에 공급되는 메서드에 대한 프로파일링 정보를 수집함 Tiered Compilation에서는 인터프리터 외에도 client compiler가 자신에 대한 프로파일링 정보를 수집하는 메서드의 컴파일된 버전을 생성함 컴파일된 코드가 인터프리터 보다 후러씬 빠르기 때문에, 이 프로파일 단계에서 프로그램이 더 뛰어난 성능으로 실행됨 애플리케이션 초기화 된계에서 server compiler가 생성한 최종 코드를 사용할 수 있기때문에 시작이 더 빠른 경우도 종종 존재함 Tier level 서로 다른 컴파일러와 인터프리터의 결합으로 아래와 같은 5개의 최적화 수준이 생성됨 Level Compiler 0 Interpreter JVM은 모든 자바 코드를 0 level을 사용함\n워밍업 단계가 끝나면 JIT 컴파일러가 시작되어 런타임에 코드를 최적화함\nJIT 컴파일러는 0 level에서 수집한 프로파일링 정보로 최적화 수행 1 C1 without profiling C1컴파일러를 사용하여 코드를 컴파일하지만, 프로파일 정보는 수집하지 않음\n사소한 것으로 간주되는 메서드(ex. getter)에 대해 level1 컴파일을 수행함\n메서드 복잡성이 낮아 C2컴파일하지 않음 2 C1 with basic profiling JVM은 라이트 프로파일링이 포함된 C1컴파일러를 사용하여 컴파일함\nC2큐가 가득차면 level2를 사용함\n목표는 성능개선을 위해 가능한 빠르게 코드를 컴파일 하는것\n나중에 JVM은 전체 프로파일링을 사용하여 level3으로 코드를 다시 컴파일함\n마지막으로, C2 대기열이 짧아지면, JVM은 level4에서 코드를 다시 컴파일함 3 C1 with full profiling JVM은 전체 프로파일링이 포함된 C1컴파일러를 사용하여 코드를 컴파일함\nlevel3은 기본 compilation path임\nJVM은 사소한 메서드와 컴파일러 대기열이 가득찬 경우를 제외한 모든 경우에 사용함\nJIT컴파일러에서 가장 일반적인 시나리오는 해석된 코드가 레벨 0에서 레벨3으로 바로 점프하는 것임 4 C2 full optimizing, no profiling 장기적인 성능을 극대화 하기 위해 JVM이 C2컴파일러를 사용하여 코드를 컴파일함\nlevel 4는 기본 compilation path임\nJVM은 사소한 메서드를 제외한 모든 메서드를 level4로 컴파일함\nlevel4코드는 완전히 최적화된 것으로 간주되므로 프로파일링 정보 수집을 중단함\n그럼에도, 코드 최적화를 해제하고 레벨 0으로 돌려보낼 수 있음 일반적으로 메서드는 interperter안에서 생성되며 메서드가 실행되는동안 계측을 통해 메서드의 프로파일이 수집됨 수집된 프로파일은 휴리스틱에 의해 사용되며 컴파일될지, 다시 다른 수준에서 컴파일 될지, 어떤 최적화를 수행할지 절정함 메서드를 실행하는 동안 HotSpot이 수집하는 가장 기본적인 두 가지 정보는 메서드가 실행된 횟수와 메서드의 루프가 반복된 휫수임 이 정보는 컴파일 정책에서 메서드를 컴파일 할지 여부와 컴파일 수준을 결정하는데 사용됨 컴파일 정책에서는 현재 compile중인 메서드에 대해 컴파일 요청을 레벨 3에서 설정하기 위해 공식을 사용함 현재 3레벨 컴파일로 실행중인 메서드를 레벨 4로 컴파일 하기 위한 요청을 생성할지 여부를 결정하는 데도 동일한 공식이 사용됨 1 2 3 (Executions > TierXInvocationThreshold * Scale) (Executions\u00a0> TierXMinInvocationThreshold * Scale\u00a0AND\u00a0Executions + Iterations > TierXCompileThreshold * Scale) TierXInvocationThreshold\n"><meta property='og:url' content='https://sungho94.me/p/jvm-tiered-compilation/'><meta property='og:site_name' content="Sungho's Dev BLog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Optimize'><meta property='article:tag' content='JVM'><meta property='article:tag' content='hugo_blog'><meta property='article:published_time' content='2024-08-27T22:57:53+00:00'><meta property='article:modified_time' content='2024-09-06T04:47:40+00:00'><meta name=twitter:title content="JVM Tiered Compilation"><meta name=twitter:description content="Java 언어의 특징 Java는 컴파일 + 인터프리터 두가지 특징을 다 가지고 있음 Java코드를 컴파일하면 .class파일(byte Code)이 되고, JVM은 .class파일을 가지고 os에 맞게 machine code로 변환함 .class파일은 특정 실행횟수가 지나면 최적화가 됨 Tiered Compilation JVM의 JIT Compiler는 자주 실행되는 부분의 코드를 native code로 변환함 JIT compiler에는 2개의 java byte code interpreter가 존재함 Client compiler 메소드를 빠르게 컴파일 하지만 Server compiler보다 덜 최적화된 machine code를 생성함 빠른\x1f 시작에 사용함 Server compiler 동일한 메서드르 컴파일하는데 더 많은 시간이 듬 Client compiler보다 더 많은 시간 및 메모리를 소요하지만, 더 최적화된 machine code를 생성함 Tiered Compilation은 Client compiler를 첫번째 계\x1c으로 사용하여 서버 VM시작 속도를 향상시킴 서버 vm은 인터프리터를 사용하여 컴파일러에 공급되는 메서드에 대한 프로파일링 정보를 수집함 Tiered Compilation에서는 인터프리터 외에도 client compiler가 자신에 대한 프로파일링 정보를 수집하는 메서드의 컴파일된 버전을 생성함 컴파일된 코드가 인터프리터 보다 후러씬 빠르기 때문에, 이 프로파일 단계에서 프로그램이 더 뛰어난 성능으로 실행됨 애플리케이션 초기화 된계에서 server compiler가 생성한 최종 코드를 사용할 수 있기때문에 시작이 더 빠른 경우도 종종 존재함 Tier level 서로 다른 컴파일러와 인터프리터의 결합으로 아래와 같은 5개의 최적화 수준이 생성됨 Level Compiler 0 Interpreter JVM은 모든 자바 코드를 0 level을 사용함\n워밍업 단계가 끝나면 JIT 컴파일러가 시작되어 런타임에 코드를 최적화함\nJIT 컴파일러는 0 level에서 수집한 프로파일링 정보로 최적화 수행 1 C1 without profiling C1컴파일러를 사용하여 코드를 컴파일하지만, 프로파일 정보는 수집하지 않음\n사소한 것으로 간주되는 메서드(ex. getter)에 대해 level1 컴파일을 수행함\n메서드 복잡성이 낮아 C2컴파일하지 않음 2 C1 with basic profiling JVM은 라이트 프로파일링이 포함된 C1컴파일러를 사용하여 컴파일함\nC2큐가 가득차면 level2를 사용함\n목표는 성능개선을 위해 가능한 빠르게 코드를 컴파일 하는것\n나중에 JVM은 전체 프로파일링을 사용하여 level3으로 코드를 다시 컴파일함\n마지막으로, C2 대기열이 짧아지면, JVM은 level4에서 코드를 다시 컴파일함 3 C1 with full profiling JVM은 전체 프로파일링이 포함된 C1컴파일러를 사용하여 코드를 컴파일함\nlevel3은 기본 compilation path임\nJVM은 사소한 메서드와 컴파일러 대기열이 가득찬 경우를 제외한 모든 경우에 사용함\nJIT컴파일러에서 가장 일반적인 시나리오는 해석된 코드가 레벨 0에서 레벨3으로 바로 점프하는 것임 4 C2 full optimizing, no profiling 장기적인 성능을 극대화 하기 위해 JVM이 C2컴파일러를 사용하여 코드를 컴파일함\nlevel 4는 기본 compilation path임\nJVM은 사소한 메서드를 제외한 모든 메서드를 level4로 컴파일함\nlevel4코드는 완전히 최적화된 것으로 간주되므로 프로파일링 정보 수집을 중단함\n그럼에도, 코드 최적화를 해제하고 레벨 0으로 돌려보낼 수 있음 일반적으로 메서드는 interperter안에서 생성되며 메서드가 실행되는동안 계측을 통해 메서드의 프로파일이 수집됨 수집된 프로파일은 휴리스틱에 의해 사용되며 컴파일될지, 다시 다른 수준에서 컴파일 될지, 어떤 최적화를 수행할지 절정함 메서드를 실행하는 동안 HotSpot이 수집하는 가장 기본적인 두 가지 정보는 메서드가 실행된 횟수와 메서드의 루프가 반복된 휫수임 이 정보는 컴파일 정책에서 메서드를 컴파일 할지 여부와 컴파일 수준을 결정하는데 사용됨 컴파일 정책에서는 현재 compile중인 메서드에 대해 컴파일 요청을 레벨 3에서 설정하기 위해 공식을 사용함 현재 3레벨 컴파일로 실행중인 메서드를 레벨 4로 컴파일 하기 위한 요청을 생성할지 여부를 결정하는 데도 동일한 공식이 사용됨 1 2 3 (Executions > TierXInvocationThreshold * Scale) (Executions\u00a0> TierXMinInvocationThreshold * Scale\u00a0AND\u00a0Executions + Iterations > TierXCompileThreshold * Scale) TierXInvocationThreshold\n"><link rel="shortcut icon" href=/favicon.png><script async src="https://www.googletagmanager.com/gtag/js?id=G-PTKY5BPR7H"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PTKY5BPR7H")}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="메뉴 여닫기">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu1582294339771580780.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Sungho's Dev BLog</a></h1><h2 class=site-description>백엔드 개발자 황성호입니다.</h2></div></header><ol class=menu-social><li><a href=https://github.com/Star-ho target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://www.linkedin.com/in/starho/ target=_blank title=LinkedIn rel=me><svg fill="#000" width="800" height="800" viewBox="0 0 24 24"><path d="M6.975 20.667H3.117V9.059H6.975zM5.072 3.462a2.011 2.011.0 10-.051 4.012h.026a2.012 2.012.0 10.025-4.012zM9.111 20.667h3.858V14.185a2.639 2.639.0 01.127-.941 2.111 2.111.0 011.98-1.411c1.4.0 1.955 1.064 1.955 2.625v6.209h3.858V14.011c0-3.565-1.9-5.225-4.442-5.225A3.828 3.828.0 0012.97 10.7V9.059H9.111c.051 1.089.0 11.609.0 11.609z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>다크 모드</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">목차</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#java-언어의-특징>Java 언어의 특징</a></li><li><a href=#tiered-compilation>Tiered Compilation</a></li><li><a href=#tier-level>Tier level</a></li><li><a href=#compile-관련-옵션>Compile 관련 옵션</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/jvm/>JVM</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/jvm-tiered-compilation/>JVM Tiered Compilation</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 27, 2024</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>8 분 정도</time></div></footer></div></header><section class=article-content><h2 id=java-언어의-특징>Java 언어의 특징</h2><ul><li>Java는 컴파일 + 인터프리터 두가지 특징을 다 가지고 있음</li><li>Java코드를 컴파일하면 .class파일(byte Code)이 되고, JVM은 .class파일을 가지고 os에 맞게 machine code로 변환함</li><li>.class파일은 특정 실행횟수가 지나면 최적화가 됨</li></ul><h2 id=tiered-compilation>Tiered Compilation</h2><ul><li>JVM의 JIT Compiler는 자주 실행되는 부분의 코드를 native code로 변환함</li><li>JIT compiler에는 2개의 java byte code interpreter가 존재함<ul><li>Client compiler<ul><li>메소드를 빠르게 컴파일 하지만 Server compiler보다 덜 최적화된 machine code를 생성함</li><li>빠른 시작에 사용함</li></ul></li><li>Server compiler<ul><li>동일한 메서드르 컴파일하는데 더 많은 시간이 듬</li><li>Client compiler보다 더 많은 시간 및 메모리를 소요하지만, 더 최적화된 machine code를 생성함</li></ul></li></ul></li><li>Tiered Compilation은 Client compiler를 첫번째 계으로 사용하여 서버 VM시작 속도를 향상시킴</li><li>서버 vm은 인터프리터를 사용하여 컴파일러에 공급되는 메서드에 대한 프로파일링 정보를 수집함</li><li>Tiered Compilation에서는 인터프리터 외에도 client compiler가 자신에 대한 프로파일링 정보를 수집하는 메서드의 컴파일된 버전을 생성함</li><li>컴파일된 코드가 인터프리터 보다 후러씬 빠르기 때문에, 이 프로파일 단계에서 프로그램이 더 뛰어난 성능으로 실행됨</li><li>애플리케이션 초기화 된계에서 server compiler가 생성한 최종 코드를 사용할 수 있기때문에 시작이 더 빠른 경우도 종종 존재함</li></ul><h2 id=tier-level>Tier level</h2><ul><li>서로 다른 컴파일러와 인터프리터의 결합으로 아래와 같은 5개의 최적화 수준이 생성됨</li></ul><div class=table-wrapper><table><thead><tr><th style=text-align:left><strong>Level</strong></th><th style=text-align:left><strong>Compiler</strong></th><th style=text-align:left></th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>Interpreter</td><td style=text-align:left>JVM은 모든 자바 코드를 0 level을 사용함<br>워밍업 단계가 끝나면 JIT 컴파일러가 시작되어 런타임에 코드를 최적화함<br>JIT 컴파일러는 0 level에서 수집한 프로파일링 정보로 최적화 수행</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>C1 without profiling</td><td style=text-align:left>C1컴파일러를 사용하여 코드를 컴파일하지만, 프로파일 정보는 수집하지 않음<br>사소한 것으로 간주되는 메서드(ex. getter)에 대해 level1 컴파일을 수행함<br>메서드 복잡성이 낮아 C2컴파일하지 않음</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>C1 with basic profiling</td><td style=text-align:left>JVM은 라이트 프로파일링이 포함된 C1컴파일러를 사용하여 컴파일함<br>C2큐가 가득차면 level2를 사용함<br>목표는 성능개선을 위해 가능한 빠르게 코드를 컴파일 하는것<br>나중에 JVM은 전체 프로파일링을 사용하여 level3으로 코드를 다시 컴파일함<br>마지막으로, C2 대기열이 짧아지면, JVM은 level4에서 코드를 다시 컴파일함</td></tr><tr><td style=text-align:left>3</td><td style=text-align:left>C1 with full profiling</td><td style=text-align:left>JVM은 전체 프로파일링이 포함된 C1컴파일러를 사용하여 코드를 컴파일함<br>level3은 기본 compilation path임<br>JVM은 사소한 메서드와 컴파일러 대기열이 가득찬 경우를 제외한 모든 경우에 사용함<br>JIT컴파일러에서 가장 일반적인 시나리오는 해석된 코드가 레벨 0에서 레벨3으로 바로 점프하는 것임</td></tr><tr><td style=text-align:left>4</td><td style=text-align:left>C2 full optimizing, no profiling</td><td style=text-align:left>장기적인 성능을 극대화 하기 위해 JVM이 C2컴파일러를 사용하여 코드를 컴파일함<br>level 4는 기본 compilation path임<br>JVM은 사소한 메서드를 제외한 모든 메서드를 level4로 컴파일함<br>level4코드는 완전히 최적화된 것으로 간주되므로 프로파일링 정보 수집을 중단함<br>그럼에도, 코드 최적화를 해제하고 레벨 0으로 돌려보낼 수 있음</td></tr></tbody></table></div><ul><li>일반적으로 메서드는 interperter안에서 생성되며 메서드가 실행되는동안 계측을 통해 메서드의 프로파일이 수집됨</li><li>수집된 프로파일은 휴리스틱에 의해 사용되며 컴파일될지, 다시 다른 수준에서 컴파일 될지, 어떤 최적화를 수행할지 절정함</li><li>메서드를 실행하는 동안 HotSpot이 수집하는 가장 기본적인 두 가지 정보는 메서드가 실행된 횟수와 메서드의 루프가 반복된 휫수임</li><li>이 정보는 컴파일 정책에서 메서드를 컴파일 할지 여부와 컴파일 수준을 결정하는데 사용됨</li><li>컴파일 정책에서는 현재 compile중인 메서드에 대해 컴파일 요청을 레벨 3에서 설정하기 위해 공식을 사용함<ul><li>현재 3레벨 컴파일로 실행중인 메서드를 레벨 4로 컴파일 하기 위한 요청을 생성할지 여부를 결정하는 데도 동일한 공식이 사용됨</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(Executions &gt; TierXInvocationThreshold * Scale)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>(Executions &gt; TierXMinInvocationThreshold * Scale AND Executions + Iterations &gt; TierXCompileThreshold * Scale)
</span></span></code></pre></td></tr></table></div></div><ul><li><p>TierXInvocationThreshold</p><ul><li>호출 수가 이 임계값을 초과하는 경우, 메서드를 레벨X로 컴파일함</li><li>기본값은 레벨 3의 경우 200, 레벨 4의 경우 5000</li></ul></li><li><p>TierXMinInvocationThreshold</p><ul><li>메서드를 레벨 X에서 컴파일하는데 필요한 최소 실행 횟수</li><li>기본값은 레벨 3의 경우 100, 레벨 4의 경우 600</li></ul></li><li><p>TierXCompileThreshold</p><ul><li>메서드와 해당 루프의 반복 횟수가 이 임계값보다 . 더많이 실행된 경우 메서드를 레벨 X에서 컴파일함</li><li>기본값은 레벨 3의 경우 2000, 레벨 4의 경우 15000</li></ul></li><li><p>Executions</p><ul><li>메서드가 실행된 횟수</li></ul></li><li><p>Iterations</p><ul><li>메서드 내부의 루프가 실행된 누적 반복 횟수</li></ul></li><li><p>Scale</p><ul><li>컴파일 대기열 부하를 안정적으로 유지하기 위한 Scale 계수</li><li>컴파일 대기열 함목 수와 컴파일러 스레드 수에 따라 주기적으로 동적으로 조정됨</li></ul></li><li><p>HoptSpot은 컴파일이 다른 부분에 미치는 영향과 시스템이 현재 처리하고 있는 부하량도 고려함</p></li><li><p>메서드를 해석중이고 위의 공식이 충족되어 레벨 3에서 메서드를 컴파일한다고 가정하면 컴파일 정책이 실제로 레3이 아닌 레벨2에서 컴파일 하기로 결정할 수 있음</p><ul><li>C2 대기열의 길이<ul><li>일반적으로 레벨 3에서 컴파일된 메서드는 레벨2에서 컴파일된 동일한 메서드보다 느리기 때문에 메서드가 레벨3에서 보내는 시간을 최소화 하는 것이 좋음</li><li>적절한 프로파일리을 수집하여 필요한 시간만 레벨 3에서 소비해야함</li><li>따라서 C2대기열이 너무 길어, 레벨 3로 전환되는게 너무 오래걸린다면 우선 레벨 2로 이동하는 것이 유리함<ul><li>추후 C2대기열이 줄어든다면 레벨 3에서 메서드를 다시 컴파일함</li></ul></li></ul></li><li>C1대기열 길이는 임계값을 동적으로 조정하고, 컴파일러가 과부하 될때 추가 필터링을 도입하는데 사용됨<ul><li>컴파일러 대기열이 너무 길면 컴파일이 완료될 때 까지 메서드가 더이상 실행되지 않을 수 있기 때문</li></ul></li></ul></li><li><p>레벨 3에서 컴파일된 메서드가 레벨 4로 전환하기 위한 공식을 충족할 만큼 충분하 실행되면, 해당 레벨에서 메서드를 다시 컴파일 하라는 요청이 생성됨</p></li><li><p>이 level에서는 HotSpot은 장기적인 성능을 극대화 하기 위해 C2 컴파일러를 사용하여 코드를 컴파일함</p></li><li><p>레벨 4코드는 완전히 최적화된 것으로 간주되므로 JVM은 프로파일링 정보 수집을 중단함</p></li><li><p>위 설명은 컴파일 정책의 단순화된 버전임, 메서드를 컴파일하거나 다시 컴파일할지 결정할 때 HotSpot이 고려하는 몇가지 다른 사항과 JVM 사용자가 정책을 정의하는데 사용할 수 있는 몇개의 플래그가 있음</p><ul><li>아래는 최적화와 연관된 이야기임</li></ul></li><li><p>C2는 메소드의 동적 프로파일에 대한 정보를 사용하여 몇가지 최적화를 안내함</p><ul><li>Inlining, Class Hierarchy Analysis(CHA), basic block ordering, some loop optimizations</li></ul></li><li><p>프로파일이 <code>if-else</code>문이 과거에 <code>then</code>부분만 실행했음을 보여줄 떄,</p><ul><li>C2는 앞으로도 계속 이런 일이 발생할 것이라 가정하고, <code>else</code>블록은 전혀 컴파일 하지 않기로 결정</li></ul></li><li><p>프로파일이 참조 변수가 절대 null이 아니라고 보여줄 때,</p><ul><li>C2는 향후 실행에서 변수가 계속 null이 아닐것이라고 가정하고, 그 가정을 사용하여 코드를 최적화 할 수 있음</li></ul></li><li><p>프로필이 루프가 일반적으로 수천번 반복된다고 보여줄 때,</p><ul><li>C2는 해당 정보를 기반으로 루프를 unrolling 또는 벡터화 할 수 있음</li></ul></li><li><p>프로파일이 클래스에 서브클래스가 없음을 보여줄 때,</p><ul><li>C2는 해당 클래스의 객체를 사용하여 메서드 호출에서 인라인 또는 다른 종류의 최적하를 수행하기로 결정할 수 있음</li></ul></li><li><p>메서드의 프로파일은 동적 문제가 있음</p></li><li><p>애플리케이션이 실행동항 메서드의 프로파일이 안정적일것이라는 보장은 없음</p><ul><li>프로그램 실행 중 대부분 참이었던 <code>if-else</code>조건이 갑자기 거짓을 반환함</li><li>트리거 되지 않었던 예외가 트리거됨</li><li>한번도 null이 아니었던 참조변수가 null로 표시됨</li><li>시스템에 새클래스가 로드되고, 이전에는 단순했던 클래스 계층구조가 더 복잡해짐</li><li>일반적으로 수천번 반복되는 루프가 이제는 몇번만 반복함</li></ul></li><li><p>이러한 동적 동작을 고려하기 위해, C2는 컴파일된 코드에 predicates를 삽입하여 프로파일 정보를 기반으로 한 가정이 예전이 유효한지 확인함</p></li><li><p>predicate가 false인 경우, 트랩(JVM 내부에 대한 호출)이 실행되어 어떤 가정이 거짓인지 HotSpot에 알림</p></li><li><p>트랩이 제공한 정보를 바탕으로 HotSpot은 수행해야 할 작업을 결정함</p></li><li><p>현재 컴파일된 메서드를 다시 컴파일할 수 있고, 실행을 인터프리터로 전환해야 할 수도 <a class=link href=https://github.com/openjdk/jdk/blob/8eed7dea7b92dd98b74277e8521100f7f807eabb/src/hotspot/share/runtime/deoptimization.hpp#L69 target=_blank rel=noopener>https://github.com/openjdk/jdk/blob/8eed7dea7b92dd98b74277e8521100f7f807eabb/src/hotspot/share/runtime/deoptimization.hpp#L69</a></p></li><li><p>트랩이 실행될 수 있는 가능한 이유 목록 <a class=link href>링크</a></p><ul><li>필요한 조치목록<a class=link href=https://github.com/openjdk/jdk/blob/8eed7dea7b92dd98b74277e8521100f7f807eabb/src/hotspot/share/runtime/deoptimization.hpp#L144 target=_blank rel=noopener>링크</a><br><br><img src=/image/real-resource-image/Pasted%20image%2020240905231051.png loading=lazy alt=center></li></ul></li></ul><h2 id=compile-관련-옵션>Compile 관련 옵션</h2><blockquote><p>default로 TieredCompilation은 활성화 되어있음</p></blockquote><ul><li><p>-Xcomp</p><ul><li>메서드를 컴파일만 하도록 설정</li><li>HotSpot은 인터프리터를 사용하지 않으며 메서드는 항상 컴파일됨</li></ul></li><li><p>-Xint</p><ul><li>메서드를 인터프리터만 사용하도록 수정</li><li>모든 JIT컴파일러가 비활성화되고 HotSpot이 프로그램을 실행하는 유일한 수단은 interpretation임</li></ul></li><li><p>-XX:TieredStopAtLevel</p><ul><li>최대 컴파일 수준을 설정하는데 사용함</li><li>일부 C2버그를 우회하거나 C1을 스트레스 테스트 하기 위해 C1컴파일러만 사용하도록 강제하는것</li></ul></li><li><p>-XX:-TieredCompilation</p><ul><li>HotSpot이 Tiered Compilation heuristics을 사용하여 컴파일간 전환하지 않고, 다른 heuristics을 사용하여 모든 컴파일에 대해 C1과 C2를 선택하게함</li></ul></li><li><ul><li>XX:InitialCodeCacheSize=N</li></ul></li><li><ul><li>XX:ReservedCodeCacheSize=N`</li></ul></li><li><p>-XX:NonNMethodCodeHeapSize</p><ul><li>non-method segment 영역을 지정</li><li>JVM내부 관련코드(default 대략 5MB)</li></ul></li><li><p>-XX:ProfiledCodeHeapSize</p><ul><li>profiled-Code segment 영역 지정</li><li>C1으로 컴파일된, 잠재적으로 짧은 수명을 가진 영역(default 대략 122MB)</li></ul></li><li><p>-XX:NonProfiledCodeHeapSize</p><ul><li>non-profiled-code segment 영역 지정</li><li>C2로 컴파일된, 잠재적으로 긴 수명을 가진 영역(default 대략 122MB)</li></ul></li><li><p>-XX:Tier4CompileThreshold</p><ul><li>Tier4로 컴파일 하는 Threshold를 지정</li></ul></li><li><p>-XX:+PrintCompilation</p><ul><li>default로, JIT compilation log는 disable되어 있음</li><li>위 옵션으로 JIT compilation log를 활성화 할 수 있음</li><li>아래의 포맷을 가짐<ul><li>Timestamp<ul><li>애플리케이션 시작 . 후밀리초 단위</li></ul></li><li>Compile ID<ul><li>컴파일되 각 메소드의 increment ID</li></ul></li><li>Attribute<ul><li>5가지 값의 상태를 가짐<ul><li>% - 온스택 교체 발생</li><li>s - 메소드가 동기화됨</li><li>! - 메소드가 exception handler를 포함하고 있음</li><li>b - blocking모드에서 컴파일이 발생</li><li>n - 컴파일이 래퍼를 네이티브 메서드로 변환함</li></ul></li></ul></li><li>Compilation level<ul><li>0에서 4사이 값을 가짐</li></ul></li><li>Method name</li><li>Bytecode size</li><li>Deoptimisation indicator<ul><li>Made not entrant<ul><li>표준 C1 최적화 또는 컴파일러의 낙관적 가정이 잘못된것으로 이증되을때</li></ul></li><li>Made zombie<ul><li>코드캐시에서 공간을 확보하기 위해 gc의 정리 메커니즘</li></ul></li></ul></li></ul></li></ul></li><li><p>아래는 AMD Ryzen 7 1800X machine running Ubuntu 20.04에서 java-17.07으로 HelloWorld 프로그램을 실행한 결과임</p></li></ul><div class=table-wrapper><table><thead><tr><th style=text-align:left>Flags</th><th style=text-align:left>Average Wall Time</th></tr></thead><tbody><tr><td style=text-align:left>&ldquo;Default&rdquo;</td><td style=text-align:left>0.020s</td></tr><tr><td style=text-align:left>-Xint</td><td style=text-align:left>0.020s</td></tr><tr><td style=text-align:left>-Xcomp</td><td style=text-align:left>0.890s</td></tr></tbody></table></div><ul><li>-Xcomp로 실행한것이 현저하게 느린것을 확인할 수 있는데, 이는 많은 메서드가 컴파일 비용을 상쇄할만큼 충분히 실행하지 않았기 때문</li><li>인터프리터만 사용하도록 JVM을 구성하면, 사용자 지정을 하지 않았을때와 같은데, 이는 예제가 오래 실행되는 메서드가 없기에, 인터프리터가 최선의 선택이기 때문임</li></ul><p><a class=link href=https://www.baeldung.com/jvm-tiered-compilation target=_blank rel=noopener>https://www.baeldung.com/jvm-tiered-compilation</a><br><a class=link href=https://docs.oracle.com/en/java/javase/11/jrockit-hotspot/compilation-optimization.html#GUID-8033B236-F6E5-473B-BB9F-34422143A1AA target=_blank rel=noopener>https://docs.oracle.com/en/java/javase/11/jrockit-hotspot/compilation-optimization.html#GUID-8033B236-F6E5-473B-BB9F-34422143A1AA</a><br><a class=link href=https://devblogs.microsoft.com/java/how-tiered-compilation-works-in-openjdk/ target=_blank rel=noopener>https://devblogs.microsoft.com/java/how-tiered-compilation-works-in-openjdk/</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/optimize/>Optimize</a>
<a href=/tags/jvm/>JVM</a>
<a href=/tags/hugo_blog/>Hugo_blog</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>마지막 수정: Sep 06, 2024 04:47 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>관련 글</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/5-executorservice-countdownlatch/><div class=article-details><h2 class=article-title>5-ExecutorService & CountDownLatch</h2></div></a></article><article><a href=/p/4-volitile/><div class=article-details><h2 class=article-title>4-Volitile</h2></div></a></article><article><a href=/p/2-semaphore/><div class=article-details><h2 class=article-title>2-Semaphore</h2></div></a></article><article><a href=/p/1-reentrantlock-condition/><div class=article-details><h2 class=article-title>1-ReentrantLock & Condition</h2></div></a></article><article><a href=/p/0-lock-%EC%A0%95%EC%9D%98-synchronized/><div class=article-details><h2 class=article-title>0-Lock 정의 & synchronized</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=Star-ho/star-ho.github.io issue-term=pathname label=Comments crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2024 Sungho's Dev BLog</section><section class=powerby><a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a>로 만듦<br><a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>의 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 테마 사용 중</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>