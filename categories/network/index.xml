<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Network on Sungho's Dev BLog</title><link>https://sungho94.me/categories/network/</link><description>Recent content in Network on Sungho's Dev BLog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sun, 14 Jul 2024 23:01:00 +0000</lastBuildDate><atom:link href="https://sungho94.me/categories/network/index.xml" rel="self" type="application/rss+xml"/><item><title>HTTP Client Timeout</title><link>https://sungho94.me/p/http-client-timeout/</link><pubDate>Sun, 14 Jul 2024 23:01:00 +0000</pubDate><guid>https://sungho94.me/p/http-client-timeout/</guid><description>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240715122255.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="connection-timeout">Connection Timeout
&lt;/h2>&lt;ul>
&lt;li>client가 server에 커넥션을 연결을 시도하는 최대 시간 지정
&lt;ul>
&lt;li>the time to establish the connection with the remote host&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="socket-timeout">Socket Timeout
&lt;/h2>&lt;ul>
&lt;li>server와의 연결이 완료된 시점에서, 데이터의 송수신을 할 최대 시간 지정
&lt;ul>
&lt;li>두 데이터패킷 사이 비활성화된 최대 시간&lt;/li>
&lt;li>maximum time of inactivity between two data packets&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="http-manager-timeout">HTTP Manager Timeout
&lt;/h2>&lt;ul>
&lt;li>HTTP Client 라이브러리에서는 내부적으로 HTTP 커넥션 풀을 관리함&lt;/li>
&lt;li>HTTP 커넥션 풀에서 커넥션을 가져오는데 걸리는 최대 시간 제어&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.baeldung.com/httpclient-timeout" target="_blank" rel="noopener"
>https://www.baeldung.com/httpclient-timeout&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/18184899/what-is-the-difference-between-the-setconnectiontimeout-setsotimeout-and-http" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/18184899/what-is-the-difference-between-the-setconnectiontimeout-setsotimeout-and-http&lt;/a>&lt;/p></description></item><item><title>URL, URN, URI</title><link>https://sungho94.me/p/url-urn-uri/</link><pubDate>Tue, 09 Apr 2024 22:31:29 +0000</pubDate><guid>https://sungho94.me/p/url-urn-uri/</guid><description>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240409223209.png"
loading="lazy"
alt="|center|600"
>&lt;/p>
&lt;h2 id="uriuniform-resource-identifier">URI(Uniform Resource Identifier)
&lt;/h2>&lt;ul>
&lt;li>통합 자원 식별자&lt;/li>
&lt;li>인터넷에 있는 자원을 나타내는 유일한 주소&lt;/li>
&lt;li>URN과 URL을 포괄하는 개념&lt;/li>
&lt;li>URL은 URI가 될 수 없지만, URI는 URL이 될 수 있음&lt;/li>
&lt;li>&lt;em>제한적인 URL과 URN보다는 URI라는 용어를 쓰자&lt;/em>&lt;/li>
&lt;li>예시
&lt;ul>
&lt;li>data:text/plain;base64,SGVsbG8gV29ybGQh&lt;/li>
&lt;li>data:image/jpeg;base64,/9j/4AAQSkZJRgAB…&lt;/li>
&lt;li>tel:+1234567890&lt;/li>
&lt;li>tel:555–123–4567&lt;/li>
&lt;li>file:///path/to/file.txt&lt;/li>
&lt;li>file:///C:/Documents/document.docx&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="urluniform-resource-locator">URL(Uniform Resource Locator)
&lt;/h2>&lt;ul>
&lt;li>통합 자원 위치&lt;/li>
&lt;li>인터넷에서 웹페이지, 이미지, 비디오 등 리소스의 위치를 가르키는 문자열&lt;/li>
&lt;li>자원를 식별하는것 뿐만아니라 수단을 제공&lt;/li>
&lt;li>예시
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.example.com/index.html" target="_blank" rel="noopener"
>https://www.example.com/index.html&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="http://api.example.com/data" target="_blank" rel="noopener"
>http://api.example.com/data&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="ftp://ftp.example.com/files/document.pdf" >ftp://ftp.example.com/files/document.pdf&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="mailto:info@example.com" >info@example.com&lt;/a>&lt;/li>
&lt;li>mailto:user@example.com?subject=Hello&amp;amp;body=Hi%20there&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="urnuniform-resource-name">URN(Uniform Resource Name)
&lt;/h2>&lt;ul>
&lt;li>통합 자원 이름&lt;/li>
&lt;li>지속적이고, 위치에 독립적인 리소스 식별자&lt;/li>
&lt;li>예시
&lt;ul>
&lt;li>urn:isbn:0–486–27557–4&lt;/li>
&lt;li>urn:ietf:rfc:3986&lt;/li>
&lt;li>urn:oid:2.16.840&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3" target="_blank" rel="noopener"
>https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3&lt;/a>&lt;br>
&lt;a class="link" href="https://blog.bytebytego.com/i/132279282/url-uri-urn-do-you-know-the-differences" target="_blank" rel="noopener"
>https://blog.bytebytego.com/i/132279282/url-uri-urn-do-you-know-the-differences&lt;/a>&lt;br>
&lt;a class="link" href="https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-URL-URI-%EC%B0%A8%EC%9D%B4" target="_blank" rel="noopener"
>https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-URL-URI-%EC%B0%A8%EC%9D%B4&lt;/a>&lt;br>
&lt;a class="link" href="https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9" target="_blank" rel="noopener"
>https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9&lt;/a>_%EC%9E%90%EC%9B%90_%EC%8B%9D%EB%B3%84%EC%9E%90&lt;/p></description></item><item><title>네트워크에서 들어온 데이터가 어플리케이션에서 사용되기까지</title><link>https://sungho94.me/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%97%90%EC%84%9C-%EB%93%A4%EC%96%B4%EC%98%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EA%B8%B0%EA%B9%8C%EC%A7%80/</link><pubDate>Sat, 06 Jan 2024 22:09:41 +0000</pubDate><guid>https://sungho94.me/p/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EC%97%90%EC%84%9C-%EB%93%A4%EC%96%B4%EC%98%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EC%96%B4%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%EB%90%98%EA%B8%B0%EA%B9%8C%EC%A7%80/</guid><description>&lt;ul>
&lt;li>
&lt;p>먼저 네트워크에서 데이터가 들어오면 nic에서 데이터를 받아 kernel buffer에 저장함&lt;/p>
&lt;ul>
&lt;li>이때 데이터를 처리하는 방식이 4가지 존재 &lt;a class="link" href="https://dfdeboer.github.io/BURKS/pcinfo/hardware/ethernet/nic.htm" target="_blank" rel="noopener"
>링크&lt;/a>
&lt;ul>
&lt;li>데이터가 들어오면 바로 interrupt를 발생시켜 mainboard의 cpu를 사용하는방식&lt;/li>
&lt;li>NIC의 cpu를 사용해서 데이터를 저장하고 저장이 끝나면 interrupt를 발생시키는 방식&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>커널 버퍼에 있는 데이터를 실제 사용할 프로세스에 전달하는 과정&lt;/p>
&lt;ul>
&lt;li>커널버퍼와 유저버퍼가 따로있다
&lt;ul>
&lt;li>커널버퍼는 모든 프로세스가 사용할수 있는 공유공간&lt;/li>
&lt;li>유저버퍼는 우리가 실행한 프로세스가 사용하는 공간&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>커널버퍼에 있는 데이터를 유저버퍼에 가져오려면 system call을 호출해야함&lt;/li>
&lt;li>소켓의 모드에 따라 blocking, non-blocking이 나눠짐
&lt;ul>
&lt;li>blocking 방식
&lt;ul>
&lt;li>accept 호출 시 쓰레드는 데이터를 가져올 때까지 계속 대기함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>non-blocking 방식
&lt;ul>
&lt;li>accept 호출 시 데이터가 없을경우 &lt;strong>ERROR WOULD BLOCK&lt;/strong>을 리턴하여 쓰레드가 block되지 않음, 데이터가 있을경우 데이터를 가져옴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>I/O multiplexing&lt;/p>
&lt;ul>
&lt;li>하나의 쓰레드에서 하나이상의 소켓을 관리하는 방법&lt;br>
- select, epoll, io_uring, IOCP 등이 사용됨&lt;br>
- 바로 accept를 호출하는 것이 아니라, 소켓에서 변경이 발생했는지 여부를 먼저 확인하고 변경이 발생하면 accept를 호출함&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="왜-block-io보다-io-multiplexing이-느릴까">왜 Block IO보다 IO Multiplexing이 느릴까?
&lt;/h2>&lt;h2 id="block-io">Block I/O
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231105204457.png"
loading="lazy"
alt="Pasted image 20231105204457"
>&lt;/p>
&lt;ul>
&lt;li>데이터가 커널로 들어오면 데이터가 바로 커널스페이스에서 유저스페이스로 이동함&lt;/li>
&lt;/ul>
&lt;h2 id="non-block-io">Non Block I/O
&lt;/h2>&lt;ul>
&lt;li>방법이 2가지 있음&lt;/li>
&lt;/ul>
&lt;h3 id="데이터가-들어왔는지-반복해서-확인">데이터가 들어왔는지 반복해서 확인
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231105204700.png"
loading="lazy"
alt="Pasted image 20231105204700"
>&lt;/p>
&lt;ul>
&lt;li>우선 반복적으로 확인하기 때문에 cpu 자원낭비가 됨&lt;/li>
&lt;li>데이터가 들어온시점과 반복적으로 확인한 시점 사이에 시간차가 발생할 수 밖에 없기 때문에 Block I/O보다 느림&lt;/li>
&lt;/ul>
&lt;h3 id="데이터가-들어오면-알려-줌">데이터가 들어오면 알려 줌
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231105205052.png"
loading="lazy"
alt="Pasted image 20231105205052"
>&lt;/p>
&lt;ul>
&lt;li>데이터가 들어오면 커널에서 알려줌&lt;/li>
&lt;li>알려주면 쓰레드에서 read syscall을 날려서 데이터를 읽음&lt;/li>
&lt;li>커널에서 데이터가 들어온걸 알려주고, 쓰레드가 확인해서 해당 데이터를 가져오기 까지 시간 텀이 발생함&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://marmelo12.tistory.com/287" target="_blank" rel="noopener"
>https://marmelo12.tistory.com/287&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/" target="_blank" rel="noopener"
>https://www2.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.youtube.com/watch?v=uagKTbohimU" target="_blank" rel="noopener"
>https://www.youtube.com/watch?v=uagKTbohimU&lt;/a>&amp;amp;list=PLBlnK6fEyqRgKl0MbI6kbI5ffNt7BF8Fn&amp;amp;index=13&lt;/p>
&lt;p>&lt;a class="link" href="https://dfdeboer.github.io/BURKS/pcinfo/hardware/ethernet/nic.htm" target="_blank" rel="noopener"
>https://dfdeboer.github.io/BURKS/pcinfo/hardware/ethernet/nic.htm&lt;/a>&lt;br>
&lt;a class="link" href="https://dfdeboer.github.io/BURKS/pcinfo/hardware/ethernet/hyperlin.htm" target="_blank" rel="noopener"
>https://dfdeboer.github.io/BURKS/pcinfo/hardware/ethernet/hyperlin.htm&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://d2.naver.com/helloworld/47667" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/47667&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://engineering.linecorp.com/ko/blog/do-not-block-the-event-loop-part1" target="_blank" rel="noopener"
>https://engineering.linecorp.com/ko/blog/do-not-block-the-event-loop-part1&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://meetup.nhncloud.com/posts/54#:~:text=%EC%9C%84%EC%97%90%EC%84%9C%20%EB%91%90%20%EA%B0%92%EC%9D%80%20%EA%B0%81%EA%B0%81%20%EC%82%AC%EC%9A%A9%ED%95%A0%20%ED%8F%AC%ED%8A%B8%20%EB%B2%94%EC%9C%84%EC%9D%98,%EC%86%8C%EC%BC%93%20%EC%88%98%EB%8A%94%20%EC%9D%B4%EC%97%90%20%EB%AF%B8%EC%B9%98%EC%A7%80%20%EB%AA%BB%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4" target="_blank" rel="noopener"
>https://meetup.nhncloud.com/posts/54#:~:text=%EC%9C%84%EC%97%90%EC%84%9C%20%EB%91%90%20%EA%B0%92%EC%9D%80%20%EA%B0%81%EA%B0%81%20%EC%82%AC%EC%9A%A9%ED%95%A0%20%ED%8F%AC%ED%8A%B8%20%EB%B2%94%EC%9C%84%EC%9D%98,%EC%86%8C%EC%BC%93%20%EC%88%98%EB%8A%94%20%EC%9D%B4%EC%97%90%20%EB%AF%B8%EC%B9%98%EC%A7%80%20%EB%AA%BB%ED%95%A0%20%EC%88%98%20%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4&lt;/a>&lt;/p>
&lt;p>#Network&lt;br>
#ComputerScience&lt;br>
#Non-Blocking-IO&lt;/p></description></item><item><title>Long polling, Streaming, Web Socket</title><link>https://sungho94.me/p/long-polling-streaming-web-socket/</link><pubDate>Thu, 04 Jan 2024 22:47:40 +0000</pubDate><guid>https://sungho94.me/p/long-polling-streaming-web-socket/</guid><description>&lt;h2 id="why">Why?
&lt;/h2>&lt;ul>
&lt;li>클라이언트가 서버에게 http요청을 보내는 상황이 아닌, 서버에서 클라이언트에게 요청을 보내는 상황이 발생시 유용함
&lt;ul>
&lt;li>서버에서 작업이 즉시 처리되지 않고, 처리되기까지 대기해야하는 상황&lt;/li>
&lt;li>서버에서 어떤 이벤트 발생 시 클라이언트에게 알려야 하는 상황&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>이를 위한 방안으로 polling, Long polling, streaming, web socket, plugin 등의 방안이 존재&lt;/li>
&lt;/ul>
&lt;h2 id="자세한-내용은-rfc파일을-참고">자세한 내용은 RFC파일을 참고
&lt;/h2>&lt;ul>
&lt;li>당장 사용할 사항이 아니고, 단지 궁금증에 알아보는 것이니 이 문서에서는 간단하게 요약&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Long polling과 streaming은 &lt;a class="link" href="https://datatracker.ietf.org/doc/html/rfc6202" target="_blank" rel="noopener"
>RFC6202&lt;/a>참고&lt;br>
Web socket은 &lt;a class="link" href="https://datatracker.ietf.org/doc/html/rfc6455" target="_blank" rel="noopener"
>RFC6455&lt;/a> 참고&lt;/p>
&lt;/blockquote>
&lt;h2 id="pooling폴링">Pooling(폴링)
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240329225214.png"
loading="lazy"
alt="center|400"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트가 주기적으로 서버에 요청을 보내서 확인하는 방식&lt;/li>
&lt;li>클라이언트가 주기적으로 서버에 요청을 보내므로 서버의 변경에 즉시 대응하지 못함&lt;/li>
&lt;li>다른 방법들은 서버에서 커넥션을 유지하고 있어야 하는 반면 폴링 방식에서는 커넥션을 유지하지 않아도 돼 서버에 부하가 적음&lt;/li>
&lt;/ul>
&lt;h2 id="long-polling롱폴링">Long polling(롱폴링)
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240329225407.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트가 요청을 보내면, 서버에서 커넥션을 유지하다가 이벤트가 발생하면 응답하는 방식&lt;/li>
&lt;li>폴링에 비해 실시간 처리가 가능함&lt;/li>
&lt;li>서버가 여러번 응답을 해야 하는 상황에서는 효율이 좋지 않음
&lt;ul>
&lt;li>서버가 응답을 한 후 클라이언트가 다시 요청해서 커넥션을 유지해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Time-out 오류가 발생할 수 있음&lt;/li>
&lt;/ul>
&lt;h2 id="streaming스트리밍">Streaming(스트리밍)
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240329230355.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>클라이언트가 요청을 보내면, 서버에서는 커넥션을 유지하고 리스폰스를 보내는 방식&lt;/li>
&lt;li>한번 응답을 보내고 커넥션이 끊어지는 것이 아니라 계속 응답을 보낼 수 있음&lt;/li>
&lt;li>HTTP/1.1 또는 HTTP/1.0에서 가능&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>RFC문서에서는 위 두버전만 명시되어 있지만, 해당 문서는 2011년에 작성되었기에, 위 두 버전만 명시한것으로 보임&lt;br>
그 이후버전에서도 가능할것이라 생각함&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>HTTP의 EOF와 chunked transfer를 사용하여 연결을 지속함
&lt;ul>
&lt;li>HTTP/1.0에서는 EOF만 사용가능함&lt;/li>
&lt;li>HTTP/1.1에서는 EOF와 chunked transfer 둘다 사용가능함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="web-socket">Web Socket
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240329231640.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>위의 방식들은 HTTP를 잘 활용해서 만든 방식이라면 Web Socket은 HTTP 프로토콜을 사용하지 않음&lt;/li>
&lt;li>양방향으로 통신이 가능한 방식으로 언제든 서로 데이터를 보낼 수 있음&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://dydtjr1128.github.io/etc/2019/09/23/polling-long-polling-streaming.html" target="_blank" rel="noopener"
>https://dydtjr1128.github.io/etc/2019/09/23/polling-long-polling-streaming.html&lt;/a>&lt;br>
&lt;a class="link" href="https://bcho.tistory.com/896" target="_blank" rel="noopener"
>https://bcho.tistory.com/896&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/12555043/my-understanding-of-http-polling-long-polling-http-streaming-and-websockets" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/12555043/my-understanding-of-http-polling-long-polling-http-streaming-and-websockets&lt;/a>&lt;br>
&lt;a class="link" href="https://sendbird.com/ko/developer/tutorials/websocket-vs-http-communication-protocols" target="_blank" rel="noopener"
>https://sendbird.com/ko/developer/tutorials/websocket-vs-http-communication-protocols&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://datatracker.ietf.org/doc/html/rfc6202" target="_blank" rel="noopener"
>https://datatracker.ietf.org/doc/html/rfc6202&lt;/a>&lt;br>
&lt;a class="link" href="https://datatracker.ietf.org/doc/html/rfc6455" target="_blank" rel="noopener"
>https://datatracker.ietf.org/doc/html/rfc6455&lt;/a>&lt;/p></description></item><item><title>0.0.0.0 ip address</title><link>https://sungho94.me/p/0.0.0.0-ip-address/</link><pubDate>Tue, 03 Oct 2023 10:10:26 +0000</pubDate><guid>https://sungho94.me/p/0.0.0.0-ip-address/</guid><description>&lt;p>0.0.0.0 is a valid address syntax. So it should parse as valid wherever an IP address in traditional dotted-decimal notation is expected.&lt;/p>
&lt;p>0.0.0.0주소는 모든 ip를 의미한다&lt;br>
접근제어시 0.0.0.0으로 설정하여 모든 ip를 허용하거나 거부할 수 있다.&lt;/p>
&lt;p>&lt;a class="link" href="https://www.howtogeek.com/225487/what-is-the-difference-between-127.0.0.1-and-0.0.0.0/" target="_blank" rel="noopener"
>https://www.howtogeek.com/225487/what-is-the-difference-between-127.0.0.1-and-0.0.0.0/&lt;/a>&lt;/p>
&lt;p>#ComputerScience&lt;/p></description></item></channel></rss>