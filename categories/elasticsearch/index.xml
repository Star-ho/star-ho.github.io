<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ElasticSearch on Sungho's Dev BLog</title><link>https://sungho94.me/categories/elasticsearch/</link><description>Recent content in ElasticSearch on Sungho's Dev BLog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sun, 23 Jun 2024 10:45:30 +0000</lastBuildDate><atom:link href="https://sungho94.me/categories/elasticsearch/index.xml" rel="self" type="application/rss+xml"/><item><title>Elasticsearch write</title><link>https://sungho94.me/p/elasticsearch-write/</link><pubDate>Sun, 23 Jun 2024 10:45:30 +0000</pubDate><guid>https://sungho94.me/p/elasticsearch-write/</guid><description>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240623104840.png"
loading="lazy"
alt="|center"
>&lt;/p>
&lt;h2 id="1-coordinateing-stage">1. coordinateing stage
&lt;/h2>&lt;ul>
&lt;li>Elasticsearch의 모든 색인 작업은 일반적으로 document ID(routing_key)를 기반으로 라우팅을 사용해 복제 그룹을 확인함
&lt;ul>
&lt;li>&lt;code>shard = hash(routing_key) % number_of_primary_shards&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>복제 그룹이 확인되면, 그 작업은 내부적으로 그룹의 현재 기본 샤드로 전달됨&lt;/li>
&lt;/ul>
&lt;h2 id="2-primary-stage">2. primary stage
&lt;/h2>&lt;ul>
&lt;li>primary 샤드는 작업의 유효성을 검증하고, replica 샤드로 전달하는 역할&lt;/li>
&lt;li>replica 샤드는 오프라인 상태일 수 있으므로 primary 샤드가 모든 replica에 복제할 필요가 없음
&lt;ul>
&lt;li>대신 Elasticsearch는 작업을 수신해야 하는 샤드 복제본 목록을 유지함&lt;/li>
&lt;li>이 목록을 &lt;code>in-sync copies&lt;/code>라고 불리며, 마스터노드에서 관리됨&lt;/li>
&lt;li>사용자에게 승인된 모든 인덱스 및 삭제 작업을 처리했음을 보장하는 정상 샤드 복사본 직합&lt;/li>
&lt;li>primary는 이 불변성을 유지할 책임이 있으므로, 모든 작업을 해당 세트의 replica에 복제해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>기본 샤드의 요청 흐름&lt;br>
2-1. 들어오는 연산의 유효성을 검사하고, 유효하지 않은 경우 거부함&lt;br>
ex) 숫자 필드에 객체 필드가 들어오는경우&lt;br>
2-2. local에서 작업을 수행하고, 관련 document를 indexing하거나 삭제함
&lt;ul>
&lt;li>유효성을 검사하고 필요할경우 거부함(키워드가 너무 길어 Lucene에 색인할 수 없는경우)&lt;br>
2-3. in-sync copies set의 각 replica에게 작업을 전송함&lt;/li>
&lt;li>복제본이 여러개인 경우, 병렬로 수행됨&lt;br>
2-4. 모든 in-sync copies set이 작업을 성공적으로 수행하고, primary에 응답하면 primary는 클라이언트에 대한 요청이 정상적으로 완료되었음을 알 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>검색은 in-sync copies에 있는 reaplica샤드 뿐만아닌, 모든 replica 샤드에서 검색이 가능함&lt;br>
모든 replica샤드에 요청이 전파되어 저장되기 전에, in-sync copies외 샤드에 검색하면 변경내용이 없음&lt;br>
이로인해 es는 near real-time search가 됨&lt;/p>
&lt;/blockquote>
&lt;h2 id="3-replica-stage">3. replica stage
&lt;/h2>&lt;ul>
&lt;li>각 in-sync replica는 로컬에서 인덱싱 작업을 수행하며 복사본을 가짐&lt;/li>
&lt;/ul>
&lt;h3 id="위의-indexing단계는-순차적으로-진행되며-내부-재시도를-가능하기-위해-lifetime을-가지고-있음">위의 indexing단계는 순차적으로 진행되며, 내부 재시도를 가능하기 위해 lifetime을 가지고 있음
&lt;/h3>&lt;p>&lt;a class="link" href="https://www.elastic.co/blog/found-elasticsearch-top-down" target="_blank" rel="noopener"
>https://www.elastic.co/blog/found-elasticsearch-top-down&lt;/a>&lt;br>
&lt;a class="link" href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up" target="_blank" rel="noopener"
>https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up&lt;/a>&lt;br>
&lt;a class="link" href="https://www.javaadvent.com/2022/12/elasticsearch-internals.html" target="_blank" rel="noopener"
>https://www.javaadvent.com/2022/12/elasticsearch-internals.html&lt;/a>&lt;br>
&lt;a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#basic-write-model" target="_blank" rel="noopener"
>https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#basic-write-model&lt;/a>&lt;br>
&lt;a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/near-real-time.html" target="_blank" rel="noopener"
>https://www.elastic.co/guide/en/elasticsearch/reference/current/near-real-time.html&lt;/a>&lt;/p></description></item><item><title>Analyzer</title><link>https://sungho94.me/p/analyzer/</link><pubDate>Sat, 22 Jun 2024 21:13:08 +0000</pubDate><guid>https://sungho94.me/p/analyzer/</guid><description>&lt;ul>
&lt;li>document의 문자열 필드가 역 인덱스의 term으로 변환되는 방식을 결정하는 알고리즘&lt;/li>
&lt;li>궁극적인 목표는 문자열을 일련의 토큰으로 변환하는것&lt;/li>
&lt;/ul>
&lt;h2 id="문자열이-token화-되는-과정">문자열이 token화 되는 과정
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240622211444.png"
loading="lazy"
alt="Analyer Pipeline"
>&lt;/p>
&lt;h3 id="1-input">1. Input
&lt;/h3>&lt;h3 id="2-characterfilter">2. CharacterFilter
&lt;/h3>&lt;ul>
&lt;li>텍스트를 소문자로 변환하거나, 단어를 대체하는 등 특정 방식으로 문자열을 변환하고, 변환된 문자열을 출력함&lt;/li>
&lt;li>문자를 추가, 제거, 또는 변경함
&lt;ul>
&lt;li>힌두-아랍 숫자(٠١٢٣٤٥٦٧٨٩)를 아랍어-라틴어(0123456789)로 변환하거나 &amp;lt;b&amp;gt;와 같은 HTML 요소를 제거할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="3-tokenizer">3. Tokenizer
&lt;/h3>&lt;ul>
&lt;li>문자열 스트림을 입력으로 받아, 개별 토큰으로 분리함&lt;/li>
&lt;li>다음을 데이터을 저장
&lt;ul>
&lt;li>각 용어의 순서 또는 위치&lt;/li>
&lt;li>용어가 나타나는 원래 단어의 시작 및 끝 문자 오프셋
&lt;ul>
&lt;li>검색 스니펫을 강조하기 위해 사용함(?)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>토큰 유형
&lt;ul>
&lt;li>ex) &lt;code>&amp;lt;ALPHANUM&amp;gt;&lt;/code>, &lt;code>&amp;lt;HANGUL&amp;gt;&lt;/code>, or &lt;code>&amp;lt;NUM&amp;gt;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="4-tokenfilter">4. TokenFilter
&lt;/h3>&lt;ul>
&lt;li>Tokenizer에서 받은 토큰을 수정(대-&amp;gt;소 문자로 변환), 삭제(stopword제거), 추가(ex) 동의어)함&lt;/li>
&lt;/ul>
&lt;h3 id="5-output">5. Output
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240622211925.png"
loading="lazy"
alt="|center"
>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.elastic.co/blog/found-text-analysis-part-1" target="_blank" rel="noopener"
>https://www.elastic.co/blog/found-text-analysis-part-1&lt;/a>&lt;br>
&lt;a class="link" href="https://www.elastic.co/blog/found-text-analysis-part-2" target="_blank" rel="noopener"
>https://www.elastic.co/blog/found-text-analysis-part-2&lt;/a>&lt;br>
&lt;a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html" target="_blank" rel="noopener"
>https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html&lt;/a>&lt;br>
&lt;a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html" target="_blank" rel="noopener"
>https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html&lt;/a>&lt;/p></description></item><item><title>ElasticSearch query and fetch</title><link>https://sungho94.me/p/elasticsearch-query-and-fetch/</link><pubDate>Tue, 18 Jun 2024 22:30:18 +0000</pubDate><guid>https://sungho94.me/p/elasticsearch-query-and-fetch/</guid><description>&lt;ul>
&lt;li>search쿼리는 도착지를 고정할 수 없고, 잠재적으로 매칭되는 index또는 indices안의 모든 샤드를 검색해야하기에 어려움&lt;/li>
&lt;li>일치하는 문서를 찾는 것 뿐만아니라, 검색 api는 결과를 사용자에게 표시하기 전에 통합되고 정리된 목록으로 결합해야함&lt;/li>
&lt;li>기본적으로, 엘라스틱서치는 Query Then Fetch라는 검색방법을 사용함&lt;/li>
&lt;/ul>
&lt;h2 id="단계">단계
&lt;/h2>&lt;h3 id="1-클라이언트가-elasticsearch로-쿼리-전송조정노드">1. 클라이언트가 Elasticsearch로 쿼리 전송(조정노드)
&lt;/h3>&lt;h3 id="2-쿼리를-각-샤드로-브로드캐스팅조정노드">2. 쿼리를 각 샤드로 브로드캐스팅(조정노드)
&lt;/h3>&lt;p>2-1. 조정노드는 패턴 또는 별칭으로 대상 인덱스 목록 작성&lt;/p>
&lt;ul>
&lt;li>단일인덱스도 될 수 있지만, logsash-*과같이 패턴일 수 있음&lt;/li>
&lt;li>실제 쿼리가 검색해야하는 인덱스 목록이 생성됨&lt;br>
2-2. 대상 인덱스의 distinct shard 목록을 작성함&lt;/li>
&lt;li>distinct shard목록은 primary shard와 replica shard의 집함임&lt;/li>
&lt;li>검색요청은 primary shard와 replica shard 둘 중 어&lt;br>
2-3. 각 인덱스의 라우팅옵션에 따라 모든 샤드로 갈지, 하나의 샤드로 갈지 결정함&lt;/li>
&lt;li>대부분의 쿼리는 모든 별개의 샤드로 가지만, 특정 라우팅으로 하나의 샤드에 모든 document가 있다는것을 보증한다면, 하나의 샤드로만 쿼리함&lt;br>
2-4. 조정노드는 관롼된 각 샤드에 대해 쿼리할 실제 샤드를 선택함&lt;/li>
&lt;li>일반적으로 무작위로 선택되지만, 최근 쿼리에서 가장 성능이 좋은 샤드를 결정하는 등 최적화가 이루어지기도 함&lt;/li>
&lt;/ul>
&lt;h3 id="3-로컬-용어빈도를-사용해-일치하는-모든-문서-찾기-및-점수계산">3. 로컬 용어/빈도를 사용해 일치하는 모든 문서 찾기 및 점수계산
&lt;/h3>&lt;ul>
&lt;li>아래의 작업이 발생함
&lt;ul>
&lt;li>ElasticSearch level에서 매핑
&lt;ul>
&lt;li>인덱스 시점의 매핑과 유사함&lt;/li>
&lt;li>쿼리 필드를 기본 Lucoene데이터 필드 및 구조에 매핑하여, 각 세그먼트(Lucene index)가 실행할 수 있는 Lucene호환 쿼리를 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Lucene에서의 분석&lt;/li>
&lt;li>Lucene에서 검색&lt;/li>
&lt;li>Lucone에서 Scoring&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>쿼리의 텍스트 부분은 동일한 analyzer를 통해 tokenzing됨
&lt;ul>
&lt;li>이로인해 쿼리 텍스트가 색인된 방식과 일치하게 됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="4-결과의-우선순위-큐-구축정렬-페이지네이션-등">4. 결과의 우선순위 큐 구축(정렬, 페이지네이션 등)
&lt;/h3>&lt;h3 id="5-조정-노드에-결과에-대한-메타데이터를-반환함">5. 조정 노드에 결과에 대한 메타데이터를 반환함
&lt;/h3>&lt;ul>
&lt;li>실제 문서가 아닌 document ID와 점수를 반환함&lt;/li>
&lt;/ul>
&lt;h3 id="6-모든-샤드의-점수가-조정-노드에서-병합-및-정렬되고-쿼리-기준에-따라-문서가-선택됨">6. 모든 샤드의 점수가 조정 노드에서 병합 및 정렬되고, 쿼리 기준에 따라 문서가 선택됨
&lt;/h3>&lt;h3 id="7-끝으로-실제-문서가-있는-개별-샤드에서-실제-문서가-검색됨">7. 끝으로, 실제 문서가 있는 개별 샤드에서 실제 문서가 검색됨
&lt;/h3>&lt;h3 id="8-결과를-클라이언트에-반환조정노드">8. 결과를 클라이언트에 반환(조정노드)
&lt;/h3>&lt;ul>
&lt;li>조정 노드는 1,2,8단계에서 사용됨&lt;/li>
&lt;/ul>
&lt;h2 id="query-phase3456">Query Phase(3,4,5,6)
&lt;/h2>&lt;ul>
&lt;li>검색 쿼리는 모든 샤드에 전성되어 로컬 실행이 시작되고, 일치하는 문서가 포함된 우선순위 대기열이 생성됨&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240618223803.png"
loading="lazy"
alt="|center"
>&lt;/p>
&lt;h2 id="fetch-phase7">Fetch Phase(7)
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>query Phase가 연관된 문서를 확인하는 반면에, Fetch phase에서는 각각의 샤드에서 실제 문서를 가져오는 역할을 담당함&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240618223931.png"
loading="lazy"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>이 분할방식은 분산된 환경에서 효과적이고 확장가능한 검색작업을 보장함&lt;/p>
&lt;ul>
&lt;li>Query phase에서는 검색 커리가 각 샤드 복사본을 탐색하여 로컬 검색을 시작하고, 일치하는 문서의 우선순위가 지정된 목록을 컴파일함
&lt;ul>
&lt;li>이 단계는 검색 결과를 구체화 하는 초기단계임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Fetch phase에서는 원하는 검색 결과를 제공함
&lt;ul>
&lt;li>이 단계는 쿼리 실행과 검색 결과 사이의 가교 역할을 하며 검색 프로세스의 철저함을 보장함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="추가-정보">추가 정보
&lt;/h2>&lt;ul>
&lt;li>Elasticsearch의 query와 fetch phases에서 slow logs를 enable하면, 검색 성능을 모니터링 및 최적화가 가능함&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-HTTp" data-lang="HTTp">&lt;span class="line">&lt;span class="cl">&lt;span class="err">PUT *,-.*/_settings
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">{
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;#34;index.search.slowlog.threshold.query.warn&amp;#34;: &amp;#34;1s&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;#34;index.search.slowlog.threshold.fetch.warn&amp;#34;: &amp;#34;100ms&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">#or with curl
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">curl -XPUT &amp;#34;http://localhost:9200/*,-.*/_settings&amp;#34; -H &amp;#34;Content-Type: application/json&amp;#34; -d&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">{
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;#34;index.search.slowlog.threshold.query.warn&amp;#34;: &amp;#34;1s&amp;#34;,
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">&amp;#34;index.search.slowlog.threshold.fetch.warn&amp;#34;: &amp;#34;100ms&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">}&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;a class="link" href="https://medium.com/@musabdogan/elasticsearchs-distributed-search-query-and-fetch-phases-df869d35f4b3" target="_blank" rel="noopener"
>https://medium.com/@musabdogan/elasticsearchs-distributed-search-query-and-fetch-phases-df869d35f4b3&lt;/a>&lt;br>
&lt;a class="link" href="https://steve-mushero.medium.com/elasticsearch-search-data-flow-2a5f799aac6a" target="_blank" rel="noopener"
>https://steve-mushero.medium.com/elasticsearch-search-data-flow-2a5f799aac6a&lt;/a>&lt;/p></description></item><item><title>ElasticSearch</title><link>https://sungho94.me/p/elasticsearch/</link><pubDate>Thu, 05 Oct 2023 23:26:11 +0000</pubDate><guid>https://sungho94.me/p/elasticsearch/</guid><description>&lt;ul>
&lt;li>분산 문서 장소&lt;/li>
&lt;li>분산 시스템으로 구성되어 대용량 데이터와 빠른 검색 가능&lt;/li>
&lt;li>역인덱스구조&lt;/li>
&lt;/ul>
&lt;h2 id="document">Document
&lt;/h2>&lt;ul>
&lt;li>엘라스틱 서치의 단일 데이터 단위&lt;/li>
&lt;li>JSON구조로 되어있음&lt;/li>
&lt;li>디폴트로 schema-less구조
&lt;ul>
&lt;li>schema를 지정 하지 않아도 됨&lt;/li>
&lt;li>schema를 지정할 수 있으며, schema를 지정했다면, 모든 document들은 schema를 따라야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>metadata
&lt;ul>
&lt;li>_index document가 저장된 index를 나타냄&lt;/li>
&lt;li>_id doucument의 id를 나타냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="node">Node
&lt;/h2>&lt;ul>
&lt;li>하나의 ElasticSearch 인스턴스&lt;/li>
&lt;li>하나이상의 Node가 모여 Cluster를 구성&lt;/li>
&lt;li>node는 여러 role을 가질 수 있음
&lt;ul>
&lt;li>master, data, data_content, data_hot, data_warm, data_cold, data_frozen, ingest, ml, remote_cluster_client, transform&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="master-node">Master node
&lt;/h3>&lt;ul>
&lt;li>인덱스의 생성 또는 삭제, 클러스터의 일부인 노드추적, 어떤 샤드를 어떤 노드를 할당할지 결정하는 등 가벼운 작업을 담당&lt;/li>
&lt;/ul>
&lt;h3 id="data-node">Data node
&lt;/h3>&lt;ul>
&lt;li>인덱싱한 문서가 포함된 샤드를 보관&lt;/li>
&lt;li>CRUD, 검색, 집계와 같은 데이터 관련 작업 처리
&lt;ul>
&lt;li>I/O, 메모리, CPU 집약적인 작업&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>hot, warm, cold 등 여러 data노드들이 있음&lt;/li>
&lt;/ul>
&lt;h2 id="index">Index
&lt;/h2>&lt;ul>
&lt;li>유사한 특성을 가진 문서들의 모음&lt;/li>
&lt;li>es에서 쿼리할 수 있는 가장 높은 수준의 엔티티&lt;/li>
&lt;/ul>
&lt;h2 id="shard">Shard
&lt;/h2>&lt;ul>
&lt;li>하나의 인덱스는 하나 이상의 shard로 분리되어 저장됨&lt;/li>
&lt;li>인덱스를 구성하는 기본단위&lt;/li>
&lt;li>Lucene의 인스턴스이며, 그 자체로 완벽한 검색엔진임&lt;/li>
&lt;li>document가 저장되어있고&lt;/li>
&lt;li>primary shard와 replica shard가 존재함
&lt;ul>
&lt;li>primary shard
&lt;ul>
&lt;li>각각의 document는 하나의 primary shard에 속함&lt;/li>
&lt;li>최대 Integer.MAX_VALUE - 128 만큼의 document를 저장할 수 있음&lt;/li>
&lt;li>update시 즉시 업데이트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>replica shard
&lt;ul>
&lt;li>primary shard의 복제본&lt;/li>
&lt;li>update시 즉시 업데이트 되지 않음&lt;/li>
&lt;li>장애 복구 시 및 검색시 사용함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>primary샤드수를 바꾸려면 reindexing해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="역인덱스inverted-index">역인덱스(inverted index)
&lt;/h2>&lt;ul>
&lt;li>해당 단어가 나타내는 문서들 간의 매핑을 제공해주는 데이터 구조&lt;/li>
&lt;li>각 단어가 어떤 문서들에 등장하는지 알려줌&lt;/li>
&lt;li>inverted index와 forward index는 방향성의 차이임&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-jsx" data-lang="jsx">&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span>&lt;span class="nx">forward&lt;/span> &lt;span class="nx">index&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">Document&lt;/span> &lt;span class="nx">Keywords&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">doc1&lt;/span> &lt;span class="nx">hello&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">sky&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">morning&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">doc2&lt;/span> &lt;span class="nx">tea&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">coffee&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">hi&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">doc3&lt;/span> &lt;span class="nx">greetings&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">sky&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-jsx" data-lang="jsx">&lt;span class="line">&lt;span class="cl">&lt;span class="err">#&lt;/span>&lt;span class="nx">inverted&lt;/span> &lt;span class="nx">index&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">Word&lt;/span> &lt;span class="nx">Documents&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">hello&lt;/span> &lt;span class="nx">doc1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">sky&lt;/span> &lt;span class="nx">doc1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">doc3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">coffee&lt;/span> &lt;span class="nx">doc2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">hi&lt;/span> &lt;span class="nx">doc2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nx">greetings&lt;/span> &lt;span class="nx">doc3&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>ex)&lt;/p>
&lt;ul>
&lt;li>hello를 찾는다?
&lt;ul>
&lt;li>forward index 구조
&lt;ul>
&lt;li>document를 순회하며 hello라는 키워드가 있는지 확인함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>inverted index 구조
&lt;ul>
&lt;li>word에서 hello를 찾고, 해당 document를 반환&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html#generic-data-node" target="_blank" rel="noopener"
>https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html#generic-data-node&lt;/a>&lt;br>
&lt;a class="link" href="https://opster.com/guides/elasticsearch/glossary/elasticsearch-document/" target="_blank" rel="noopener"
>https://opster.com/guides/elasticsearch/glossary/elasticsearch-document/&lt;/a>&lt;br>
&lt;a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/documents-indices.html" target="_blank" rel="noopener"
>https://www.elastic.co/guide/en/elasticsearch/reference/current/documents-indices.html&lt;/a>&lt;br>
&lt;a class="link" href="https://www.knowi.com/blog/what-is-elastic-search/" target="_blank" rel="noopener"
>https://www.knowi.com/blog/what-is-elastic-search/&lt;/a>&lt;/p></description></item><item><title>Elastic Search Data Tier</title><link>https://sungho94.me/p/elastic-search-data-tier/</link><pubDate>Wed, 04 Oct 2023 22:54:59 +0000</pubDate><guid>https://sungho94.me/p/elastic-search-data-tier/</guid><description>&lt;ul>
&lt;li>
&lt;p>Data Tier는 Content, Hot, Warm, Cold, Frozen 5개의 티어로 나눔&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Data Tier는 정말 사용하는 데이터(상품의 카탈로그)같은 것으로 다른 티어들과 다르게 시간의 지남에 따라 티어를 이동하지 않음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hot, Warm, Cold, Frozen는 Time series data의 관리시 매우 유용함&lt;/p>
&lt;ul>
&lt;li>특히 시계열 인덱스일때 매우 유용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>많은 경우, 자주 접하는 데이터와 자주 접하지 않는 데이터가 나누어 &lt;/p>
&lt;ul>
&lt;li>시계열일 경우 최근 데이터를 자주보고 시간이 지난 데이터를 덜 볼 것임&lt;/li>
&lt;li>ex) 로그 데이터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Hot으로 갈수록 더 최근, 자주 접근하는 데이터이고 Frozen으로 갈수로 옛날, 잘 접근하지 않는 데이터&lt;/p>
&lt;/li>
&lt;li>
&lt;p>데이터 관리 방법&lt;/p>
&lt;ul>
&lt;li>자주 접근하는 티어(ex Hot tier)는 더 좋은 장비(SSD, memory)를 두고 덜 접근하는 티어(Fozen)에는 낮은장비, 혹은 스냅샷을 이용하여 저장하고 필요시 복구하는 정도&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>티어를 나눔으로써 장비에 대한 비용을 아낄 수 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>하나의 샤드의 크기를 50GB이하로 유지할것, elastic search는 200M이상 50GB이하일때 성능이 가장 좋음&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/data-tiers.html" target="_blank" rel="noopener"
>https://www.elastic.co/guide/en/elasticsearch/reference/current/data-tiers.html&lt;/a>&lt;br>
&lt;a class="link" href="https://www.elastic.co/kr/blog/implementing-hot-warm-cold-in-elasticsearch-with-index-lifecycle-management" target="_blank" rel="noopener"
>https://www.elastic.co/kr/blog/implementing-hot-warm-cold-in-elasticsearch-with-index-lifecycle-management&lt;/a>&lt;/p></description></item></channel></rss>