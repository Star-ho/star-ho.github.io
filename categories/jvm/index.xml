<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>JVM on Sungho's Dev BLog</title><link>https://sungho94.me/categories/jvm/</link><description>Recent content in JVM on Sungho's Dev BLog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 27 Aug 2024 22:57:53 +0000</lastBuildDate><atom:link href="https://sungho94.me/categories/jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>JVM Tiered Compilation</title><link>https://sungho94.me/p/jvm-tiered-compilation/</link><pubDate>Tue, 27 Aug 2024 22:57:53 +0000</pubDate><guid>https://sungho94.me/p/jvm-tiered-compilation/</guid><description>&lt;h2 id="java-언어의-특징">Java 언어의 특징
&lt;/h2>&lt;ul>
&lt;li>Java는 컴파일 + 인터프리터 두가지 특징을 다 가지고 있음&lt;/li>
&lt;li>Java코드를 컴파일하면 .class파일(byte Code)이 되고, JVM은 .class파일을 가지고 os에 맞게 machine code로 변환함&lt;/li>
&lt;li>.class파일은 특정 실행횟수가 지나면 최적화가 됨&lt;/li>
&lt;/ul>
&lt;h2 id="tiered-compilation">Tiered Compilation
&lt;/h2>&lt;ul>
&lt;li>JVM의 JIT Compiler는 자주 실행되는 부분의 코드를 native code로 변환함&lt;/li>
&lt;li>JIT compiler에는 2개의 java byte code interpreter가 존재함
&lt;ul>
&lt;li>Client compiler
&lt;ul>
&lt;li>메소드를 빠르게 컴파일 하지만 Server compiler보다 덜 최적화된 machine code를 생성함&lt;/li>
&lt;li>빠른 시작에 사용함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Server compiler
&lt;ul>
&lt;li>동일한 메서드르 컴파일하는데 더 많은 시간이 듬&lt;/li>
&lt;li>Client compiler보다 더 많은 시간 및 메모리를 소요하지만, 더 최적화된 machine code를 생성함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Tiered Compilation은 Client compiler를 첫번째 계으로 사용하여 서버 VM시작 속도를 향상시킴&lt;/li>
&lt;li>서버 vm은 인터프리터를 사용하여 컴파일러에 공급되는 메서드에 대한 프로파일링 정보를 수집함&lt;/li>
&lt;li>Tiered Compilation에서는 인터프리터 외에도 client compiler가 자신에 대한 프로파일링 정보를 수집하는 메서드의 컴파일된 버전을 생성함&lt;/li>
&lt;li>컴파일된 코드가 인터프리터 보다 후러씬 빠르기 때문에, 이 프로파일 단계에서 프로그램이 더 뛰어난 성능으로 실행됨&lt;/li>
&lt;li>애플리케이션 초기화 된계에서 server compiler가 생성한 최종 코드를 사용할 수 있기때문에 시작이 더 빠른 경우도 종종 존재함&lt;/li>
&lt;/ul>
&lt;h2 id="tier-level">Tier level
&lt;/h2>&lt;ul>
&lt;li>서로 다른 컴파일러와 인터프리터의 결합으로 아래와 같은 5개의 최적화 수준이 생성됨&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">&lt;strong>Level&lt;/strong>&lt;/th>
&lt;th style="text-align: left">&lt;strong>Compiler&lt;/strong>&lt;/th>
&lt;th style="text-align: left">&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">0&lt;/td>
&lt;td style="text-align: left">Interpreter&lt;/td>
&lt;td style="text-align: left">JVM은 모든 자바 코드를 0 level을 사용함&lt;br>워밍업 단계가 끝나면 JIT 컴파일러가 시작되어 런타임에 코드를 최적화함&lt;br>JIT 컴파일러는 0 level에서 수집한 프로파일링 정보로 최적화 수행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">1&lt;/td>
&lt;td style="text-align: left">C1 without profiling&lt;/td>
&lt;td style="text-align: left">C1컴파일러를 사용하여 코드를 컴파일하지만, 프로파일 정보는 수집하지 않음&lt;br>사소한 것으로 간주되는 메서드(ex. getter)에 대해 level1 컴파일을 수행함&lt;br>메서드 복잡성이 낮아 C2컴파일하지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">2&lt;/td>
&lt;td style="text-align: left">C1 with basic profiling&lt;/td>
&lt;td style="text-align: left">JVM은 라이트 프로파일링이 포함된 C1컴파일러를 사용하여 컴파일함&lt;br>C2큐가 가득차면 level2를 사용함&lt;br>목표는 성능개선을 위해 가능한 빠르게 코드를 컴파일 하는것&lt;br>나중에 JVM은 전체 프로파일링을 사용하여 level3으로 코드를 다시 컴파일함&lt;br>마지막으로, C2 대기열이 짧아지면, JVM은 level4에서 코드를 다시 컴파일함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">3&lt;/td>
&lt;td style="text-align: left">C1 with full profiling&lt;/td>
&lt;td style="text-align: left">JVM은 전체 프로파일링이 포함된 C1컴파일러를 사용하여 코드를 컴파일함&lt;br>level3은 기본 compilation path임&lt;br>JVM은 사소한 메서드와 컴파일러 대기열이 가득찬 경우를 제외한 모든 경우에 사용함&lt;br>JIT컴파일러에서 가장 일반적인 시나리오는 해석된 코드가 레벨 0에서 레벨3으로 바로 점프하는 것임&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">4&lt;/td>
&lt;td style="text-align: left">C2 full optimizing, no profiling&lt;/td>
&lt;td style="text-align: left">장기적인 성능을 극대화 하기 위해 JVM이 C2컴파일러를 사용하여 코드를 컴파일함&lt;br>level 4는 기본 compilation path임&lt;br>JVM은 사소한 메서드를 제외한 모든 메서드를 level4로 컴파일함&lt;br>level4코드는 완전히 최적화된 것으로 간주되므로 프로파일링 정보 수집을 중단함&lt;br>그럼에도, 코드 최적화를 해제하고 레벨 0으로 돌려보낼 수 있음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>일반적으로 메서드는 interperter안에서 생성되며 메서드가 실행되는동안 계측을 통해 메서드의 프로파일이 수집됨&lt;/li>
&lt;li>수집된 프로파일은 휴리스틱에 의해 사용되며 컴파일될지, 다시 다른 수준에서 컴파일 될지, 어떤 최적화를 수행할지 절정함&lt;/li>
&lt;li>메서드를 실행하는 동안 HotSpot이 수집하는 가장 기본적인 두 가지 정보는 메서드가 실행된 횟수와 메서드의 루프가 반복된 휫수임&lt;/li>
&lt;li>이 정보는 컴파일 정책에서 메서드를 컴파일 할지 여부와 컴파일 수준을 결정하는데 사용됨&lt;/li>
&lt;li>컴파일 정책에서는 현재 compile중인 메서드에 대해 컴파일 요청을 레벨 3에서 설정하기 위해 공식을 사용함
&lt;ul>
&lt;li>현재 3레벨 컴파일로 실행중인 메서드를 레벨 4로 컴파일 하기 위한 요청을 생성할지 여부를 결정하는 데도 동일한 공식이 사용됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">(Executions &amp;gt; TierXInvocationThreshold * Scale)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(Executions &amp;gt; TierXMinInvocationThreshold * Scale AND Executions + Iterations &amp;gt; TierXCompileThreshold * Scale)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>TierXInvocationThreshold&lt;/p>
&lt;ul>
&lt;li>호출 수가 이 임계값을 초과하는 경우, 메서드를 레벨X로 컴파일함&lt;/li>
&lt;li>기본값은 레벨 3의 경우 200, 레벨 4의 경우 5000&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>TierXMinInvocationThreshold&lt;/p>
&lt;ul>
&lt;li>메서드를 레벨 X에서 컴파일하는데 필요한 최소 실행 횟수&lt;/li>
&lt;li>기본값은 레벨 3의 경우 100, 레벨 4의 경우 600&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>TierXCompileThreshold&lt;/p>
&lt;ul>
&lt;li>메서드와 해당 루프의 반복 횟수가 이 임계값보다 . 더많이 실행된 경우 메서드를 레벨 X에서 컴파일함&lt;/li>
&lt;li>기본값은 레벨 3의 경우 2000, 레벨 4의 경우 15000&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Executions&lt;/p>
&lt;ul>
&lt;li>메서드가 실행된 횟수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Iterations&lt;/p>
&lt;ul>
&lt;li>메서드 내부의 루프가 실행된 누적 반복 횟수&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Scale&lt;/p>
&lt;ul>
&lt;li>컴파일 대기열 부하를 안정적으로 유지하기 위한 Scale 계수&lt;/li>
&lt;li>컴파일 대기열 함목 수와 컴파일러 스레드 수에 따라 주기적으로 동적으로 조정됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>HoptSpot은 컴파일이 다른 부분에 미치는 영향과 시스템이 현재 처리하고 있는 부하량도 고려함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>메서드를 해석중이고 위의 공식이 충족되어 레벨 3에서 메서드를 컴파일한다고 가정하면 컴파일 정책이 실제로 레3이 아닌 레벨2에서 컴파일 하기로 결정할 수 있음&lt;/p>
&lt;ul>
&lt;li>C2 대기열의 길이
&lt;ul>
&lt;li>일반적으로 레벨 3에서 컴파일된 메서드는 레벨2에서 컴파일된 동일한 메서드보다 느리기 때문에 메서드가 레벨3에서 보내는 시간을 최소화 하는 것이 좋음&lt;/li>
&lt;li>적절한 프로파일리을 수집하여 필요한 시간만 레벨 3에서 소비해야함&lt;/li>
&lt;li>따라서 C2대기열이 너무 길어, 레벨 3로 전환되는게 너무 오래걸린다면 우선 레벨 2로 이동하는 것이 유리함
&lt;ul>
&lt;li>추후 C2대기열이 줄어든다면 레벨 3에서 메서드를 다시 컴파일함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>C1대기열 길이는 임계값을 동적으로 조정하고, 컴파일러가 과부하 될때 추가 필터링을 도입하는데 사용됨
&lt;ul>
&lt;li>컴파일러 대기열이 너무 길면 컴파일이 완료될 때 까지 메서드가 더이상 실행되지 않을 수 있기 때문&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>레벨 3에서 컴파일된 메서드가 레벨 4로 전환하기 위한 공식을 충족할 만큼 충분하 실행되면, 해당 레벨에서 메서드를 다시 컴파일 하라는 요청이 생성됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>이 level에서는 HotSpot은 장기적인 성능을 극대화 하기 위해 C2 컴파일러를 사용하여 코드를 컴파일함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>레벨 4코드는 완전히 최적화된 것으로 간주되므로 JVM은 프로파일링 정보 수집을 중단함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>위 설명은 컴파일 정책의 단순화된 버전임, 메서드를 컴파일하거나 다시 컴파일할지 결정할 때 HotSpot이 고려하는 몇가지 다른 사항과 JVM 사용자가 정책을 정의하는데 사용할 수 있는 몇개의 플래그가 있음&lt;/p>
&lt;ul>
&lt;li>아래는 최적화와 연관된 이야기임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>C2는 메소드의 동적 프로파일에 대한 정보를 사용하여 몇가지 최적화를 안내함&lt;/p>
&lt;ul>
&lt;li>Inlining, Class Hierarchy Analysis(CHA), basic block ordering, some loop optimizations&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>프로파일이 &lt;code>if-else&lt;/code>문이 과거에 &lt;code>then&lt;/code>부분만 실행했음을 보여줄 떄,&lt;/p>
&lt;ul>
&lt;li>C2는 앞으로도 계속 이런 일이 발생할 것이라 가정하고, &lt;code>else&lt;/code>블록은 전혀 컴파일 하지 않기로 결정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>프로파일이 참조 변수가 절대 null이 아니라고 보여줄 때,&lt;/p>
&lt;ul>
&lt;li>C2는 향후 실행에서 변수가 계속 null이 아닐것이라고 가정하고, 그 가정을 사용하여 코드를 최적화 할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>프로필이 루프가 일반적으로 수천번 반복된다고 보여줄 때,&lt;/p>
&lt;ul>
&lt;li>C2는 해당 정보를 기반으로 루프를 unrolling 또는 벡터화 할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>프로파일이 클래스에 서브클래스가 없음을 보여줄 때,&lt;/p>
&lt;ul>
&lt;li>C2는 해당 클래스의 객체를 사용하여 메서드 호출에서 인라인 또는 다른 종류의 최적하를 수행하기로 결정할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>메서드의 프로파일은 동적 문제가 있음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>애플리케이션이 실행동항 메서드의 프로파일이 안정적일것이라는 보장은 없음&lt;/p>
&lt;ul>
&lt;li>프로그램 실행 중 대부분 참이었던 &lt;code>if-else&lt;/code>조건이 갑자기 거짓을 반환함&lt;/li>
&lt;li>트리거 되지 않었던 예외가 트리거됨&lt;/li>
&lt;li>한번도 null이 아니었던 참조변수가 null로 표시됨&lt;/li>
&lt;li>시스템에 새클래스가 로드되고, 이전에는 단순했던 클래스 계층구조가 더 복잡해짐&lt;/li>
&lt;li>일반적으로 수천번 반복되는 루프가 이제는 몇번만 반복함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>이러한 동적 동작을 고려하기 위해, C2는 컴파일된 코드에 predicates를 삽입하여 프로파일 정보를 기반으로 한 가정이 예전이 유효한지 확인함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>predicate가 false인 경우, 트랩(JVM 내부에 대한 호출)이 실행되어 어떤 가정이 거짓인지 HotSpot에 알림&lt;/p>
&lt;/li>
&lt;li>
&lt;p>트랩이 제공한 정보를 바탕으로 HotSpot은 수행해야 할 작업을 결정함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>현재 컴파일된 메서드를 다시 컴파일할 수 있고, 실행을 인터프리터로 전환해야 할 수도 &lt;a class="link" href="https://github.com/openjdk/jdk/blob/8eed7dea7b92dd98b74277e8521100f7f807eabb/src/hotspot/share/runtime/deoptimization.hpp#L69" target="_blank" rel="noopener"
>https://github.com/openjdk/jdk/blob/8eed7dea7b92dd98b74277e8521100f7f807eabb/src/hotspot/share/runtime/deoptimization.hpp#L69&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>트랩이 실행될 수 있는 가능한 이유 목록 &lt;a class="link" href="" >링크&lt;/a>&lt;/p>
&lt;ul>
&lt;li>필요한 조치목록&lt;a class="link" href="https://github.com/openjdk/jdk/blob/8eed7dea7b92dd98b74277e8521100f7f807eabb/src/hotspot/share/runtime/deoptimization.hpp#L144" target="_blank" rel="noopener"
>링크&lt;/a>&lt;br>
&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240905231051.png"
loading="lazy"
alt="center"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="compile-관련-옵션">Compile 관련 옵션
&lt;/h2>&lt;blockquote>
&lt;p>default로 TieredCompilation은 활성화 되어있음&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>-Xcomp&lt;/p>
&lt;ul>
&lt;li>메서드를 컴파일만 하도록 설정&lt;/li>
&lt;li>HotSpot은 인터프리터를 사용하지 않으며 메서드는 항상 컴파일됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>-Xint&lt;/p>
&lt;ul>
&lt;li>메서드를 인터프리터만 사용하도록 수정&lt;/li>
&lt;li>모든 JIT컴파일러가 비활성화되고 HotSpot이 프로그램을 실행하는 유일한 수단은 interpretation임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>-XX:TieredStopAtLevel&lt;/p>
&lt;ul>
&lt;li>최대 컴파일 수준을 설정하는데 사용함&lt;/li>
&lt;li>일부 C2버그를 우회하거나 C1을 스트레스 테스트 하기 위해 C1컴파일러만 사용하도록 강제하는것&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>-XX:-TieredCompilation&lt;/p>
&lt;ul>
&lt;li>HotSpot이 Tiered Compilation heuristics을 사용하여 컴파일간 전환하지 않고, 다른 heuristics을 사용하여 모든 컴파일에 대해 C1과 C2를 선택하게함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>XX:InitialCodeCacheSize=N&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;ul>
&lt;li>XX:ReservedCodeCacheSize=N`&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>-XX:NonNMethodCodeHeapSize&lt;/p>
&lt;ul>
&lt;li>non-method segment 영역을 지정&lt;/li>
&lt;li>JVM내부 관련코드(default 대략 5MB)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>-XX:ProfiledCodeHeapSize&lt;/p>
&lt;ul>
&lt;li>profiled-Code segment 영역 지정&lt;/li>
&lt;li>C1으로 컴파일된, 잠재적으로 짧은 수명을 가진 영역(default 대략 122MB)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>-XX:NonProfiledCodeHeapSize&lt;/p>
&lt;ul>
&lt;li>non-profiled-code segment 영역 지정&lt;/li>
&lt;li>C2로 컴파일된, 잠재적으로 긴 수명을 가진 영역(default 대략 122MB)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>-XX:Tier4CompileThreshold&lt;/p>
&lt;ul>
&lt;li>Tier4로 컴파일 하는 Threshold를 지정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>-XX:+PrintCompilation&lt;/p>
&lt;ul>
&lt;li>default로, JIT compilation log는 disable되어 있음&lt;/li>
&lt;li>위 옵션으로 JIT compilation log를 활성화 할 수 있음&lt;/li>
&lt;li>아래의 포맷을 가짐
&lt;ul>
&lt;li>Timestamp
&lt;ul>
&lt;li>애플리케이션 시작 . 후밀리초 단위&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Compile ID
&lt;ul>
&lt;li>컴파일되 각 메소드의 increment ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Attribute
&lt;ul>
&lt;li>5가지 값의 상태를 가짐
&lt;ul>
&lt;li>% - 온스택 교체 발생&lt;/li>
&lt;li>s - 메소드가 동기화됨&lt;/li>
&lt;li>! - 메소드가 exception handler를 포함하고 있음&lt;/li>
&lt;li>b - blocking모드에서 컴파일이 발생&lt;/li>
&lt;li>n - 컴파일이 래퍼를 네이티브 메서드로 변환함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Compilation level
&lt;ul>
&lt;li>0에서 4사이 값을 가짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Method name&lt;/li>
&lt;li>Bytecode size&lt;/li>
&lt;li>Deoptimisation indicator
&lt;ul>
&lt;li>Made not entrant
&lt;ul>
&lt;li>표준 C1 최적화 또는 컴파일러의 낙관적 가정이 잘못된것으로 이증되을때&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Made zombie
&lt;ul>
&lt;li>코드캐시에서 공간을 확보하기 위해 gc의 정리 메커니즘&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>아래는 AMD Ryzen 7 1800X machine running Ubuntu 20.04에서 java-17.07으로 HelloWorld 프로그램을 실행한 결과임&lt;/p>
&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">Flags&lt;/th>
&lt;th style="text-align: left">Average Wall Time&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">&amp;ldquo;Default&amp;rdquo;&lt;/td>
&lt;td style="text-align: left">0.020s&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">-Xint&lt;/td>
&lt;td style="text-align: left">0.020s&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">-Xcomp&lt;/td>
&lt;td style="text-align: left">0.890s&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>-Xcomp로 실행한것이 현저하게 느린것을 확인할 수 있는데, 이는 많은 메서드가 컴파일 비용을 상쇄할만큼 충분히 실행하지 않았기 때문&lt;/li>
&lt;li>인터프리터만 사용하도록 JVM을 구성하면, 사용자 지정을 하지 않았을때와 같은데, 이는 예제가 오래 실행되는 메서드가 없기에, 인터프리터가 최선의 선택이기 때문임&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.baeldung.com/jvm-tiered-compilation" target="_blank" rel="noopener"
>https://www.baeldung.com/jvm-tiered-compilation&lt;/a>&lt;br>
&lt;a class="link" href="https://docs.oracle.com/en/java/javase/11/jrockit-hotspot/compilation-optimization.html#GUID-8033B236-F6E5-473B-BB9F-34422143A1AA" target="_blank" rel="noopener"
>https://docs.oracle.com/en/java/javase/11/jrockit-hotspot/compilation-optimization.html#GUID-8033B236-F6E5-473B-BB9F-34422143A1AA&lt;/a>&lt;br>
&lt;a class="link" href="https://devblogs.microsoft.com/java/how-tiered-compilation-works-in-openjdk/" target="_blank" rel="noopener"
>https://devblogs.microsoft.com/java/how-tiered-compilation-works-in-openjdk/&lt;/a>&lt;/p></description></item><item><title>5-ExecutorService &amp; CountDownLatch</title><link>https://sungho94.me/p/5-executorservice-countdownlatch/</link><pubDate>Fri, 05 Apr 2024 17:25:00 +0000</pubDate><guid>https://sungho94.me/p/5-executorservice-countdownlatch/</guid><description>&lt;h1 id="executorservice">ExecutorService
&lt;/h1>&lt;ul>
&lt;li>비동기 작업을 할때 쓰레드관리가 복잡한 과정임
&lt;ul>
&lt;li>ExecutorService가 복잡한 쓰레드관리를 단순화 시켜줌&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하나이상의 비동기 작업을 과정을 추적하기 위한 Future를 생성하는 메서드와 종료관리 메서드를 제공&lt;/li>
&lt;li>Excutor를 상속받았기에 execute메서드와 ExecutorService자체에서 제공하는 submit 메서드, shutdown, shutdownNow, awaitTermination등의 메서드가 있음&lt;/li>
&lt;/ul>
&lt;h2 id="method">Method
&lt;/h2>&lt;h3 id="executerunnable-command">execute(Runnable command)
&lt;/h3>&lt;ul>
&lt;li>Runnable한 인자를 받아 미래에 실행시킴&lt;/li>
&lt;li>void를 리턴함&lt;/li>
&lt;/ul>
&lt;h3 id="submitrunnable-command">submit(Runnable command)
&lt;/h3>&lt;ul>
&lt;li>execute와 마찬가지고러 Runnable한 인자와 Callable한 인자를 받아 미래에 실행시킴&lt;/li>
&lt;li>인자의 수행 결과를 Future로 감싸서 리턴함&lt;/li>
&lt;/ul>
&lt;h3 id="awaitterminationlong-timeout-timeunit-unit">awaitTermination(long timeout, TimeUnit unit)
&lt;/h3>&lt;ul>
&lt;li>시간을 인자로 받으며, 모든 작업이 끝나거나, 시간 초과되거나, 인터럽트가 발생할때까지 쓰레드를 block시킴&lt;/li>
&lt;/ul>
&lt;h3 id="shutdown">shutdown()
&lt;/h3>&lt;ul>
&lt;li>이전에 제출된 작업은 유지하지만, 새로운 작업은 받지않음&lt;/li>
&lt;li>제출된 작업이 완료되면 종료함&lt;/li>
&lt;/ul>
&lt;h3 id="shutdownnow">shutdownNow()
&lt;/h3>&lt;ul>
&lt;li>실행중인 작업과 대기중인 작업 모두 중지하고, 실행 대기중인 작업을 반환함&lt;/li>
&lt;/ul>
&lt;h1 id="countdownlatch">CountDownlatch
&lt;/h1>&lt;ul>
&lt;li>하나 이상의 스레드가 다른 쓰레드의 작업이 완료될때 까지 기다려주는 보조 동기화 장치&lt;/li>
&lt;li>생성자로 count를 받으며, count가 0이 되면 await를 즉시 리턴함&lt;/li>
&lt;/ul>
&lt;h2 id="메서드">메서드
&lt;/h2>&lt;h3 id="countdownlatchintcount">CountDownLatch(int count)
&lt;/h3>&lt;ul>
&lt;li>생성자로 count를 받고, await를 호출하면 해당 count가 0이 될때까지 스레드를 wait함&lt;/li>
&lt;/ul>
&lt;h3 id="countdown">countDown()
&lt;/h3>&lt;ul>
&lt;li>count를 1감소시킴, 0이되면 await중인 스레드의 release함&lt;/li>
&lt;/ul>
&lt;h3 id="getcount">getCount()
&lt;/h3>&lt;ul>
&lt;li>현재 count를 가져옴&lt;/li>
&lt;/ul>
&lt;h3 id="await">await()
&lt;/h3>&lt;ul>
&lt;li>스레드가 인터럽트 되지 않는 한, count가 0이 될때까지 현재 쓰레드를 wait함&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html" target="_blank" rel="noopener"
>https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html&lt;/a>&lt;br>
&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_blank" rel="noopener"
>https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&lt;/a>&lt;/p></description></item><item><title>4-Volitile</title><link>https://sungho94.me/p/4-volitile/</link><pubDate>Thu, 04 Apr 2024 23:11:59 +0000</pubDate><guid>https://sungho94.me/p/4-volitile/</guid><description>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">repeat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">worker&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">VolatileWorker&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// worker 쓰레드 생성
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">worker&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">start&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// worker 쓰레드 시작
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nc">Thread&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">sleep&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">100&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 메인 쓰레드 잠시 수면
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;stop을 true로 변경&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">worker&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">stop&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">true&lt;/span> &lt;span class="c1">// worker쓰레드의 stop 플래그 변경
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">worker&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="c1">// worker 쓰레드가 끝날 때까지 메인쓰레드에서 대기
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;작업 종료&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">VolatileWorker&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Volatile&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">var&lt;/span> &lt;span class="py">stop&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">super&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(!&lt;/span>&lt;span class="n">stop&lt;/span>&lt;span class="p">){&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Worker&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">Thread&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">var&lt;/span> &lt;span class="py">stop&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">false&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">override&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">super&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(!&lt;/span>&lt;span class="n">stop&lt;/span>&lt;span class="p">){&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>현재 실행되고 있는 프로그램의 변수의 값을 읽기 위해서는 main메모리 혹은 cpu캐시에서 데이터를 읽어오게 된다&lt;/li>
&lt;li>cpu캐시에 데이터가 있을 경우, main메모리가 아닌, cpu캐시에서 읽어오는 것이 더 효율적이기에 cpu캐시에서 데이터를 읽어온다&lt;/li>
&lt;li>하지만 cpu캐시에서 계속 데이터를 읽어올경우, 다른 쓰레드에서 변경한 데이터를 읽지 않아 변경을 확인하지 못하는 문제가 발생할 수 있다&lt;/li>
&lt;li>이때 변수에 @Volatile을 사용하면 해당 변수는 항상 main메모리에서만 데이터를 읽고 쓰기에 최신의 데이터에 대한 동작을 보장받을 수 있다&lt;/li>
&lt;li>항상 main메모리에서 데이터를 읽어오기에 성능 저하가 발생한다&lt;/li>
&lt;/ul>
&lt;h3 id="volatile을-사용하지-않았을때">Volatile을 사용하지 않았을때
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240226231655.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;h3 id="volatile을-사용할-때">Volatile을 사용할 때
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240226231714.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;p>&lt;a class="link" href="https://nesoy.github.io/articles/2018-06/Java-volatile" target="_blank" rel="noopener"
>https://nesoy.github.io/articles/2018-06/Java-volatile&lt;/a>&lt;br>
&lt;a class="link" href="https://jenkov.com/tutorials/java-concurrency/volatile.html" target="_blank" rel="noopener"
>https://jenkov.com/tutorials/java-concurrency/volatile.html&lt;/a>&lt;/p></description></item><item><title>2-Semaphore</title><link>https://sungho94.me/p/2-semaphore/</link><pubDate>Wed, 03 Apr 2024 23:37:49 +0000</pubDate><guid>https://sungho94.me/p/2-semaphore/</guid><description>&lt;ul>
&lt;li>
&lt;p>허가증을 유지함으로서 동시성을 제어&lt;/p>
&lt;/li>
&lt;li>
&lt;p>acquire()메서드는 허가증이 사용가능할때까지 block하고 사용가능할때 허가증을 가짐&lt;/p>
&lt;/li>
&lt;li>
&lt;p>release는 허가증을 추가하고, 잠재적으로 blocking되어있는 acquirer를 해제함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>실제로 퍼미션 객체는 사용되지 않으며, 세마포어는 사용가능한 개수를 카운팅할 뿐임&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Semaphore는 자원에 대해 접근할수 있는 쓰레드의 수를 제한하는데 사용함&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">Pool&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">static&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MAX_AVAILABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">100&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">final&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Semaphore&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">available&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Semaphore&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MAX_AVAILABLE&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getItem&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">throws&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">InterruptedException&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">available&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">acquire&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">getNextAvailableItem&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">putItem&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">markAsUnused&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">available&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">release&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// Not a particularly efficient data structure; just for demo&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">...&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">whatever&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">kinds&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">of&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">being&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">managed&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">boolean&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">used&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">boolean&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">MAX_AVAILABLE&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">getNextAvailableItem&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MAX_AVAILABLE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">used&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">used&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// not reached&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">protected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">boolean&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">markAsUnused&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MAX_AVAILABLE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">items&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">used&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">used&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">else&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>ReentrantLock과 유사하게 lock을 얻어 자원을 확보한 이후에 작업을 진행함&lt;/li>
&lt;li>허가증을 1개만 사용하여 metex처럼 사용 가능&lt;/li>
&lt;li>reentrantLock과 같이 공정성 여부를 파라미터로 받아 공정성 여부를 결정함&lt;/li>
&lt;/ul>
&lt;h2 id="vs-reentrantlock">vs ReentrantLock
&lt;/h2>&lt;ul>
&lt;li>ReentrantLock은 1개의 자원에 대해 1개의 쓰레드만 접근이 가능함&lt;/li>
&lt;li>Semaphore는 1개의 자원에 대해 n개의 쓰레드 접근이 가능함&lt;/li>
&lt;li>ReentrantLock은 하나의 자원에 대해 여러번 시도하여 재진입이 가능함
&lt;ul>
&lt;li>재진입한 횟수만큼 자원 해제를 해야함&lt;/li>
&lt;li>Semaphore에서는 지원하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>1-ReentrantLock &amp; Condition</title><link>https://sungho94.me/p/1-reentrantlock-condition/</link><pubDate>Tue, 02 Apr 2024 18:05:04 +0000</pubDate><guid>https://sungho94.me/p/1-reentrantlock-condition/</guid><description>&lt;h1 id="reentrantlock">ReentrantLock
&lt;/h1>&lt;ul>
&lt;li>Lock 인터페이스의 구현체&lt;/li>
&lt;li>synchronized method, statements와 기본적인 동작과 의미가 동일하지만 확장된 기능을 가짐&lt;/li>
&lt;li>synchronized 키워드를 사용할때보다 더 유연하게 사용가능&lt;/li>
&lt;li>lock을 얻은후 다시 Lock을 얻을 수 있음
&lt;ul>
&lt;li>hold count를 증가시키고, hold count가 0이 되면 자원을 release함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="fair">Fair
&lt;/h2>&lt;ul>
&lt;li>생정자에서 fair변수의 값을 받음&lt;/li>
&lt;li>fair가 true라면 잠금을 가장 오래 기다린 쓰레드에 엑세스 권한부여&lt;/li>
&lt;li>false라면 특정 엑세스 순서를 보장하지 않음&lt;/li>
&lt;li>fair가 true인 경우가 전체처리량이 낮을 수 있지만, lock을 얻는 편차가 적고, lock starvartion이 덜 발생함&lt;/li>
&lt;li>fair가 true라도 쓰레드 스케줄링이 공정하지 않을 수 있음
&lt;ul>
&lt;li>쓰레드 A,B,C가 lock을 대기하고 순서도 A,B,C순일때, A가 lock을 점유하고 해제한뒤 A가 다시 lock 요청시 B와 C가 사용한 가 아닌, A가 다시 사용하는 현상&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>tryLock 메소드는 fair필드의 여부와는 상관없음&lt;/li>
&lt;li>tryLock을 사용한다면, 다른 쓰레드가 대기중이더라도 lock을 점유할 수 있음&lt;/li>
&lt;/ul>
&lt;h2 id="method">Method
&lt;/h2>&lt;h3 id="lock">lock()
&lt;/h3>&lt;ul>
&lt;li>lock을 점유함&lt;/li>
&lt;li>다른 스레드에서 lock을 점유하고 있지 않다면 lock을 점유하고 즉시 return함&lt;/li>
&lt;li>현재 스레드에서 점유하고 있었다면, hold count를 1 증가시키고 즉시 return함&lt;/li>
&lt;li>다른 스레드에서 점유중이라면 현재 스레드는 사용불가능하고 lock을 얻을 수 있을때 까지 대기함
&lt;ul>
&lt;li>lock을 얻는다면 hold count를 1로 세팅함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="unlock">unLock()
&lt;/h3>&lt;ul>
&lt;li>lock을 헤제함&lt;/li>
&lt;li>현재 스레드가 lock을 점유하고 있다면 hold count를 1 감소시킴
&lt;ul>
&lt;li>hold count가 0이 된다면 락을 해제함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>현재 스레드가 lock을 점유하고 있지 않다면 illegalMonitorStateException 예외를 발생시킴&lt;/li>
&lt;/ul>
&lt;h3 id="trylock">tryLock()
&lt;/h3>&lt;ul>
&lt;li>다른 스레드에서 lock을 점유하지 않다면, 락을 점유하고 true를 리턴하고 hold count를 1로 세팅함
&lt;ul>
&lt;li>심지어 해당 ReentrantLock객체가 fair하게 동작하고 있고, 다른 스레드에서 lock을 대기하고 있는 상태라도 해당 lock을 점유할 수 있는 상태라면 lock을 점유함&lt;/li>
&lt;li>만약 공정성을 해치고 싶지 않다면 tryLock(0,TimeUnit.SECONDS)로 호출하면 공정성을 해치지 않을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해당 스레드가 Lock을 이미 점유하고 있다면 true를 리턴하고 hold count를 1 증가시킴&lt;/li>
&lt;li>다른 스레드에 의해 이미 lock이 점유되어 있다면 즉시 false를 리턴함&lt;/li>
&lt;/ul>
&lt;h3 id="기타">기타
&lt;/h3>&lt;ul>
&lt;li>hasQueuedThreads() : 해당 락을 점유하기 위해 대기하고 있는 쓰레드의 존재여부를 알려줌&lt;/li>
&lt;li>hasQueuedThread(Thread thread) : 주어진 쓰레드가 락을 점유하기 위해 대기중인지 여부를 알려줌&lt;/li>
&lt;li>getQueueLength() : 락 점유 대기중인 스레드 수를 알려줌&lt;/li>
&lt;li>getQueuedThreads() : 락 점유 대기중인 스레드 Collection을 리턴&lt;/li>
&lt;/ul>
&lt;h2 id="condition">Condition
&lt;/h2>&lt;ul>
&lt;li>Lock이 synchronized를 대체하듯 Condition은 Object를 대체함&lt;/li>
&lt;li>Lock.newCondition 메서드로 생성가능&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">synchronized&lt;/th>
&lt;th style="text-align: center">lock&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">wait&lt;/td>
&lt;td style="text-align: center">await&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">notify&lt;/td>
&lt;td style="text-align: center">signal&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">notifyAll&lt;/td>
&lt;td style="text-align: center">signalAll&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>javadoc&lt;br>
&lt;a class="link" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html" target="_blank" rel="noopener"
>https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html&lt;/a>&lt;/p></description></item><item><title>0-Lock 정의 &amp; synchronized</title><link>https://sungho94.me/p/0-lock-%EC%A0%95%EC%9D%98-synchronized/</link><pubDate>Mon, 01 Apr 2024 22:38:42 +0000</pubDate><guid>https://sungho94.me/p/0-lock-%EC%A0%95%EC%9D%98-synchronized/</guid><description>&lt;h1 id="사용하는-이유">사용하는 이유
&lt;/h1>&lt;h3 id="쓰레드-동기화">쓰레드 동기화
&lt;/h3>&lt;ul>
&lt;li>멀티 쓰레드 환경에서 서로 다른 스레드가 하나의 자원을 공유해서 사용할때, 자원을 동시에 사용하면 예상치 않은 동작이 발생
&lt;ul>
&lt;li>쓰레드 간섭(Thread Interference), 메모리 일관성 오류(Memory consistency Error)&lt;/li>
&lt;li>ex) 두개의 쓰레드가 하나의 변수에 10을 증가시키려할때, 20이 증가되지 않고 10이 증가되는 문제&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위와 같은 방법을 해결하기 위해 쓰레드를 동기화 하여 하나의 자원을 동시에 사용하지 못하는 방법&lt;/li>
&lt;/ul>
&lt;h1 id="종류-및-사용방법">종류 및 사용방법
&lt;/h1>&lt;h2 id="synchronized">Synchronized
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>synchronized는 내재적 잠금(Intrinsic Lock) 또는 모니터 잠금(Monitor Lock)으로 알려진 내부 앤티티 중심으로 구현됨&lt;/p>
&lt;ul>
&lt;li>내재적 잠금은 동기화의 두가지 측면을 구현함
&lt;ul>
&lt;li>객체의 상태에 대한 배타적 엑세스를 강제함&lt;/li>
&lt;li>가시성에 필수적인 happens-before relationships(발생 전 관계)를 설정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>java의 모든 Object은 내재적 잠금을 가지고 있음&lt;/p>
&lt;ul>
&lt;li>header에 들어가있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>객체의 필드에 독점적이고 일관된 엑세스를 필요로 하는 쓰레드는, 객체를 접근하기전객체의 내재적 잠금을 얻어야함&lt;/p>
&lt;ul>
&lt;li>그리고 작업이 끝나면 내재적 잠금을 해제(release)해야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>쓰레드는 잠금을 획득한 시점부터 해제할때까지 내재적 잠금을 소유해야함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>한 스레드가 내재적 잠금을 소유하고 있으면, 다른 쓰레드는 같은 lock을 소유할 수 없음&lt;/p>
&lt;ul>
&lt;li>다른 쓰레드가 잠금을 획득하려하면 block됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>스레드가 내재적 잠금을 해제하면, 해당 작업과 이후 동일한 잠금을 획득하는 모든 작업간에 선후(happens-before) 관계가 설정됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>java에서는 synchronized method와 synchronized statment를 제공함&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="synchronized-method">synchronized method
&lt;/h3>&lt;ul>
&lt;li>스레드가 synchronized 메서드를 호출하면, 해당 메서드의 객체에 대한 내재 잠금을 자동으로 획득하고 메서드가 반환될때 잠금을 해제
&lt;ul>
&lt;li>반환이 잡히지 않은 예외로 인해 발생한 경우에도 잠금이 해제됨&lt;/li>
&lt;li>잠금이 객체단위에 적용되므로 increment뿐만 아닌 increment와 decrement도 동시에 동작하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>정적 synchronized 메서드가 호출되면 객체가 아닌 클래스에 대한 내재 잠금을 획득&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">SynchronizedCounter&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">var&lt;/span> &lt;span class="py">c&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Synchronized&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">increment&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span>&lt;span class="o">++&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Synchronized&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">decrement&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c&lt;/span>&lt;span class="o">--&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nd">@Synchronized&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">value&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">c&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>synchronized 메소드를 사용하면 아래 2가지 효과를 얻을 수 있음
&lt;ul>
&lt;li>동일한 객체에 대해 synchronized 메서드 호출이 동시에 발생되지 않음
&lt;ul>
&lt;li>한 스레드가 객체에 대해 synchronized 메서드를 실행하면, 첫번째 쓰레드가 작업을 완료할때까지 동기화된 메서드를 호출하는 다른 모든 쓰레드가 block됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>synchronized된 메서드가 종료되면, 동일한 객체에 대한 synchronized 메서드의 후속 호출과 함께 happends-before 관계가 설립됨
&lt;ul>
&lt;li>이로인해 모든 스레드에서 해당 객체 변경사항을 확인할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>생성자 메소드에는 synchronized를 호출할 수 없음&lt;/li>
&lt;/ul>
&lt;h3 id="synchronized-statements">Synchronized statements
&lt;/h3>&lt;ul>
&lt;li>synchronized method와 다르게 명시적으로 객체를 정의해야함&lt;/li>
&lt;li>명시적의로 정의한 객체의 잠금을 획득하고 반환할때 잠금을 해제함&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">addName&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">lastName&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">nameCount&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">nameList&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">add&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>위의 예시에서는 lastName과 nameCount에는 동기화가 필요하지만, nameList에는 동기화가 필요하지 않은 경우이다&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Synchronized statements가 없다면 nameList.add를 호출하는 별도의 메서드가 필요함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>세분화된 동기화시에도 Synchronized statements가 유용함&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kd">class&lt;/span> &lt;span class="nc">MsLunch&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">long&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lock1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">lock2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Object&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">inc1&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c1&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">inc2&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">synchronized&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">lock2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">c2&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>c1과 c2는 절대 함께 사용되지 않으며, 이런 필드의 모든 업데이트는 동기화 되어야함
&lt;ul>
&lt;li>하지만 c1과 c2사이의 동기화는 고려하지도 않아도 됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위와 같은상황에서 synchronized statements가 유용함&lt;/li>
&lt;/ul>
&lt;h3 id="synchronized-method-or-statements에서만-사용가능한-메서드">Synchronized method or statements에서만 사용가능한 메서드
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>Synchronized method or statements외에 사용시 IllegalMonitorStateException 오류 발생&lt;/p>
&lt;/li>
&lt;li>
&lt;p>wait&lt;/p>
&lt;ul>
&lt;li>현재 쓰레드를 중단하고 객체 잠금을 해제함&lt;/li>
&lt;li>notify() 또는 notifyAll메서드를 호출하여 해당 객체를 알릴때까지 대기함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>notify&lt;/p>
&lt;ul>
&lt;li>객체 잠금을 가진 한 쓰레드르 깨우고 실행함&lt;/li>
&lt;li>깨어난 쓰레드는 객체 잠금을 얻고 작업을 수행&lt;/li>
&lt;li>어떤 쓰레드를 깨울지는 알 수 없기에 notifyAll을 주로 사용&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>notifyAll&lt;/p>
&lt;ul>
&lt;li>객체 잠금을 기다리는 모든 스레드르 꺠우고 실행&lt;/li>
&lt;li>깨어난 쓰레드들은 객체 잠금을 얻기위해 경쟁함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.ibm.com/docs/en/i/7.3?topic=techniques-synchronization-among-threads" target="_blank" rel="noopener"
>https://www.ibm.com/docs/en/i/7.3?topic=techniques-synchronization-among-threads&lt;/a>&lt;br>
&lt;a class="link" href="https://www.linkedin.com/pulse/thread-synchronization-techniques-ensuring-order-concurrent-n/" target="_blank" rel="noopener"
>https://www.linkedin.com/pulse/thread-synchronization-techniques-ensuring-order-concurrent-n/&lt;/a>&lt;br>
&lt;a class="link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html" target="_blank" rel="noopener"
>https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html&lt;/a>&lt;/p></description></item><item><title>HikariCP</title><link>https://sungho94.me/p/hikaricp/</link><pubDate>Sun, 31 Mar 2024 22:41:00 +0000</pubDate><guid>https://sungho94.me/p/hikaricp/</guid><description>&lt;blockquote>
&lt;p>hikari가 일본어로 빛이라는 의미&lt;/p>
&lt;/blockquote>
&lt;h2 id="concurrentbag">ConcurrentBag
&lt;/h2>&lt;ul>
&lt;li>hikary cp 에서 커넥션을 관리하는 주체&lt;/li>
&lt;li>borrow(빌려줌)메서드으로 커넥션을 반환
&lt;ul>
&lt;li>Compare and set 연산으로 커넥션을 사용상태로 변경&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>requite(갚음)메스드로 커넥션을 반납
&lt;ul>
&lt;li>setState 메서드로 커넥션을 사용가능한상태로 변경&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>빌려줄때는 CAS연산으로 해당 커넥션이 사용가능한 상태인지 확인하지만, 갚을때는 따로 확인하지 않음&lt;/p>
&lt;/blockquote>
&lt;h2 id="왜-hikari-cp를-많이-사용하는가">왜 Hikari CP를 많이 사용하는가?
&lt;/h2>&lt;ul>
&lt;li>Spring에서 지원하는 기본 connection pool이다&lt;/li>
&lt;li>Spring에서는 성능과 동시성에서 HikariCP가 장점이 있다고 판단하여 사용함&lt;/li>
&lt;li>사용이 불가능한 상황에서는 아래와 같은 순서로 Connection pool을를 사용함
&lt;ul>
&lt;li>HikariCP &amp;gt; Tomcat pooling DataSource &amp;gt; Commons DBCP2 &amp;gt; Oracle UCP&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>참고&lt;br>
&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#data.sql.datasource.connection-pool" target="_blank" rel="noopener"
>https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#data.sql.datasource.connection-pool&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>다른 CP들과 비교 [https://github.com/brettwooldridge/HikariCP/blob/dev/documents/Welcome-To-The-Jungle.md]
&lt;ul>
&lt;li>위 링크를 보면 다른 CP에 비해 request spike가 발생했을때 blocking thread가 적고, 커넥션 수가 일정한 것을 확인할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="기타">기타
&lt;/h2>&lt;ul>
&lt;li>HikariCP는 다른 CP에 비해 설정할 수 있는 값이 적음, 간단함을 추구하는 디자인 철학&lt;/li>
&lt;li>HikariCP와 다른 CP들과의 다르게 PrepareStatement캐싱을 하지 않음&lt;br>
&lt;/li>
&lt;/ul>
&lt;h2 id="속성-정리">속성 정리
&lt;/h2>&lt;h3 id="connectiontimeout">connectionTimeout
&lt;/h3>&lt;ul>
&lt;li>연결 타임아웃&lt;/li>
&lt;li>기본 30초&lt;/li>
&lt;li>짧게 설정할경우, 설정한 시간보다 조회하는 시간이 길면, time out error 발생&lt;/li>
&lt;/ul>
&lt;h3 id="이외의-것들은-링크httpsgithubcombrettwooldridgehikaricptabreadme-ov-filegear-configuration-knobs-baby참고">이외의 것들은 &lt;a class="link" href="https://github.com/brettwooldridge/HikariCP?tab=readme-ov-file#gear-configuration-knobs-baby" target="_blank" rel="noopener"
>링크&lt;/a>참고
&lt;/h3>&lt;p>&lt;a class="link" href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener"
>https://github.com/brettwooldridge/HikariCP&lt;/a>&lt;br>
&lt;a class="link" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#data.sql.datasource.connection-pool" target="_blank" rel="noopener"
>https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#data.sql.datasource.connection-pool&lt;/a>&lt;/p>
&lt;p>#Database&lt;/p></description></item><item><title>2-Garbage Collection Types</title><link>https://sungho94.me/p/2-garbage-collection-types/</link><pubDate>Thu, 22 Feb 2024 23:19:00 +0000</pubDate><guid>https://sungho94.me/p/2-garbage-collection-types/</guid><description>&lt;h2 id="serial-gc">Serial GC
&lt;/h2>&lt;ul>
&lt;li>CPU 코어나 메모리가 적을 때 유용&lt;/li>
&lt;li>하나의 서버에 여러 jvm이 실행되는 환경에서 유용&lt;/li>
&lt;li>major GC와 minor GC가 serially하게 적용됨&lt;/li>
&lt;li>mark-compact-swap 방식을 사용&lt;/li>
&lt;li>오래된 메모리를 heap의 시작점에 두고, 새로 생성된 메모리를 heap의 마지막에 두어 새로 생성된 메모리가 연속적으로 할당되게함&lt;/li>
&lt;li>-XX:+UseSerialGC 로 사용가능&lt;/li>
&lt;/ul>
&lt;h2 id="parallel-gc">Parallel GC
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>사용하는 알고리즘은 Serial GC와 같으나, 여러 스레드를 사용함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU코어가 1개 이상일때 많을때 유용함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU코어가 N개일때 N개의 garbage Collector를 사용&lt;/p>
&lt;ul>
&lt;li>옵션으로 garbage Collector개수 설정 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CPU코어가 1개인 환경에서는 Parallel GC를 사용하더라도 해당 Serial GC가 사용됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ParallelGC는 2가지 가 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="parallelgc">ParallelGC
&lt;/h3>&lt;ul>
&lt;li>Old영역은 싱글스레드, Young 영역은 멀티스레드로 동작&lt;/li>
&lt;li>Old영역의 compact도 싱글스레드로 동작&lt;/li>
&lt;li>&lt;code>-XX:+UseParallelGC&lt;/code>로 사용가능&lt;/li>
&lt;/ul>
&lt;h3 id="paralleloldgc">ParallelOldGC
&lt;/h3>&lt;ul>
&lt;li>Old영역, Young영역 둘다 멀티스레드로 동작&lt;/li>
&lt;li>compact도 멀티스레드로 동작&lt;/li>
&lt;li>&lt;code>-XX:+UseParallelOldGC&lt;/code>로 사용가능&lt;/li>
&lt;/ul>
&lt;h2 id="the-concurrent-mark-sweep-cms-collector">The Concurrent Mark Sweep (CMS) Collector
&lt;/h2>&lt;ul>
&lt;li>tenured영역을 collect하는 GC&lt;/li>
&lt;li>GC를 애플리케이션 스레드와 동시에 수행하여 애플리케이션의 일시중단 시간을 최소화 하려함&lt;/li>
&lt;li>live객체를 이동, 복사하거나 압축하지 않음&lt;/li>
&lt;li>조각화가 문제가 되는경우 더 큰 힙을 할당해야함&lt;/li>
&lt;li>&lt;code>-XX:+UseConcMarkSweepGC&lt;/code>로 사용가능&lt;/li>
&lt;li>&lt;em>거의 사용되지 않음&lt;/em>&lt;/li>
&lt;/ul>
&lt;h2 id="g1-gc">G1 GC
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240304223056.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>아래와 같이 바둑판 영역에 객체를 할당하고 GC를 실행함&lt;/li>
&lt;li>해당 영역에 데이터가 꽉 차면 다른 영역에 객체를 할당하고 gc를 실행함&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://d2.naver.com/helloworld/1329" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/1329&lt;/a>&lt;br>
&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"
>https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a>&lt;/p></description></item><item><title>2-Garbage Collection Types</title><link>https://sungho94.me/p/2-garbage-collection-types/</link><pubDate>Thu, 22 Feb 2024 23:19:00 +0000</pubDate><guid>https://sungho94.me/p/2-garbage-collection-types/</guid><description>&lt;h2 id="serial-gc">Serial GC
&lt;/h2>&lt;ul>
&lt;li>CPU 코어나 메모리가 적을 때 유용&lt;/li>
&lt;li>하나의 서버에 여러 jvm이 실행되는 환경에서 유용&lt;/li>
&lt;li>major GC와 minor GC가 serially하게 적용됨&lt;/li>
&lt;li>mark-compact-swap 방식을 사용&lt;/li>
&lt;li>오래된 메모리를 heap의 시작점에 두고, 새로 생성된 메모리를 heap의 마지막에 두어 새로 생성된 메모리가 연속적으로 할당되게함&lt;/li>
&lt;li>-XX:+UseSerialGC 로 사용가능&lt;/li>
&lt;/ul>
&lt;h2 id="parallel-gc">Parallel GC
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>사용하는 알고리즘은 Serial GC와 같으나, 여러 스레드를 사용함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU코어가 1개 이상일때 많을때 유용함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CPU코어가 N개일때 N개의 garbage Collector를 사용&lt;/p>
&lt;ul>
&lt;li>옵션으로 garbage Collector개수 설정 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>CPU코어가 1개인 환경에서는 Parallel GC를 사용하더라도 해당 Serial GC가 사용됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ParallelGC는 2가지 가 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="parallelgc">ParallelGC
&lt;/h3>&lt;ul>
&lt;li>Old영역은 싱글스레드, Young 영역은 멀티스레드로 동작&lt;/li>
&lt;li>Old영역의 compact도 싱글스레드로 동작&lt;/li>
&lt;li>&lt;code>-XX:+UseParallelGC&lt;/code>로 사용가능&lt;/li>
&lt;/ul>
&lt;h3 id="paralleloldgc">ParallelOldGC
&lt;/h3>&lt;ul>
&lt;li>Old영역, Young영역 둘다 멀티스레드로 동작&lt;/li>
&lt;li>compact도 멀티스레드로 동작&lt;/li>
&lt;li>&lt;code>-XX:+UseParallelOldGC&lt;/code>로 사용가능&lt;/li>
&lt;/ul>
&lt;h2 id="the-concurrent-mark-sweep-cms-collector">The Concurrent Mark Sweep (CMS) Collector
&lt;/h2>&lt;ul>
&lt;li>tenured영역을 collect하는 GC&lt;/li>
&lt;li>GC를 애플리케이션 스레드와 동시에 수행하여 애플리케이션의 일시중단 시간을 최소화 하려함&lt;/li>
&lt;li>live객체를 이동, 복사하거나 압축하지 않음&lt;/li>
&lt;li>조각화가 문제가 되는경우 더 큰 힙을 할당해야함&lt;/li>
&lt;li>&lt;code>-XX:+UseConcMarkSweepGC&lt;/code>로 사용가능&lt;/li>
&lt;li>&lt;em>거의 사용되지 않음&lt;/em>&lt;/li>
&lt;/ul>
&lt;h2 id="g1-gc">G1 GC
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240304223056.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>아래와 같이 바둑판 영역에 객체를 할당하고 GC를 실행함&lt;/li>
&lt;li>해당 영역에 데이터가 꽉 차면 다른 영역에 객체를 할당하고 gc를 실행함&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://d2.naver.com/helloworld/1329" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/1329&lt;/a>&lt;br>
&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"
>https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a>&lt;/p></description></item><item><title>1-Garbage Collection Process</title><link>https://sungho94.me/p/1-garbage-collection-process/</link><pubDate>Thu, 22 Feb 2024 23:15:48 +0000</pubDate><guid>https://sungho94.me/p/1-garbage-collection-process/</guid><description>&lt;ul>
&lt;li>앞의 Garbage Collection Concept에서는 heap이 나누어져 저장되는 것을 이해함&lt;/li>
&lt;li>여기서는 나누어져 저장되는 것들의 상호작용에 대해 알아봄&lt;/li>
&lt;/ul>
&lt;h3 id="1-object-allocation">1. Object Allocation
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222231607.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>모든 새 객체들은 Eden 영역에 할당됨&lt;/li>
&lt;li>애플리케이션을 처음 시작한다면 두 survivor영역은 비어있음&lt;/li>
&lt;/ul>
&lt;h3 id="2-filling-the-eden-space">2. Filling the Eden Space
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222232133.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>Eden 영역이 꽉 찬다면, minor GC가 실행됨&lt;/li>
&lt;/ul>
&lt;h3 id="3-copying-referenced-objects">3. Copying Referenced Objects
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222232238.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>Referenced 객체는 S0 servivor 영역으로 이동됨&lt;/li>
&lt;li>Unreferenced 객체는 삭제됨&lt;/li>
&lt;/ul>
&lt;h3 id="4-object-aging">4. Object Aging
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222232408.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>다음 miner GC때 3의 동작이 한번 더 발생됨&lt;/li>
&lt;li>Referenced 객체는 suvivor 영역으로 이동하고, Unreferenced 객체는 삭제됨&lt;/li>
&lt;li>3과 다른점은 S0에 존재했던 객체들이 S1영역 으로 간다는 것&lt;/li>
&lt;li>S0에서 S1으로 이동한 객체는 이동하면서 1살을 더 먹음&lt;/li>
&lt;li>miner GC가 발생하므로서 Eden과 S0은 비워지고 S1에만 객체가 존재함&lt;/li>
&lt;/ul>
&lt;h3 id="5-additional-aging">5. Additional Aging
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222233018.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>다음 minor GC때 4의 과정이 반복되며 나이를 먹음&lt;/li>
&lt;li>S1에 있던 Referenced 객체들이 S0으로 이동하며 나이를 먹고, Eden과 S2 영역은 비워짐&lt;/li>
&lt;/ul>
&lt;h3 id="6-promotion---1">6. Promotion - 1
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222233216.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>계속 minor gc가 발생하고, 특정 임계값(예제에서는 8)을 넘은 객체들은 Old Generation(Tenured)영역으로 이동함&lt;/li>
&lt;/ul>
&lt;h3 id="promotion--2">Promotion -2
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222233418.png"
loading="lazy"
alt="center|400"
>&lt;/p>
&lt;ul>
&lt;li>minor GC가 계속 발생하면서 Old Generation으로 객체가 계속 승격됨&lt;/li>
&lt;/ul>
&lt;h3 id="gc-process-summary">GC Process Summary
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222233605.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>결국에는 Old Generation에도 객체가 꽉차고 major GC가 발생함&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://d2.naver.com/helloworld/1329" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/1329&lt;/a>&lt;br>
&lt;a class="link" href="https://d2.naver.com/helloworld/0128759" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/0128759&lt;/a>&lt;br>
&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"
>https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a>&lt;br>
&lt;a class="link" href="https://developers.redhat.com/articles/2021/08/20/stages-and-levels-java-garbage-collection#generational" target="_blank" rel="noopener"
>https://developers.redhat.com/articles/2021/08/20/stages-and-levels-java-garbage-collection#generational&lt;/a>_garbage_collection&lt;br>
&lt;a class="link" href="https://developers.redhat.com/articles/2021/09/09/how-jvm-uses-and-allocates-memory#how" target="_blank" rel="noopener"
>https://developers.redhat.com/articles/2021/09/09/how-jvm-uses-and-allocates-memory#how&lt;/a>_to_check_the_thread_stack_size&lt;/p></description></item><item><title>1-Garbage Collection Process</title><link>https://sungho94.me/p/1-garbage-collection-process/</link><pubDate>Thu, 22 Feb 2024 23:15:48 +0000</pubDate><guid>https://sungho94.me/p/1-garbage-collection-process/</guid><description>&lt;ul>
&lt;li>앞의 Garbage Collection Concept에서는 heap이 나누어져 저장되는 것을 이해함&lt;/li>
&lt;li>여기서는 나누어져 저장되는 것들의 상호작용에 대해 알아봄&lt;/li>
&lt;/ul>
&lt;h3 id="1-object-allocation">1. Object Allocation
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222231607.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>모든 새 객체들은 Eden 영역에 할당됨&lt;/li>
&lt;li>애플리케이션을 처음 시작한다면 두 survivor영역은 비어있음&lt;/li>
&lt;/ul>
&lt;h3 id="2-filling-the-eden-space">2. Filling the Eden Space
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222232133.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>Eden 영역이 꽉 찬다면, minor GC가 실행됨&lt;/li>
&lt;/ul>
&lt;h3 id="3-copying-referenced-objects">3. Copying Referenced Objects
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222232238.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>Referenced 객체는 S0 servivor 영역으로 이동됨&lt;/li>
&lt;li>Unreferenced 객체는 삭제됨&lt;/li>
&lt;/ul>
&lt;h3 id="4-object-aging">4. Object Aging
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222232408.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>다음 miner GC때 3의 동작이 한번 더 발생됨&lt;/li>
&lt;li>Referenced 객체는 suvivor 영역으로 이동하고, Unreferenced 객체는 삭제됨&lt;/li>
&lt;li>3과 다른점은 S0에 존재했던 객체들이 S1영역 으로 간다는 것&lt;/li>
&lt;li>S0에서 S1으로 이동한 객체는 이동하면서 1살을 더 먹음&lt;/li>
&lt;li>miner GC가 발생하므로서 Eden과 S0은 비워지고 S1에만 객체가 존재함&lt;/li>
&lt;/ul>
&lt;h3 id="5-additional-aging">5. Additional Aging
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222233018.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>다음 minor GC때 4의 과정이 반복되며 나이를 먹음&lt;/li>
&lt;li>S1에 있던 Referenced 객체들이 S0으로 이동하며 나이를 먹고, Eden과 S2 영역은 비워짐&lt;/li>
&lt;/ul>
&lt;h3 id="6-promotion---1">6. Promotion - 1
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222233216.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>계속 minor gc가 발생하고, 특정 임계값(예제에서는 8)을 넘은 객체들은 Old Generation(Tenured)영역으로 이동함&lt;/li>
&lt;/ul>
&lt;h3 id="promotion--2">Promotion -2
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222233418.png"
loading="lazy"
alt="center|400"
>&lt;/p>
&lt;ul>
&lt;li>minor GC가 계속 발생하면서 Old Generation으로 객체가 계속 승격됨&lt;/li>
&lt;/ul>
&lt;h3 id="gc-process-summary">GC Process Summary
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222233605.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>결국에는 Old Generation에도 객체가 꽉차고 major GC가 발생함&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://d2.naver.com/helloworld/1329" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/1329&lt;/a>&lt;br>
&lt;a class="link" href="https://d2.naver.com/helloworld/0128759" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/0128759&lt;/a>&lt;br>
&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"
>https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a>&lt;br>
&lt;a class="link" href="https://developers.redhat.com/articles/2021/08/20/stages-and-levels-java-garbage-collection#generational" target="_blank" rel="noopener"
>https://developers.redhat.com/articles/2021/08/20/stages-and-levels-java-garbage-collection#generational&lt;/a>_garbage_collection&lt;br>
&lt;a class="link" href="https://developers.redhat.com/articles/2021/09/09/how-jvm-uses-and-allocates-memory#how" target="_blank" rel="noopener"
>https://developers.redhat.com/articles/2021/09/09/how-jvm-uses-and-allocates-memory#how&lt;/a>_to_check_the_thread_stack_size&lt;/p></description></item><item><title>Full garbage collection</title><link>https://sungho94.me/p/full-garbage-collection/</link><pubDate>Thu, 22 Feb 2024 23:11:30 +0000</pubDate><guid>https://sungho94.me/p/full-garbage-collection/</guid><description>&lt;ul>
&lt;li>Garbage Collection 파트에서 Full garbage collection에 대한 추가 설명&lt;/li>
&lt;li>직접 실험해보면서 체크필요&lt;/li>
&lt;/ul>
&lt;p>#wait-to-update&lt;/p>
&lt;p>&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"
>https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a>&lt;br>
&lt;a class="link" href="https://dzone.com/articles/minor-gc-vs-major-gc-vs-full" target="_blank" rel="noopener"
>https://dzone.com/articles/minor-gc-vs-major-gc-vs-full&lt;/a>&lt;/p></description></item><item><title>Full garbage collection</title><link>https://sungho94.me/p/full-garbage-collection/</link><pubDate>Thu, 22 Feb 2024 23:11:30 +0000</pubDate><guid>https://sungho94.me/p/full-garbage-collection/</guid><description>&lt;ul>
&lt;li>Garbage Collection 파트에서 Full garbage collection에 대한 추가 설명&lt;/li>
&lt;li>직접 실험해보면서 체크필요&lt;/li>
&lt;/ul>
&lt;p>#wait-to-update&lt;/p>
&lt;p>&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"
>https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a>&lt;br>
&lt;a class="link" href="https://dzone.com/articles/minor-gc-vs-major-gc-vs-full" target="_blank" rel="noopener"
>https://dzone.com/articles/minor-gc-vs-major-gc-vs-full&lt;/a>&lt;/p></description></item><item><title>0-Garbage Collection Concept</title><link>https://sungho94.me/p/0-garbage-collection-concept/</link><pubDate>Mon, 19 Feb 2024 13:24:16 +0000</pubDate><guid>https://sungho94.me/p/0-garbage-collection-concept/</guid><description>&lt;ul>
&lt;li>메모리 관리 기법중 하나로 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게된 영역을 해제하는 기능&lt;/li>
&lt;li>Reference counting이 0이되면 삭제함&lt;/li>
&lt;/ul>
&lt;h2 id="garbage-collection-과정">Garbage Collection 과정
&lt;/h2>&lt;h3 id="step-1-marking">Step 1. Marking
&lt;/h3>&lt;ul>
&lt;li>Garbage Collector가 메모리 조각중에서 사용되고 있는 것과 사용되지 않는것을 찾아 marking하는 단계&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222132054.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;li>그림에서 참조된 객체는 blue, 참조되지 않은 객체는 주황색임&lt;/li>
&lt;li>marking단계에서는 삭제를 하기 위한 객체를 찾는 과정&lt;/li>
&lt;li>시스템을 모두 스캔해야 하는 경우 시간이 많이 소요될 수 있음&lt;/li>
&lt;/ul>
&lt;h3 id="step-2-normal-deletion">Step 2. Normal Deletion
&lt;/h3>&lt;ul>
&lt;li>Step 1에서 찾은 객체를 삭제하는 단계&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222132435.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;li>memory allocator는 새 객체를 할당 할 수 있는 여유 공간 블록에 대한 참조를 보유
&lt;ul>
&lt;li>memory allocator는 비어있는 공간에 대한 참조를 가지고, 할당이 필요한 비어있는 공간을 검색&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="step-2a-deletion-with-compacting">Step 2a. Deletion with Compacting
&lt;/h3>&lt;ul>
&lt;li>추가적인 성능 향상을 위해, 참조되지 않는 객체를 삭제하면서 남아있는 참조 객체를 압축할 수 있음&lt;/li>
&lt;li>참조된 객체를 함께 이동함으로써, 메모리 할당은 더 빠르고 쉬워짐&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222133340.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;li>Memory Allocator는 비어있는 공간에 대한 첫번째 참조를 가지고, 메모리를 순차적으로 할당&lt;/li>
&lt;/ul>
&lt;h2 id="generation-garbage-collection">Generation Garbage Collection
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222224100.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>JVM의 모든 객체를 marking하고 compact하는것은 비효율적임&lt;/li>
&lt;li>시간이 지날수록 객체의 숫자는 늘어가며 이에따라 garbage collection의 시간은 증가할것임&lt;/li>
&lt;li>하지만 대부분의 객체의 수명은 짧기에 Generation Garbage Collection을 사용함
&lt;ul>
&lt;li>경험적으로 증명됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위의 그래프에서 알 수 있듯이 대부분의 객체의 수명은 짧고, 시간이 지남에 따라 객체의 숫자가 줄어든다는 것을 파악할 수 있음&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222224505.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>JVM heap은 위와 같이 3가지 구역(Young, Old, Permanent)으로 나뉨&lt;/li>
&lt;li>Yong Generation
&lt;ul>
&lt;li>새로운 객체가 할당되고, aged되는 곳&lt;/li>
&lt;li>Yong Generation이 가득차면 minor gc가 발생함&lt;/li>
&lt;li>minor gc는 객체의 사망률이 높을때 최적화됨&lt;/li>
&lt;li>dead object는 빠르게 수거됨&lt;/li>
&lt;li>살아남은 일부 객체는 Old Generation으로 이동함&lt;/li>
&lt;li>minor gc가 발생할때 Stop-the-world가 발생함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Stop-the-world가 발생하면 모든 어플리케이션의 쓰레드가 중지됨&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>Old Generation&lt;/p>
&lt;ul>
&lt;li>오래 살아남은 객체가 저장되는곳&lt;/li>
&lt;li>Yong Generation에는 임계값이 존재하고 임계값을 넘어서 생존하는 경우 Old Generation으로 이동함&lt;/li>
&lt;li>언젠간 Old Generation에도 Garbage Collection이 발생해야 하고 이것을 major GC로 명명함&lt;/li>
&lt;li>major gc에서도 Stop-the-world가 발생함&lt;/li>
&lt;li>major gc는 모든 살아있는 객체를 대상으로 하기에 느림&lt;/li>
&lt;li>반응형 애플리케이션에서는 major gc가 최소한으로 발생해야함&lt;/li>
&lt;li>major gc는 Old Generation에서 사용하는 garbage collector 종류에 따라 Stop-the-world의 시간이 결정됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Permanent Generation&lt;/p>
&lt;ul>
&lt;li>JVM의 class와 Method를 describe하기 위한 메타데이터가 저장됨&lt;/li>
&lt;li>Permanent Generation는 어플리케이션에서 사용중인 클래스를 기반으로 런타임에 JVM에 의해 채워짐&lt;/li>
&lt;li>Java SE 라이브러리 클래스 및 메서드가 채워질 수 있음&lt;/li>
&lt;li>JVM이 더 이상 필요없다고 판단하거나, 다른 클래스를 위한 공간이 필요할경우 unload될 수 있음&lt;/li>
&lt;li>Permanent Generation은 full garbage collection에 포함됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>full garbage collection이란?&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://d2.naver.com/helloworld/1329" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/1329&lt;/a>&lt;br>
&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"
>https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a>&lt;/p></description></item><item><title>0-Garbage Collection Concept</title><link>https://sungho94.me/p/0-garbage-collection-concept/</link><pubDate>Mon, 19 Feb 2024 13:24:16 +0000</pubDate><guid>https://sungho94.me/p/0-garbage-collection-concept/</guid><description>&lt;ul>
&lt;li>메모리 관리 기법중 하나로 프로그램이 동적으로 할당했던 메모리 영역 중에서 필요없게된 영역을 해제하는 기능&lt;/li>
&lt;li>Reference counting이 0이되면 삭제함&lt;/li>
&lt;/ul>
&lt;h2 id="garbage-collection-과정">Garbage Collection 과정
&lt;/h2>&lt;h3 id="step-1-marking">Step 1. Marking
&lt;/h3>&lt;ul>
&lt;li>Garbage Collector가 메모리 조각중에서 사용되고 있는 것과 사용되지 않는것을 찾아 marking하는 단계&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222132054.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;li>그림에서 참조된 객체는 blue, 참조되지 않은 객체는 주황색임&lt;/li>
&lt;li>marking단계에서는 삭제를 하기 위한 객체를 찾는 과정&lt;/li>
&lt;li>시스템을 모두 스캔해야 하는 경우 시간이 많이 소요될 수 있음&lt;/li>
&lt;/ul>
&lt;h3 id="step-2-normal-deletion">Step 2. Normal Deletion
&lt;/h3>&lt;ul>
&lt;li>Step 1에서 찾은 객체를 삭제하는 단계&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222132435.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;li>memory allocator는 새 객체를 할당 할 수 있는 여유 공간 블록에 대한 참조를 보유
&lt;ul>
&lt;li>memory allocator는 비어있는 공간에 대한 참조를 가지고, 할당이 필요한 비어있는 공간을 검색&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="step-2a-deletion-with-compacting">Step 2a. Deletion with Compacting
&lt;/h3>&lt;ul>
&lt;li>추가적인 성능 향상을 위해, 참조되지 않는 객체를 삭제하면서 남아있는 참조 객체를 압축할 수 있음&lt;/li>
&lt;li>참조된 객체를 함께 이동함으로써, 메모리 할당은 더 빠르고 쉬워짐&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222133340.png"
loading="lazy"
alt="center|400"
>&lt;/li>
&lt;li>Memory Allocator는 비어있는 공간에 대한 첫번째 참조를 가지고, 메모리를 순차적으로 할당&lt;/li>
&lt;/ul>
&lt;h2 id="generation-garbage-collection">Generation Garbage Collection
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222224100.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>JVM의 모든 객체를 marking하고 compact하는것은 비효율적임&lt;/li>
&lt;li>시간이 지날수록 객체의 숫자는 늘어가며 이에따라 garbage collection의 시간은 증가할것임&lt;/li>
&lt;li>하지만 대부분의 객체의 수명은 짧기에 Generation Garbage Collection을 사용함
&lt;ul>
&lt;li>경험적으로 증명됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>위의 그래프에서 알 수 있듯이 대부분의 객체의 수명은 짧고, 시간이 지남에 따라 객체의 숫자가 줄어든다는 것을 파악할 수 있음&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240222224505.png"
loading="lazy"
alt="center|600"
>&lt;/p>
&lt;ul>
&lt;li>JVM heap은 위와 같이 3가지 구역(Young, Old, Permanent)으로 나뉨&lt;/li>
&lt;li>Yong Generation
&lt;ul>
&lt;li>새로운 객체가 할당되고, aged되는 곳&lt;/li>
&lt;li>Yong Generation이 가득차면 minor gc가 발생함&lt;/li>
&lt;li>minor gc는 객체의 사망률이 높을때 최적화됨&lt;/li>
&lt;li>dead object는 빠르게 수거됨&lt;/li>
&lt;li>살아남은 일부 객체는 Old Generation으로 이동함&lt;/li>
&lt;li>minor gc가 발생할때 Stop-the-world가 발생함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Stop-the-world가 발생하면 모든 어플리케이션의 쓰레드가 중지됨&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>Old Generation&lt;/p>
&lt;ul>
&lt;li>오래 살아남은 객체가 저장되는곳&lt;/li>
&lt;li>Yong Generation에는 임계값이 존재하고 임계값을 넘어서 생존하는 경우 Old Generation으로 이동함&lt;/li>
&lt;li>언젠간 Old Generation에도 Garbage Collection이 발생해야 하고 이것을 major GC로 명명함&lt;/li>
&lt;li>major gc에서도 Stop-the-world가 발생함&lt;/li>
&lt;li>major gc는 모든 살아있는 객체를 대상으로 하기에 느림&lt;/li>
&lt;li>반응형 애플리케이션에서는 major gc가 최소한으로 발생해야함&lt;/li>
&lt;li>major gc는 Old Generation에서 사용하는 garbage collector 종류에 따라 Stop-the-world의 시간이 결정됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Permanent Generation&lt;/p>
&lt;ul>
&lt;li>JVM의 class와 Method를 describe하기 위한 메타데이터가 저장됨&lt;/li>
&lt;li>Permanent Generation는 어플리케이션에서 사용중인 클래스를 기반으로 런타임에 JVM에 의해 채워짐&lt;/li>
&lt;li>Java SE 라이브러리 클래스 및 메서드가 채워질 수 있음&lt;/li>
&lt;li>JVM이 더 이상 필요없다고 판단하거나, 다른 클래스를 위한 공간이 필요할경우 unload될 수 있음&lt;/li>
&lt;li>Permanent Generation은 full garbage collection에 포함됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>full garbage collection이란?&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://d2.naver.com/helloworld/1329" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/1329&lt;/a>&lt;br>
&lt;a class="link" href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" target="_blank" rel="noopener"
>https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/a>&lt;/p></description></item><item><title>JVM memory structure</title><link>https://sungho94.me/p/jvm-memory-structure/</link><pubDate>Tue, 14 Nov 2023 23:06:28 +0000</pubDate><guid>https://sungho94.me/p/jvm-memory-structure/</guid><description>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231117232133.png"
loading="lazy"
alt="Pasted image 20231117232133"
>&lt;/p>
&lt;h3 id="pc-register">PC Register
&lt;/h3>&lt;ul>
&lt;li>각각의 쓰레드마다 하나씩 가지고 있음&lt;/li>
&lt;li>현재 실행중인 명령의 주소를 저장하고있음&lt;/li>
&lt;li>실행중인 메서드가 native메서드가 아닐경우, 가상머신 명령어의 주소를 가지고 있음&lt;/li>
&lt;/ul>
&lt;h3 id="java-virtual-machine-stacks">Java Virtual Machine Stacks
&lt;/h3>&lt;ul>
&lt;li>C stack이라는 범용적인 스택을 사용
&lt;ul>
&lt;li>내가 ollydbg봤던 스택&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>현재 실행중인 메서드의 정보를 포함함
&lt;ul>
&lt;li>지역변수, 파라미터, 리턴주소 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>각각의 쓰레드가 하나씩 가지고 있음&lt;/li>
&lt;li>해당 스레드가 허용된것보다 더 큰 Native Method Stack이 필요한경우, StackOverflowError&lt;/li>
&lt;li>해당 스레드가 허용된만큼 Native Method Stack이 필요하지만, 메모리가 부족한 경우 OutOfMemoryError&lt;/li>
&lt;/ul>
&lt;h3 id="native-method-stack">Native Method Stack
&lt;/h3>&lt;ul>
&lt;li>JVM 스택과 유사하지만, java가 아닌 다른 언어로 작성된 네이티브 메서드를 지원하기 위한 영역&lt;/li>
&lt;li>C stack가지고, jvm stack과 같은 정보를 포함하고 있음&lt;/li>
&lt;li>jvm stack과 같은 상황에서 StackOverflowError, OutOfMemoryError가 발생함&lt;/li>
&lt;/ul>
&lt;h3 id="heap-area">Heap Area
&lt;/h3>&lt;ul>
&lt;li>가상머신 쓰레드간 공유되는 메모리 영역&lt;/li>
&lt;li>클래스의 인스턴스와 배열의 메모리가 할당되는 영역&lt;/li>
&lt;li>가상머신이 시작될때 생성됨&lt;/li>
&lt;li>gc에 의해 회수되고, 명시적으로 회수할 수 없음&lt;/li>
&lt;li>초기 메모리를 할당받고, 메모리가 더 필요하면 시스템에 요청해 메모리를 더 받아옴
&lt;ul>
&lt;li>#JVM-option 참고&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>할당된 메모리보다 많은 메모리를 사용해야 할때 OutOfMemoryError발생&lt;/li>
&lt;/ul>
&lt;h3 id="method-area">Method Area
&lt;/h3>&lt;ul>
&lt;li>가상머신 쓰레드간 공유되는 메모리 영역&lt;/li>
&lt;li>운영체제 프로세스의 text영역과 유사함&lt;/li>
&lt;li>런타임 상수 풀, 필드 및 메서드 데이터, 클래스 및 인터페이스 초기화 및 인스턴스 초기화에 사용되는 특수 메서드를 포함한 메서드 및 생성자 코드와 같은 클래스별 구조를 저장&lt;/li>
&lt;li>가상머신이 생성될때 생성됨&lt;/li>
&lt;li>논리적으로 heap의 일부임
&lt;ul>
&lt;li>간단한 구현에서는 gc가 발생하지 않을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>할당된 메모리보다 많은 메모리를 사용해야 할때 OutOfMemoryError발생&lt;/li>
&lt;/ul>
&lt;h3 id="run-time-constant-pool">Run-Time Constant Pool
&lt;/h3>&lt;ul>
&lt;li>Method Area에 포함됨&lt;/li>
&lt;li>클래스 파일의 constant_pool에 있는 데이터를 가지고 있음&lt;/li>
&lt;li>할당된 메모리보다 많은 메모리를 사용해야 할때 OutOfMemoryError발생&lt;/li>
&lt;/ul>
&lt;h3 id="쓰레드와-메모리의-관계">쓰레드와 메모리의 관계
&lt;/h3>&lt;ul>
&lt;li>pc register, jvm Stack, Native Method Stack은 각 쓰레드마다 가짐&lt;/li>
&lt;li>Heap Area와 Method Area는 쓰레드간 공유되는 영역임&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-2.html" target="_blank" rel="noopener"
>https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-2.html&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.devkuma.com/docs/jvm/memory-structure/" target="_blank" rel="noopener"
>https://www.devkuma.com/docs/jvm/memory-structure/&lt;/a>&lt;/p>
&lt;p>#Java&lt;/p></description></item><item><title>jvm option for Container</title><link>https://sungho94.me/p/jvm-option-for-container/</link><pubDate>Tue, 14 Nov 2023 11:26:23 +0000</pubDate><guid>https://sungho94.me/p/jvm-option-for-container/</guid><description>&lt;h3 id="현재-옵션-확인">현재 옵션 확인
&lt;/h3>&lt;ul>
&lt;li>java -XX:+PrintFlagsFinal -version 2&amp;gt;&amp;amp;1 | grep -i -E &amp;lsquo;heapsize|metaspace|version&amp;rsquo;&lt;/li>
&lt;/ul>
&lt;h3 id="memory">Memory
&lt;/h3>&lt;ul>
&lt;li>고정값으로 설정
&lt;ul>
&lt;li>-Xmx(ex -Xmx4g)
&lt;ul>
&lt;li>최대값&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-Xms(ex -Xms500m)
&lt;ul>
&lt;li>최소값&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>비율로 설정
&lt;ul>
&lt;li>-XX:MaxRAMPercentage(-XX:MaxRAMPercentage=75),
&lt;ul>
&lt;li>최대값&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-XX:InitialRAMPercentage(-XX:InitialRAMPercentage=75)
&lt;ul>
&lt;li>최소값&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>메모리 설정시 팁!
&lt;ul>
&lt;li>container메모리와 heap은 같은 사이즈로 가면 안됨
&lt;ul>
&lt;li>java에는 heap말고 non-heap도 있기때문&lt;/li>
&lt;li>힙 공간 외에도 Java 스레드, 가비지 컬렉션, 메타스페이스, 네이티브 메모리, 소켓 버퍼를 위한 공간이 필요하기 때문&lt;/li>
&lt;li>컨테이너 메모리와 같은 크기로 했을 때 컨테이너도 crash 발생하기 때문에 oom 후처리가 안됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>percentage로 75%정도 권장
&lt;ul>
&lt;li>&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/developer/java/containers/overview" target="_blank" rel="noopener"
>ms홈페이지 참고&lt;/a>&lt;/li>
&lt;li>물론 절대적인건 아님&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>하나의 컨테이너에 하나의 어플리케이션만 돌아갈떄 min size와 max size를 같게 설정
&lt;ul>
&lt;li>메모리가 부족이 발생하면 os에 메모리를 더 달라고 요청하는데, 어차피 하나의 컨테이너에 하나의 프로세스만 돌아가는데 굳이 필요없는 요청을 늘릴 필요가없음&lt;/li>
&lt;li>gc가 더 자주 실행됨&lt;/li>
&lt;li>하나의 컨테이너에서 하나의 프로세스만 돌기 때문에 경쟁이 필요가 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="oom-처리">OOM 처리
&lt;/h3>&lt;ul>
&lt;li>-XX:+HeapDumpOnOutOfMemoryError
&lt;ul>
&lt;li>OOM이 발생하면 heap dump를 생성&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>-XX:HeapDumpPath=/var/log
&lt;ul>
&lt;li>힙 덤프 생성 위치 설정&lt;/li>
&lt;li>위의 아래에 .hprof파일 생성됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>MaxRAMFraction&lt;/p>
&lt;ul>
&lt;li>deprecated된 옵션&lt;/li>
&lt;li>max heap memory를 설정하는 다른 방법&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>InitialRAMPercentage, MinRAMPercentage관련한 글&lt;br>
&lt;a class="link" href="https://blog.gceasy.io/2020/11/05/difference-between-initialrampercentage-minrampercentage-maxrampercentage/" target="_blank" rel="noopener"
>https://blog.gceasy.io/2020/11/05/difference-between-initialrampercentage-minrampercentage-maxrampercentage/&lt;/a>&lt;br>
&lt;a class="link" href="https://blog.ycrash.io/2020/11/23/best-practices-java-memory-arguments-for-containers/" target="_blank" rel="noopener"
>https://blog.ycrash.io/2020/11/23/best-practices-java-memory-arguments-for-containers/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>#JVM-option&lt;/p>
&lt;p>&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html" target="_blank" rel="noopener"
>https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html&lt;/a>&lt;br>
&lt;a class="link" href="https://www.merikan.com/2019/04/jvm-in-a-container/" target="_blank" rel="noopener"
>https://www.merikan.com/2019/04/jvm-in-a-container/&lt;/a>&lt;br>
&lt;a class="link" href="https://learn.microsoft.com/en-us/azure/developer/java/containers/overview" target="_blank" rel="noopener"
>https://learn.microsoft.com/en-us/azure/developer/java/containers/overview&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/43651167/is-there-any-advantage-in-setting-xms-and-xmx-to-the-same-value" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/43651167/is-there-any-advantage-in-setting-xms-and-xmx-to-the-same-value&lt;/a>&lt;br>
&lt;a class="link" href="https://developer.jboss.org/thread/149559" target="_blank" rel="noopener"
>https://developer.jboss.org/thread/149559&lt;/a>&lt;br>
&lt;a class="link" href="https://www.codementor.io/@suryab/outofmemoryerror-related-jvm-arguments-w6e4vgipt" target="_blank" rel="noopener"
>https://www.codementor.io/@suryab/outofmemoryerror-related-jvm-arguments-w6e4vgipt&lt;/a>&lt;br>
&lt;a class="link" href="https://medium.com/nordnet-tech/setting-java-heap-size-inside-a-docker-container-b5a4d06d2f46" target="_blank" rel="noopener"
>https://medium.com/nordnet-tech/setting-java-heap-size-inside-a-docker-container-b5a4d06d2f46&lt;/a>&lt;br>
&lt;a class="link" href="https://dzone.com/articles/best-practices-java-memory-arguments-for-container" target="_blank" rel="noopener"
>https://dzone.com/articles/best-practices-java-memory-arguments-for-container&lt;/a>&lt;br>
&lt;a class="link" href="https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#overview-of-java-options" target="_blank" rel="noopener"
>https://docs.oracle.com/en/java/javase/17/docs/specs/man/java.html#overview-of-java-options&lt;/a>&lt;br>
&lt;a class="link" href="https://d2.naver.com/helloworld/37111" target="_blank" rel="noopener"
>https://d2.naver.com/helloworld/37111&lt;/a>&lt;/p></description></item><item><title>Java built in Annotation</title><link>https://sungho94.me/p/java-built-in-annotation/</link><pubDate>Sun, 01 Oct 2023 23:06:17 +0000</pubDate><guid>https://sungho94.me/p/java-built-in-annotation/</guid><description>&lt;p>java의 built in Annotation은&lt;br>
&lt;strong>@Deprecated&lt;/strong>&lt;br>
&lt;strong>@Override&lt;/strong>&lt;br>
&lt;strong>@SuppressWarnings&lt;/strong>&lt;br>
&lt;strong>@SafeVarargs&lt;/strong>&lt;br>
&lt;strong>@FunctionalInterface&lt;/strong>&lt;br>
이 있고,&lt;/p>
&lt;p>다른 어노테이션에 붙을 수 있는 어노테이션은&lt;br>
&lt;strong>@Retention&lt;/strong>&lt;br>
&lt;strong>@Documented&lt;/strong>&lt;br>
&lt;strong>@Target&lt;/strong>&lt;br>
&lt;strong>@Inherited&lt;/strong>&lt;br>
&lt;strong>@Repeatable&lt;/strong>&lt;br>
이 있다&lt;/p>
&lt;p>이 중 Retention의 정확한 의미가 와닿지 않아 정리해 보겠다.&lt;/p>
&lt;h1 id="retention">Retention
&lt;/h1>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Indicates how long annotations with the annotated interface are to be retained
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>-&amp;gt; annotation이 얼마나 유지되는 정도를 나타냄, 디폴트는 Class&lt;/p>
&lt;h3 id="source">Source
&lt;/h3>&lt;ul>
&lt;li>컴파일될때 사라짐&lt;/li>
&lt;/ul>
&lt;h2 id="class">Class
&lt;/h2>&lt;ul>
&lt;li>클래스파일에는 기록되지만, vm에 올라갈떄 사라짐&lt;/li>
&lt;li>런타임시 리플렉션으로 정보를 가져올 수 없음&lt;/li>
&lt;/ul>
&lt;h2 id="runtime">Runtime
&lt;/h2>&lt;ul>
&lt;li>클래스파일에도 기록되고, vm에 올라감&lt;/li>
&lt;li>런타임시 리플렉션으로 정보를 가져올 수 있음&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Source vs Class&lt;br>
Source는 컴파일된 바이트 코드에서 아예 보이지 않음&lt;br>
Class는 바이트코드에서 보이지만 invisible이라는 주석이 붙음&lt;br>
바이트코드로 된 라이브러리를 만들때 사용&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Class vs Runtime&lt;br>
런타임에 사용 가능 여부에 따라 다름&lt;br>
@Lorg/example/RetentionSourceAnnotation;() // invisible &amp;lt;- Class&lt;br>
@Lorg/example/RetentionSourceAnnotation;() &amp;lt;- Runtime&lt;br>
javaasist 라이브러로 두개다 확인가능&lt;br>
&lt;a class="link" href="https://www.javassist.org/html/javassist/bytecode/AnnotationsAttribute.html" target="_blank" rel="noopener"
>https://www.javassist.org/html/javassist/bytecode/AnnotationsAttribute.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html" target="_blank" rel="noopener"
>https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html&lt;/a>&lt;br>
&lt;a class="link" href="https://minkukjo.github.io/language/2020/09/30/Java-02/" target="_blank" rel="noopener"
>https://minkukjo.github.io/language/2020/09/30/Java-02/&lt;/a>&lt;/p>
&lt;p>#Java&lt;/p></description></item></channel></rss>