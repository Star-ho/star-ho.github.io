<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database on Sungho's Dev BLog</title><link>https://sungho94.me/categories/database/</link><description>Recent content in Database on Sungho's Dev BLog</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Fri, 24 May 2024 16:30:40 +0000</lastBuildDate><atom:link href="https://sungho94.me/categories/database/index.xml" rel="self" type="application/rss+xml"/><item><title>7-Mysql 8.0에서는?</title><link>https://sungho94.me/p/7-mysql-8.0%EC%97%90%EC%84%9C%EB%8A%94/</link><pubDate>Fri, 24 May 2024 16:30:40 +0000</pubDate><guid>https://sungho94.me/p/7-mysql-8.0%EC%97%90%EC%84%9C%EB%8A%94/</guid><description>&lt;ul>
&lt;li>Jeremy Cole의 InnoDB정보들은 MySQL 5버전에 관한 내용이며, 10년전의 내용임&lt;/li>
&lt;li>현재 MySQL 8버전대를 사용하는데, 큰 기본 틀의 큰 차이는 없어 보이지만, 간단하게 알아볼 예정
&lt;ul>
&lt;li>Mysql버전에 따라 innodb버전이 업데이트됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Jeremy Cole의 Innodb_ruby는 현재 8버전 대를 지원하고 있지 않음&lt;/li>
&lt;li>필자는 아래 두가지 도구를 추천한다
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/alibaba/innodb-java-reader" target="_blank" rel="noopener"
>https://github.com/alibaba/innodb-java-reader&lt;/a>
&lt;ul>
&lt;li>이 포스팅에서 사용할 도구&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/baotiao/inno" target="_blank" rel="noopener"
>https://github.com/baotiao/inno&lt;/a>_space
&lt;ul>
&lt;li>사용방법을 익히려 해보았지만, record를 파싱하는 부분에서 에러가 나서 결국 포기하였다.&lt;/li>
&lt;li>예제 데이터는 ibd2sdi를 이용하여 record정보를 가져오는것 같은데 실패하였다
&lt;ul>
&lt;li>방법을 알면 댓글로 알려주시길 바랍니다 ㅠㅠ&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="무엇을-알아볼-것인가">무엇을 알아볼 것인가?
&lt;/h2>&lt;ul>
&lt;li>space page구조&lt;/li>
&lt;li>page들은 doubly-linked list 구조인가?&lt;/li>
&lt;li>index record들은 singly-linked list구조인가?&lt;/li>
&lt;/ul>
&lt;h2 id="space-page-구조">Space page 구조
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240524171103.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>매우 작은 테이블의 구조를 나타냄&lt;/li>
&lt;li>5버전대와의 차이점은 SDI페이지가 생겼다는 것이고, 이외에는 동일하다
&lt;ul>
&lt;li>SDI는 데이터베이스 객체에 대한 메타데이터를 저장하는 용도&lt;/li>
&lt;li>자세한 정보는 &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/serialized-dictionary-information.html" target="_blank" rel="noopener"
>링크&lt;/a>참고&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="여전히-page들은-doubly-linked-list인가">여전히 page들은 doubly-linked list인가?
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240524172057.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>데이터가 들어있는 페이지의 일부이다&lt;/li>
&lt;li>page들이 prevPage, nextPage를 가지고 있고 INDEX페이지들은 앞 뒤 페이지를 참조하는 것을 알 수 있음
&lt;ul>
&lt;li>doubly-linked list구조 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="index-record들은-singly-linked-list구조인가">index record들은 singly-linked list구조인가?
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240524172847.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>하나의 offset만 존재하며, 현재 primaryKeyPosition값에서 offset을 더하면, 다음 primaryKeyPosition이 되는 것을 알 수 있음
&lt;ul>
&lt;li>singly-linked list구조 확인&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>5-physical structure of records in InnoDB</title><link>https://sungho94.me/p/5-physical-structure-of-records-in-innodb/</link><pubDate>Wed, 22 May 2024 22:43:24 +0000</pubDate><guid>https://sungho94.me/p/5-physical-structure-of-records-in-innodb/</guid><description>&lt;h2 id="record">Record
&lt;/h2>&lt;ul>
&lt;li>해당 포스트에서는 COMPACT row format만 고려함&lt;/li>
&lt;/ul>
&lt;h3 id="record-offsets">Record offsets
&lt;/h3>&lt;ul>
&lt;li>이전 포스트에서 레코드 오프셋은 레코드를 가르키는 구조라고 설명했음&lt;/li>
&lt;li>레코드 오프셋은, 가변길이인 레코드 데이터 자체의 시작을 가르키지만, 각 레코드 앞에는 가변길이의 레코드 헤더가 존재함&lt;/li>
&lt;li>해당 포스트의 글과 그림에서 레코드 데이터는 N에 존재하고, N+1과같이 양수오프셋으로 표현함
&lt;ul>
&lt;li>헤더는 N-1과 같이 음수 오프셋으로 표현함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>InnoDB는 종종 레코드의 시작점 위치인 N을 원본으로 지칭함&lt;/li>
&lt;/ul>
&lt;h3 id="the-record-header">The record header
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240524152545.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Next Record offset&lt;/p>
&lt;ul>
&lt;li>현재 레코드에서 페이지 내 다음 레코드의 시작점까지의 상대적 오프셋&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Record Type&lt;/p>
&lt;ul>
&lt;li>레코드 유형으로 일반(0), 노드 포인터(1), 최소값(2), 최상위(3)의 4가지 값만 지원됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Order&lt;/p>
&lt;ul>
&lt;li>이 레코드가 힙에 삽입된 순서임&lt;/li>
&lt;li>Infimum, supremum을 포함한 힙 레코드는 0번부터 번호가 매겨짐, Infimum은 항상 0, supremum은 항상 1임&lt;/li>
&lt;li>삽입된 사용자 레코드는 2부터 번호가 매겨짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Number of Records Owned&lt;/p>
&lt;ul>
&lt;li>페이지 디렉토리에서 현재 레코드가 &amp;lsquo;소유&amp;rsquo;한 레코드수&lt;/li>
&lt;li>향후 포스트에서 설명할 예정&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Info Flag&lt;/p>
&lt;ul>
&lt;li>레코드에 대한 boolean flag를 지정하는 4비트 비트맵&lt;/li>
&lt;li>현재 두개의 플래그만 정의도어 있음
&lt;ul>
&lt;li>min_rec(1)는 이 레코드가 B+Tree의 non-leaf에서 최소 레코드임을 의미함&lt;/li>
&lt;li>deleted(2)는 레코드가 삭제 표시되어 있으며, 향후 purge operation에 의해 실제로 삭제될 것임을 의미함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Nullable field bitmap(optional)&lt;/p>
&lt;ul>
&lt;li>필드가 NULL인지 여부를 저장하기 위한 필드, nullable한 필드당 1비트를 사용하고, byte로 반올림됨&lt;/li>
&lt;li>필드가 NULL인 경우 해당 필드 값은 레코드의 키 또는 행부분에서 제거됨&lt;/li>
&lt;li>Null이 필드가 없는 경우 이 비트맵은 존재하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Variable file lengths array(optional)&lt;/p>
&lt;ul>
&lt;li>가변길이 필드당 8비트 또는 16비트 정수 배열(필드의 최대크기에 따라 다름)로 해당 필드에 대한 데이터 길이를 저장&lt;/li>
&lt;li>가변길이 필드가 없는경우, 이 배열은 없음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>record header는 row당 최소 5 byte이며, 가변길이 필드에 의해 더 길어질 수 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="clustered-indexes">Clustered indexes
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240524153758.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>Cluster Key Fields
&lt;ul>
&lt;li>클러스 키 필드는 문자 그대로 함께 연결됨&lt;/li>
&lt;li>InnoDB는 column유형 별 내부 저장소 형식의 raw byte를 단이 바이트 스트림으로 연결하기만 함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Transaction ID
&lt;ul>
&lt;li>이 레코드를 마지막으로 수정한 트랜잭션의 48비트 정수 트랜직션 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Roll Pointer
&lt;ul>
&lt;li>해당 레코드를 마지막으로 수정한 트랜잭션의 undu record의 rollback segment 위치를 포함하고 있는 구조체&lt;/li>
&lt;li>이 필드의 roll pointer 구조는 1비트의 &amp;ldquo;삽입중&amp;rdquo; 플래그, 7비트의 rollback segment ID, 4바이트 페이지 번호, 2바이트의 undo log위치의 페이지 오프셋으로 이루어짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Non-Key Fields
&lt;ul>
&lt;li>기본키가 아닌 실제 행데이터가 단일 바이트 스트림으로 연결되어 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240524160646.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>non-leaf 페이지의 레코드 포맷임&lt;/li>
&lt;li>non-leaf page는 MVCC가 아니기에, Transaction ID와 Roll Pointer filed는 없음&lt;/li>
&lt;li>non-key field 대신에 이 노드 포인터가 가르키는 하위 페이지 번호가 포함됨&lt;/li>
&lt;li>클러스터 키는 NUL이 될 수 없으므로 nullable field bitmap도 없음&lt;/li>
&lt;/ul>
&lt;h3 id="secondary-indexes">Secondary indexes
&lt;/h3>&lt;ul>
&lt;li>InnoDB의 Secondary Index는 clustered key와 전체 구조가 동일하지만, non-key대신 Primary Key Value(PKV)라고 하는 clustered key field를 포함함&lt;/li>
&lt;li>Secondary Index와 clustered key사이에 겹치는 필드가 있는 경우, Secondary Index레코드에 저장된 clustered key에서 겹치는 필드가 제거됨&lt;/li>
&lt;li>예를들어, 테이블에 primary key(a,b,c)와 secondary Index(a,d)가 있는경우, 인덱스 내의 secondary key는 (a,d)가 되지만, PKV에는 (b,c)만 포함됨&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240524161849.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>sendary key fields는 clusterd key와 마찬가지로 단일 바이트 스트림으로 연결됨&lt;/li>
&lt;li>clustered key 필드는 정확한 동일한 방식으로 함께 연결되어 PKV를 만듬&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240524162016.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>Secondary index의 non-leaf page는 PKV가 레코드에 포함되며, 이는 레코드 값이 아닌, 레코드 키의 일부로 간주됨&lt;/li>
&lt;li>Secondary index는 고유하지 않을 수 있지만, 페이지 내의 각 레코드는 unique 식별자가 필요함
&lt;ul>
&lt;li>그러므로 고유성을 보장하기 위해 PKV가 레코드에 포함되어 있어야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>즉, Secondary key의 non-leaf에 있는 레코드는 leaf 페이지의 레코드보다 4바이트 커짐&lt;/li>
&lt;/ul>
&lt;h3 id="row당-오버헤드">row당 오버헤드
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>위의 그림을 보면 InnoDB에 필요한 행당 오버헤드를 쉽게 계산할 수 있음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>clusterd key leaf에는 헤더에 최소 5바이트, 트랜잭션 ID에 6파인트, 롤포인터에 7바이트, row당 총 18바이트가 필요함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>매우 작은 테이블(2-3개의 정수컬럼을 가지는 테이블)의 경우 오버헤드가 상당히 높을 수 있음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>또한 페이지당 오버헤드가 상당하여, 비 효율적으로 페이지를 채우면 많은 야의 공간을 차지할 수 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/" target="_blank" rel="noopener"
>https://blog.jcole.us/2013/01/10/the-physical-structure-of-records-in-innodb/&lt;/a>&lt;/p></description></item><item><title>4-B+tree index structure</title><link>https://sungho94.me/p/4-b-tree-index-structure/</link><pubDate>Mon, 20 May 2024 23:10:14 +0000</pubDate><guid>https://sungho94.me/p/4-b-tree-index-structure/</guid><description>&lt;h2 id="btree-root-leaf-level-용어정리">B+Tree, root, leaf, level 용어정리
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>B+Tree는 InnoDB 인덱스의 구조임&lt;/p>
&lt;/li>
&lt;li>
&lt;p>데이터가 메모리 크기와 일치하지 않아, 디스크에서 읽어야하는 경우 효율적임&lt;/p>
&lt;ul>
&lt;li>트리의 깊이에 따라 요청된 데이터에 엑세스하는데 필요한 최대 읽기 횟수가 고정되어 있어 확장성이 뛰어남&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>인덱스 트리는 트리에 엑세스하기 위한 시작점으로 root 페이지에서 시작됨&lt;/p>
&lt;ul>
&lt;li>root page는 InnoDB의 data dictionary에 영구적으로 저장되어 있음&lt;/li>
&lt;li>트리는 단일 루트 페이지일만큼 작을 수 있고, multi-level tree의 수백만 페이지 일 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>페이지를 leaf(internal)과 non-leaf(node)페이지로 구분함&lt;/p>
&lt;ul>
&lt;li>leaf 페이지에는 실제 행 데이터가 포함됨&lt;/li>
&lt;li>non-leaf페이지는 다른 non-leaf페이지 또는 leaf 페이지를 가지고 있음&lt;/li>
&lt;li>tree는 균형이 잡혀있고, 모든 가지의 깊이는 동일함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>InnoDB는 트리의 각 페이지에 level을 할당함&lt;/p>
&lt;ul>
&lt;li>리프페이지에는 level 0을 할당하고, 트리 위로 올라갈수록 level이 증가함&lt;/li>
&lt;li>root page의 level은 트리의 깊이와 같음&lt;/li>
&lt;li>구분이 중요하지 않은 경우, leaf페이지와 non-leaf페이지는 둘다 internal페이지라고 부름&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="leaf-and-non-leaf-page">Leaf and non-leaf page
&lt;/h2>&lt;ul>
&lt;li>leaf와 non-leaf페이지(Infimum과 supreme을 포함)는 next record의 오프셋을 저장한 &amp;ldquo;next record&amp;quot;포인터를 가지고 있음&lt;/li>
&lt;li>이 연결은 infimum에서 시작하여 모든 레코드를 오름차순으로 연결되며, sumpemum에서 끝남&lt;/li>
&lt;li>레코드는 물리적으로 정렬되어 있지 않고, 링크된 목록에서의 위치가 유일한 순서임
&lt;ul>
&lt;li>insert시 사용 가능한 공간이 있으면 insert됨&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240520232314.png"
loading="lazy"
alt="center"
>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>leaf page의 구조로, 각 레코드의 데이터의 일부로 키가 아닌 값을 가지고 있음&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240520232449.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>non-leaf페이지는 동일한 구조를 가지지만, 데이터로 하위 페이지 번호를 가르키며, 정확한 키 대신 하위페이지의 가장 작은 키를 가짐&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240520232622.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>대부분의 인덱스는 2개 이상의 페이지로 구성되며, 여러 페이지가 오름차순 및 내림차순으로 링크되어 있음&lt;/li>
&lt;li>각각의 페이지는 FIL헤더 안에 이전페이지와 다음 페이지를 가르키는 point를 가지고 있음
&lt;ul>
&lt;li>이로인해 INDEX 페이지들은 동일한 레벨에서 double linked list구조를 가짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240520232907.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>위 그림은 B+Tree내의 단일 index page임&lt;/li>
&lt;/ul>
&lt;h2 id="실제로-살펴보기">실제로 살펴보기
&lt;/h2>&lt;ul>
&lt;li>실제로 그림에서 사용중인 테스트 테이블을 생성하고, 데이터를 삽입해보자!&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t_btree&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">CHAR&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">InnoDB&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t_btree&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s2">&amp;#34;C&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>매우 작고 비현실적이지만, 레코드와 레코드 순회가 어떻게 이루어 지는지 알기 위해 적절한 테이블임&lt;/li>
&lt;/ul>
&lt;h3 id="실제-기본-table-space-파일-구조-확인">실제 기본 table space 파일 구조 확인
&lt;/h3>&lt;ul>
&lt;li>실제 테이블을 확인해보면, 이전에 보았던 테이블들과 같이 FSP_HDR, IBUF_BITMAP, INODE 페이지가 있고, 루트 인덱스가 있는 INDEX페이지, 아직 사용되지 않은 FREE 페이지 2개가 존재함&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-zsh" data-lang="zsh">&lt;span class="line">&lt;span class="cl">$ innodb_space -f t_btree.ibd space-page-type-regions
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">start end count &lt;span class="nb">type&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">1&lt;/span> FSP_HDR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> &lt;span class="m">1&lt;/span> IBUF_BITMAP
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">2&lt;/span> &lt;span class="m">2&lt;/span> &lt;span class="m">1&lt;/span> INODE
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3&lt;/span> &lt;span class="m">3&lt;/span> &lt;span class="m">1&lt;/span> INDEX
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">4&lt;/span> &lt;span class="m">5&lt;/span> &lt;span class="m">2&lt;/span> FREE &lt;span class="o">(&lt;/span>ALLOCATED&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>space-index-pages-summary 명령은 각 페이지에 레코드가 몇개 있는지 알려준다
&lt;ul>
&lt;li>3개가 있을것으로 예상함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-zsh" data-lang="zsh">&lt;span class="line">&lt;span class="cl">$ innodb_space -f t_btree.ibd space-index-pages-summary
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">page index level data free records
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">3&lt;/span> &lt;span class="m">18&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">96&lt;/span> &lt;span class="m">16156&lt;/span> &lt;span class="m">3&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">4&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">16384&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">5&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span> &lt;span class="m">16384&lt;/span> &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="실제-레코드-확인">실제 레코드 확인
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-zsh" data-lang="zsh">&lt;span class="line">&lt;span class="cl">$ innodb_space -f t_btree.ibd -r ./simple_t_btree_describer.rb -d SimpleTBTreeDescriber -p &lt;span class="m">3&lt;/span> page-dump
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>:format&lt;span class="o">=&lt;/span>&amp;gt;:compact,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :offset&lt;span class="o">=&lt;/span>&amp;gt;125,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :header&lt;span class="o">=&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">{&lt;/span>:next&lt;span class="o">=&lt;/span>&amp;gt;157,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :type&lt;span class="o">=&lt;/span>&amp;gt;:conventional,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :heap_number&lt;span class="o">=&lt;/span>&amp;gt;2,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :n_owned&lt;span class="o">=&lt;/span>&amp;gt;0,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :min_rec&lt;span class="o">=&lt;/span>&amp;gt;false,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :deleted&lt;span class="o">=&lt;/span>&amp;gt;false,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :field_nulls&lt;span class="o">=&lt;/span>&amp;gt;nil,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :field_lengths&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="o">[&lt;/span>0, 0, 0, 0&lt;span class="o">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :field_externs&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="o">[&lt;/span>false, false, false, false&lt;span class="o">]}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :next&lt;span class="o">=&lt;/span>&amp;gt;157,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :type&lt;span class="o">=&lt;/span>&amp;gt;:clustered,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :key&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="o">[{&lt;/span>:name&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="s2">&amp;#34;i&amp;#34;&lt;/span>, :type&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="s2">&amp;#34;INT&amp;#34;&lt;/span>, :value&lt;span class="o">=&lt;/span>&amp;gt;0, :extern&lt;span class="o">=&lt;/span>&amp;gt;nil&lt;span class="o">}]&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :transaction_id&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="s2">&amp;#34;0000000f4745&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :roll_pointer&lt;span class="o">=&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">{&lt;/span>:is_insert&lt;span class="o">=&lt;/span>&amp;gt;true, :rseg_id&lt;span class="o">=&lt;/span>&amp;gt;8, :undo_log&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="o">{&lt;/span>:page&lt;span class="o">=&lt;/span>&amp;gt;312, :offset&lt;span class="o">=&lt;/span>&amp;gt;272&lt;span class="o">}}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :row&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="o">[{&lt;/span>:name&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="s2">&amp;#34;s&amp;#34;&lt;/span>, :type&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="s2">&amp;#34;CHAR(10)&amp;#34;&lt;/span>, :value&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>, :extern&lt;span class="o">=&lt;/span>&amp;gt;nil&lt;span class="o">}]}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>:format
&lt;ul>
&lt;li>레코드가 Barracuda 포맷 테이블 내의 compact포맷인것을 의미
&lt;ul>
&lt;li>반대로 Antelope 테이블 내의 redundant가 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>:key
&lt;ul>
&lt;li>인덱스의 키 필드 배열&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>:row
&lt;ul>
&lt;li>키가아닌 필드의 배열&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>:transaction_id and :roll_pointer
&lt;ul>
&lt;li>각 레코드에 포함된 MVCC를 위한 내부 필드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>:header내의 :next
&lt;ul>
&lt;li>실제로는 상대저 오프셋(32)가 들어가며, 편의를 위해 계산된 오프셋이 표시됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="인덱스-재귀">인덱스 재귀
&lt;/h3>&lt;ul>
&lt;li>index-recurse모드를 사용하면 전체 인덱스를 재귀하는 멋지고 간단한 출력을 얻을 수 있음
&lt;ul>
&lt;li>예시는 단일 페이지 인덱스이므로 매우 짧음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-zsh" data-lang="zsh">&lt;span class="line">&lt;span class="cl">$ innodb_space -f t_btree.ibd -r ./simple_t_btree_describer.rb -d SimpleTBTreeDescriber -p &lt;span class="m">3&lt;/span> index-recurse
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ROOT NODE &lt;span class="c1">#3: 3 records, 96 bytes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>0&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">(&lt;/span>&lt;span class="nv">s&lt;/span>&lt;span class="o">=&lt;/span>A&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>1&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">(&lt;/span>&lt;span class="nv">s&lt;/span>&lt;span class="o">=&lt;/span>B&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>2&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">(&lt;/span>&lt;span class="nv">s&lt;/span>&lt;span class="o">=&lt;/span>C&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="간단하지-않은-인덱스-트리-구축">간단하지 않은 인덱스 트리 구축
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240522223300.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>multi level 인덱스는 위와같이 나타남&lt;/li>
&lt;li>이전에 설명했듯이, 모든 페이지는 각각 doubly-linked 되어있고, 각 페이지 안의 레코드들은 오름차순으로 singly-linked되어있음&lt;/li>
&lt;li>Non-leaf페이지는 실제 키보다는 자식의 페이지 넘버를 포함한 포인터를 가지고 있음&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-zsh" data-lang="zsh">&lt;span class="line">&lt;span class="cl">$ innodb_space -f t.ibd -r ./simple_t_describer.rb -d SimpleTDescriber -p &lt;span class="m">3&lt;/span> index-recurse
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ROOT NODE &lt;span class="c1">#3: 2 records, 26 bytes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> NODE POINTER RECORD &amp;gt;&lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>252&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="c1">#36&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> INTERNAL NODE &lt;span class="c1">#36: 1117 records, 14521 bytes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> NODE POINTER RECORD &amp;gt;&lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>252&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="c1">#4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> LEAF NODE &lt;span class="c1">#4: 446 records, 9812 bytes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>1&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>2&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>3&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>4&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;many lines omitted&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> NODE POINTER RECORD &amp;gt;&lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>447&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="c1">#1676&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> LEAF NODE &lt;span class="c1">#1676: 444 records, 9768 bytes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>447&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>448&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>449&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>450&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;many lines omitted&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> NODE POINTER RECORD &amp;gt;&lt;span class="o">=&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>891&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="c1">#771&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> LEAF NODE &lt;span class="c1">#771: 512 records, 11264 bytes&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>891&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>892&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> RECORD: &lt;span class="o">(&lt;/span>&lt;span class="nv">i&lt;/span>&lt;span class="o">=&lt;/span>893&lt;span class="o">)&lt;/span> -&amp;gt; &lt;span class="o">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>10만개의 row를 가지는 간단한 테이블은 위와같은 구조리르 가짐
&lt;ul>
&lt;li>ROOT, INTERNAL, LEAF NODE를 가지고 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>일부 페이지는 완전히 꽉차있으며, 468개의 레코드가 16KB페이지의 거의 15KB를 차지하고 있음을 알 수 있음&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-zsh" data-lang="zsh">&lt;span class="line">&lt;span class="cl">$ innodb_space -f t.ibd -r ./simple_t_describer.rb -d SimpleTDescriber -p &lt;span class="m">36&lt;/span> page-dump
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">{&lt;/span>:format&lt;span class="o">=&lt;/span>&amp;gt;:compact,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :offset&lt;span class="o">=&lt;/span>&amp;gt;125,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :header&lt;span class="o">=&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">{&lt;/span>:next&lt;span class="o">=&lt;/span>&amp;gt;11877,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :type&lt;span class="o">=&lt;/span>&amp;gt;:node_pointer,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :heap_number&lt;span class="o">=&lt;/span>&amp;gt;2,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :n_owned&lt;span class="o">=&lt;/span>&amp;gt;0,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :min_rec&lt;span class="o">=&lt;/span>&amp;gt;true,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :deleted&lt;span class="o">=&lt;/span>&amp;gt;false,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :field_nulls&lt;span class="o">=&lt;/span>&amp;gt;nil,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :field_lengths&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="o">[&lt;/span>0&lt;span class="o">]&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :field_externs&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="o">[&lt;/span>false&lt;span class="o">]}&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :next&lt;span class="o">=&lt;/span>&amp;gt;11877,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :type&lt;span class="o">=&lt;/span>&amp;gt;:clustered,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :key&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="o">[{&lt;/span>:name&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="s2">&amp;#34;i&amp;#34;&lt;/span>, :type&lt;span class="o">=&lt;/span>&amp;gt;&lt;span class="s2">&amp;#34;INT UNSIGNED&amp;#34;&lt;/span>, :value&lt;span class="o">=&lt;/span>&amp;gt;252, :extern&lt;span class="o">=&lt;/span>&amp;gt;nil&lt;span class="o">}]&lt;/span>,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> :child_page_number&lt;span class="o">=&lt;/span>&amp;gt;4&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>위는 non-leaf 페이지임&lt;/li>
&lt;li>:key 배열이 나타나고, 정확한 키보다는 자식레코드의 최소키를 포함하고 있음&lt;/li>
&lt;li>:row 필드가 없으며, child_page_number가 해당 필드를 대신함&lt;/li>
&lt;/ul>
&lt;h3 id="특별한-root-page">특별한 root page
&lt;/h3>&lt;ul>
&lt;li>인덱스가 처음 생성될때 루트페이지가 할당되고, 해당 페이지 번호가 데이터 사전에 저장되므로 루트페이지는 절대 재배치하거나 제거할 수 없음&lt;/li>
&lt;li>루트페이지가 가득 차면, 루트페이지와 두개의 리프 페이지로 구성된 작은 트리를 형성하여 분할해야함&lt;/li>
&lt;li>하지만 루트 페이지 자체는 재배치 할 수 없으므로 분할할 수 없음&lt;/li>
&lt;li>대신 새 빈페이지가 할당되고, 루트 레코드가 그 페이지르 이동되며(루트페이지가 한단계 상향됨) 새페이지가 두개로 분할됨&lt;/li>
&lt;li>그러면 루트페이지는 바로 그 아래 레벨에 하위페이지(node pointer라 부름)로 가득 찰 때까지 다시 분할할 필요가 없으며, 실제로 수천개의 페이지가 될 수 있음&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/" target="_blank" rel="noopener"
>https://blog.jcole.us/2013/01/10/btree-index-structures-in-innodb/&lt;/a>&lt;/p></description></item><item><title>3-InnoDB Index</title><link>https://sungho94.me/p/3-innodb-index/</link><pubDate>Sun, 19 May 2024 22:44:51 +0000</pubDate><guid>https://sungho94.me/p/3-innodb-index/</guid><description>&lt;h2 id="index">Index
&lt;/h2>&lt;ul>
&lt;li>물리적인 인덱스 구조를 알기전, InnoDB에서 Index에 대해 중요하게 알아야하는 아래 3가지에 대해 알아야 함&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>모든 테이블은 primary key를 가지고 있다
&lt;ul>
&lt;li>테이블 생성시 primary key를 설정하지 않는다면, 먼저 non-NULL unique키를 사용하고, 없다면 48bit의 숨겨진 ROW id를 primary key로 사용함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>row data(primary key가 아닌 필드)는 primary key 인덱스 구조 내에 저장됨
&lt;ul>
&lt;li>이를 clustered key라고 명함&lt;/li>
&lt;li>인덱스 구조는 primary key필드에 키가 저장되며 row data는 해당 키에 연결된 값임(MVCC의 경우 추가적인 필드가 포함됨).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Secondary key는 동일한 인덱스 구조에 저장되며, 키는 해당하는 Secondary key이며, 값은 primary임&lt;/li>
&lt;/ol>
&lt;h2 id="index-page-구조">Index page 구조
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240519225801.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>FIL header and trailer
&lt;ul>
&lt;li>모든 페이지 유형에 일반적이고 공통적임&lt;/li>
&lt;li>다른 페이지 유형들과 다른점은, previous page와 next page 포인터가 인덱스 키를 기준으로 동일한 수준의 이전페이지와 다음페이지를 오름차순으로 가르킴&lt;/li>
&lt;li>이로인해 모든 페이지가 이중으로 연결된 double-linked list가 형성됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FSEG header
&lt;ul>
&lt;li>이전 글에서 보았던, index root page의 FSEG헤더에는 포함됨
&lt;ul>
&lt;li>해당 인덱스에서 사용하는 파일 세그먼트에 대한 포인터가 포함되어 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다른 index page는 FSEG header를 사용되지 않고 0으로 채워짐&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>INDEX header
&lt;ul>
&lt;li>Index 페이지 관리와 record관리에 필요한 필드가 포함되어 있음&lt;/li>
&lt;li>자세한 설명은 아래에 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>System records
&lt;ul>
&lt;li>인덱스의 각 페이지에는 infimum과 supremum로 불리는 system record가 존재함&lt;/li>
&lt;li>이러한 레코드들은 페이지의 고정된 장소에 저장되어, 패이지 내에서 바로 접근이 가능함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>User records
&lt;ul>
&lt;li>실제 데이터임&lt;/li>
&lt;li>각 레코드는 가변길이의 헤더와, 실제 데이터 컬럼을 가지고 있음&lt;/li>
&lt;li>헤더에는 오름차순으로 정렬된 singly-linked list를 구현하기 위한 next record 포인터를 포함함&lt;/li>
&lt;li>자세한 설명은 아래에 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>The page directory
&lt;ul>
&lt;li>FIL 트레일러에서 시작하여 페이지의 top에서 아래쪽으로 커지며(메모리 스택과 유사한 구조라고 생각됨), 페이지의 일부 레코드(4~8번째 레코드마다)에 대한 포인터를 포함함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="index-header">INDEX Header
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240519231114.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>Index ID
&lt;ul>
&lt;li>해당 페이지에 속해있는 index의 ID를 의미함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Format Flag
&lt;ul>
&lt;li>해당 페이지 안에있는 record들의 포맷을 의미함
&lt;ul>
&lt;li>Number of Heap Record필드의 상위비트(0x8000)비트에 저장됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>현재 COMPACT와 REDUNDANT가 가능함
&lt;ul>
&lt;li>뒤에 자세히 설명함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Number of Heap Records
&lt;ul>
&lt;li>infimum과 supremum 시스템 레코드, 삭제된garbage records를 포함한 페이지 내의 총 레코드 수를 의미함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Heap Top Position
&lt;ul>
&lt;li>현재 사용된 공간의 마지막 바이트 오프셋을 가르킴&lt;/li>
&lt;li>heap 상단과 page directory의 마지막의 모든 공간은 여유공간임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Garbage Space
&lt;ul>
&lt;li>garbage 레코드안에 있는 삭제된 레코드가 소비한 총 바이트 수를 저장함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Last Insert Position
&lt;ul>
&lt;li>페이지 내의 마지막으로 추가된 레코드의 바이트 오프셋을 저장함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Page Direction
&lt;ul>
&lt;li>현재 LEFT, RIGHT, NO_DIRECTION 세가지 값이 사용됨&lt;/li>
&lt;li>페이지가 순차적으로 insert되는지, 무작위로 insert되는지를 나타냄&lt;/li>
&lt;li>각 insert시 마지막 insert위치의 레코드를 일고, 해당 키를 insert된 레코드 키와 비교하여 insert방향을 결정함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Number of Inserts in Page Direction
&lt;ul>
&lt;li>한번 페이지 방향이 설정된 후 방향을 바꾸지 않은 모든 다음 삽입은 이값을 증가시킴
&lt;ul>
&lt;li>한번 페이지 방향이 설정된 후에 같은 방향으로 insert된 레코들 수를 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Number of Directory Slots
&lt;ul>
&lt;li>페이지 디렉토리의 크기(16바이트 오프셋인 slot의 단위)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Page Level
&lt;ul>
&lt;li>index에서 해당 페이지의 level을 의미&lt;/li>
&lt;li>Leaf 페이의 레벨은 0이고, B+트리를 따라 올라감&lt;/li>
&lt;li>일반적으로 3레벨 B+트리에서 루트는 레벨2, internal non-leaf page중 일부가 level 1, leaf page는 level 0임&lt;/li>
&lt;li>항후 게시글에서 추가로 설명함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="record-format-redundant-vs-compact">Record format: REDUNDANT vs COMPACT
&lt;/h2>&lt;ul>
&lt;li>COMPACT 레코드 형식은, Barracuda테이블의 새로운 형식이고, REDUNDANT레코드 형식은 Antelope테이블의 기존 형식임
&lt;ul>
&lt;li>둘다 Barracuda가 만들어질때까지, 공식적인 이름이 없었음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>COMPACT형식은 각 레코드에 중복 저장되어 data dictionary에 있는 정보(필드수, nullable한 필드, 동적 길이 필드)를 대부부분 제거함&lt;/li>
&lt;/ul>
&lt;h2 id="record-pointer에-대한-추가설명">record pointer에 대한 추가설명
&lt;/h2>&lt;ul>
&lt;li>record pointer는 INDEX Header안에 있는 Last Insert Position field, System record와 user record의 next pointer, page directory안에 있는 모든값 등 여러 다른 위치에서 사용됨&lt;/li>
&lt;li>모든 레코드는 헤더(가변 길이 일수 있는)와 실제 레코드 데이터(가변 길이 일수 있는)를 포함함&lt;/li>
&lt;li>record pointer는 레코드 데이터의 첫번째 바이트 위치를 가르키며, 실제로는 header와 record 데이터 사이에 위치함&lt;/li>
&lt;li>이를 통해 역방향으로 헤더를 읽고, 정방향으로 레코드 데이터를 읽음&lt;/li>
&lt;li>시스템 및 사용자 필드에서 next record pointer를 항상 레코드의 첫번째 필드임
&lt;ul>
&lt;li>이로인해, 항상 가변 width레코드 데이터를 파싱할 필요없이 페이지의 모든 레코드를 매우 효율적으로 읽을 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="system-records-infimum-and-supremum">System records: infimum and supremum
&lt;/h2>&lt;ul>
&lt;li>모든 INDEX 페이지는 고정된 위치에 infimum과 supremum이라는 시스템 레코드가 포함함&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240520221729.png"
loading="lazy"
alt="center"
>&lt;/li>
&lt;li>두 시스템 레코드는 일반적인 헤더를 가지며, infimum과 supremum이 유일한 데이터임
&lt;ul>
&lt;li>데이터를 가지고있는 필드 바로 앞은 다음 레코드 포인터임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="infimum-record">infimum record
&lt;/h3>&lt;ul>
&lt;li>infimum record는 페이지에서 모든 키보다 낮은 값을 나타냄&lt;/li>
&lt;li>&amp;ldquo;next record&amp;quot;포인터는 가장 낮은 키를 가진 사용자 레코드를 가르킴&lt;/li>
&lt;li>infimum은 사용자 레코드를 순차적으로 스캔하기 위한 고정된 진입점 역할을 함&lt;/li>
&lt;/ul>
&lt;h3 id="supremum">supremum
&lt;/h3>&lt;ul>
&lt;li>supremum레코드는 페이지에서 가장 높은 키를 나타냄&lt;/li>
&lt;li>&amp;ldquo;next record&amp;quot;포인터는 항상 0임
&lt;ul>
&lt;li>페이지 헤도로 인해 실제 레코드에 대해서는 항상 NUMM을 나타내며, 위효화지 않은 위치임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>페이지에서 가장 높은 키를 가진 사용자레코드의 &amp;ldquo;next record&amp;quot;포인터는 항상 supremum레코드를 가르킴&lt;/li>
&lt;/ul>
&lt;h2 id="user-records">User records
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>user record의 길고 복잡하기에 자세한 설명은 다음 게시글에서 다룸&lt;/p>
&lt;/li>
&lt;li>
&lt;p>사용자 레코드는 삽입된 순서대로 page body에 추가되며, 각 레코드 헤더의 &amp;ldquo;next record&amp;quot;포인터를 사용하여 키별로 오름차순으로 단일 링크됨&lt;/p>
&lt;ul>
&lt;li>이전에 삭제된 리코드에서 기존 여유공간을 차지 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>단일 링크된 목록은 infimum record부터 오름차순으로 모든 사용자 레코드를 거쳐 supremum으로 끝남&lt;/p>
&lt;/li>
&lt;li>
&lt;p>이 list를 사용하면 한페이지의 모든 사용자 레코드를 오름차순으로 스캔하는 것은 간단함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>또한 FIL헤더의 &amp;ldquo;next page&amp;quot;포인터를 사용하면 전체 인덱스를 오름차순으로 한페이지에서 다른 페이지로 쉽게 스캔 가능&lt;/p>
&lt;ul>
&lt;li>FIL헤더로 인해 오름차순 테이블 스캔도 간단히 구현 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>인덱스 안의 첫번째 page에서 시작
&lt;ul>
&lt;li>이 페이지는 B+트리 탐색을 통해 찾을 수 있음(향후 게시글에서 설명)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>infimum record를 읽고, next record 포인터를 따라감&lt;/li>
&lt;li>record가 supremum이라면 step 5로 이동하고, 아니라면 레코드 내용을 읽고 처리함&lt;/li>
&lt;li>&amp;ldquo;next record&amp;quot;포인터를 따라가 step 3으로 돌아감&lt;/li>
&lt;li>&amp;ldquo;next page&amp;rdquo; 포인터가 NULL을 가르키면 종료하고 아니라면 &amp;ldquo;next page&amp;quot;포인터를 따라 step 2로 돌아감&lt;/li>
&lt;/ol>
&lt;p>*레코드가 doubly-linked가 아닌 singly-linked이므로 내림차순 탐색은 쉽지 않음&lt;/p>
&lt;h2 id="page-directory">Page directory
&lt;/h2>&lt;ul>
&lt;li>page directory는 FIL trailer에서 시작하여 user record방향으로 커짐&lt;/li>
&lt;li>page directory는 4-8개의 레코드 포인터를 가지고 있으며, infimum과 supremum값을 포함함&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240520223401.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>page directory는 단순히 페이지 레코드에 대한 16비트 오프센 포인터인 동적 크기 배열(dynamically-sized array)임&lt;/li>
&lt;li>향후 게시물에 자세하게 설명할 예정&lt;/li>
&lt;/ul>
&lt;h2 id="free-space">Free space
&lt;/h2>&lt;ul>
&lt;li>user record(위쪽으로 증가함)와 page directory(아래로 증가함) 사이의 공간을 free space로 간주함&lt;/li>
&lt;li>두 섹션이 중간에 만나서 여유공간이 소진되면 페이지가 가득 찬것으로 간주함
&lt;ul>
&lt;li>garbage를 제거하기 위한 re-organizing으로 공간을 확보할 수 없을때도 가득 찬것으로 간주함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/" target="_blank" rel="noopener"
>https://blog.jcole.us/2013/01/07/the-physical-structure-of-innodb-index-pages/&lt;/a>&lt;/p></description></item><item><title>2-Page management in Innodb space files</title><link>https://sungho94.me/p/2-page-management-in-innodb-space-files/</link><pubDate>Sun, 12 May 2024 17:45:54 +0000</pubDate><guid>https://sungho94.me/p/2-page-management-in-innodb-space-files/</guid><description>&lt;h2 id="extent">Extent
&lt;/h2>&lt;ul>
&lt;li>64개의 연속된 페이지인 1MiB블록&lt;/li>
&lt;li>space에서 페이지를 관리하려면 복잡하기에, 중간에 Extent를 두어 space는 Extent를 관리하고, Extent에서 page를 관리&lt;/li>
&lt;li>Innodb는 FSD_HDR과 XDES페이지를 고정된 위치에 두어 extent가 사용중인지, extent내의 사용중인 페이지를 추적함&lt;/li>
&lt;/ul>
&lt;h3 id="fsp_hdrxdes-구조-요약">FSP_HDR/XDES 구조 요약
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512174953.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>FIL Header와 trailer, FSP Header와 256개의 extent discriptors(EHSMS descriptors)가 포함됨
&lt;ul>
&lt;li>많은 양의 미사용공간도 포함됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>아래에 더 자세한 설명 있음&lt;/li>
&lt;/ul>
&lt;h3 id="extent-decriptor">Extent decriptor
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512175239.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>File Segment ID
&lt;ul>
&lt;li>extent가 파일 세그먼트에 속할시, extent가 속한 파일 세그먼트 id&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>List node for XDES list
&lt;ul>
&lt;li>double linked extent descriptor 목록의 이전 및 다음 extent를 가르키는 포인터&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>State
&lt;ul>
&lt;li>extent의 현재 상태를 나타냄(4가지 상태가 있음)
&lt;ul>
&lt;li>해당 extent가 동일한 space목록에 속하는 FREE, FREE_FRAG, FULL_FRAG 상태
&lt;ul>
&lt;li>아래에서 자세한 설명&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해당 extent가 파일 세그먼트 ID필드에 저장된 ID를 가진 파일 세그먼트에 속함을 의미하는 FSEG상태&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Page State Bitmap
&lt;ul>
&lt;li>2개의 비트로 페이지가 free한지, clean 한지 나타냄
&lt;ul>
&lt;li>첫번빼 비트는 페이지가 free한지 여부&lt;/li>
&lt;li>두번째 비트는 clean한지 여부
&lt;ul>
&lt;li>현재 사용되지 않는다면 1로 할당됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>extent를 참조하는 다른 구조에서는 extent&amp;rsquo;s descriptor가 있는 FSP_HDR 또는 XDES 페이지 번호와, descriptor entry가 존재하는 페이지의 byte offset을 조합하여 위치를 나타냄
&lt;ul>
&lt;li>page 0 offset 150은 첫번째 페이지에서 150번째 오프셋의 XDES Entry를 참조
&lt;ul>
&lt;li>0-63페이지를 가지고 있는 XDES Entry임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>page 16384 offset 270은 16384페이지에서 270번째 오프셋의 XDES Entry를 참조
&lt;ul>
&lt;li>16576-16639페이지를 가지고 있는 XDES Entry임&lt;/li>
&lt;li>page 16384는 실제로 첫 번째 XDES 페이지를 의미함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="list---free-list">List - free list
&lt;/h2>&lt;ul>
&lt;li>List는 여러 관련 구조를 함께 연결할 수 있는 일반적인 구조체&lt;/li>
&lt;li>2개의 상호보완적인 구조를 사용해서, 디스크상의 이중 링크드 리스트를 구현함&lt;/li>
&lt;/ul>
&lt;h3 id="list-base-node">List base node
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512201648.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>하이레벨구조(FSP헤더와 같은)에서 한번만 저장됨&lt;/li>
&lt;li>리스트의 길이 및 리스트의 처음과 마지막 리스트 노드의 정보를 포함함&lt;/li>
&lt;/ul>
&lt;h3 id="list-node">List Node
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512201700.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>이전과 다음 노드에 대한 포인터를 저장함&lt;/li>
&lt;li>모든 포인터는 페이지 번호(같은 space내에 있는)와 리스트 노드를 찾을 수 있는 해당 페이지 내의 byte offset으로 구성됨&lt;/li>
&lt;li>모든 포인터는 리스트 노드의 시작을 가르킴&lt;/li>
&lt;li>반드시 서로 연결된 구조는 아님&lt;/li>
&lt;/ul>
&lt;h2 id="fsp-header-상세">FSP Header 상세
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512201947.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>Space ID
&lt;ul>
&lt;li>현재 space의 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Highest page number in the space (size)
&lt;ul>
&lt;li>파일이 커짐에 따라, 증가되는 유효한 최대 페이지 수&lt;/li>
&lt;li>space확장은 여러 단계에 걸쳐 이루어지므로, 모든 페이지가 초기화 되지 않음(일부는 0으로 채워질 수 있음)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Highest page number initialized (free limit)
&lt;ul>
&lt;li>FIL헤더가 초기화된 가장 높은 페이지 번호로, 페이지자체에 페이지 번호를 저장함&lt;/li>
&lt;li>free lmit은 항상 이 크기보다 작거나 같음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Flags
&lt;ul>
&lt;li>space와 연관된 플래그&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Next Unused Segment ID
&lt;ul>
&lt;li>다음에 할당될 파일 세그먼트에 사용될 파일 세그먼트 ID&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Number of pages used in the FREE_FRAG list
&lt;ul>
&lt;li>목록의 모든 extents를 순회하지 않고 FREE_FRAG갯수를 확인할 수 있게하기 위한 필드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>다음 extent descriptor list의 List base node도 저장됨
&lt;ul>
&lt;li>FREE_FRAG
&lt;ul>
&lt;li>여유페이지가 남아있는 extent를 나타냄
&lt;ul>
&lt;li>여유 페이지가 있는 extent는 개별 페이지를 다른 용도로 사용 가능함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>예를들어, FSP_HDR 이나 XDES 페이지가 있는 모든 extent는 FREE_FRAG 목록에 배치뒤어 남은 free page를 다른 용도로 할당할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FULL_FRAG
&lt;ul>
&lt;li>FREE_FRAG와 똑같지만, 여유페이지가 없는 extent를 나타냄&lt;/li>
&lt;li>extent가 가득차면 FULL_FRAG로 이동되며, 페이지가 해제되어 가득차 있지 않으면 FREE_FRAG로 이동됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FREE
&lt;ul>
&lt;li>완전히 사용되지 않고, 특정 용도로 전체 할당할 수 있는 extent를 의미함&lt;/li>
&lt;li>FREE extent는 파일세그먼트(적절한 INODE 목록에 배치되기 위해)에 할당되거나, 개별 페이지 사용을 위해 FREE_FRAG목록이로 이동될 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="file-segment-inode">file segment, INODE
&lt;/h2>&lt;ul>
&lt;li>InnoDB는 파일시스템에서 사용하는 file segment, INODE를 오버로드해서 사용함&lt;/li>
&lt;li>InnoDB는 inode를 다음 2가지 유형에 사용함
&lt;ul>
&lt;li>INODE entires(하나의 작은 구조)&lt;/li>
&lt;li>INODE pages(많은 INODE 항목을 포함하는 페이지 유형)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>InnoDB의 INODE는 단순히 file segment(FSEG)를 설명할 뿐이며, 앞으로 &amp;ldquo;file segment INODE&amp;quot;라 칭함&lt;/li>
&lt;/ul>
&lt;h3 id="inode-pages">INODE pages
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512220333.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>각각의 INODE page는 85개의 file segment INODE entries(총 16KiB page)를 포함함
&lt;ul>
&lt;li>각각의 INODE page는 192바이트임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>INODE page는 FSP_HDR의 FSP 헤더 구조에서 설명했던 List node가 있음
&lt;ul>
&lt;li>해당 List node는 INODE pages를 위한 것, 해당 INODE page의 INODE가 아님!&lt;/li>
&lt;li>FREE_INODES
&lt;ul>
&lt;li>적어도 하나의 free file segment INODE entry가 있는 INODE pages의 리스트&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FULL_INODES
&lt;ul>
&lt;li>free file segment INODE entry가 하나도 없는 INODE pages의 리스트&lt;/li>
&lt;li>file per table space를 사용하는 경우, 테이블에 42개 이상의 인덱스가 없는 한 각 file per table space 안에 있는 해당 목록은 비어있음
&lt;ul>
&lt;li>각각의 index는 정확히 두개의 file segment INODE entry를 사용하기 때문&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="inode-entry">INODE ENTRY
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512231201.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>필드 설명
&lt;ul>
&lt;li>File Segment ID
&lt;ul>
&lt;li>file segment ID는 해당 file segment INODE entry를 의미함&lt;/li>
&lt;li>ID가 0이면 해당 entry는 사용되지 않은 것을 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Magic Number
&lt;ul>
&lt;li>값이 97937874이면 file segment INODE entry가 초기화 되었다는 것을 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Number of used pages in the NOT_FULL list
&lt;ul>
&lt;li>space의 FREE_FLAG list(FSP header에 있는)와 정확히 같음&lt;/li>
&lt;li>NOT_FULL 리스트 수 빠르게 확인할 수 있게 하기 위한 필드&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Fragment Array
&lt;ul>
&lt;li>space에 있는 FREE_FRAG 또는 FULL_FRAG 리스트(&amp;ldquo;fragment&amp;quot;의 extent) 안의 extent로부터 개별적으로 할당된 32페이지의 배열&lt;/li>
&lt;li>해당 array가 꽉 차면, 오직 full extents만 file segment에 할당될 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>table이 커지면 각 file segment는 배열이 가득 찰때까지, 각 file segment에 개별 pages들을 할당하고, 이후 1개의 extent를 할당함, 결국에는 4개의 extent가 할당됨&lt;/li>
&lt;li>extent descriptors의 list base node또한 각각의 file segment INODE entry에 나타남
&lt;ul>
&lt;li>FREE
&lt;ul>
&lt;li>완전히 사용되지 않고, 해당 file segment에 할당된 extents&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>NOT_FULL
&lt;ul>
&lt;li>해당 file segment에 할당된 사용된 페이지가 하나 이상 있는 extents&lt;/li>
&lt;li>마지막 사용가능한 페이지가 사용되면, extents는 FULL list로 이동함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>FULL
&lt;ul>
&lt;li>해당 file segment에 할당된 사용가능한 페이지가 없는 extent&lt;/li>
&lt;li>페이지가 여유가 생기면, NOT_FULL 목록이도 이동함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>마지막으로 사용된 page가 NOT_FULL 목록의 범위에서 해제되면, 해당 extent는 file segment&amp;rsquo;s의 FREE로 이동될 수 있지만, 실제로는 space의 FREE list로 이동됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="index는-어떻게-file-segments를-사용할까">Index는 어떻게 file segments를 사용할까
&lt;/h2>&lt;ul>
&lt;li>인덱스 페이지에 대한 설명은 없지만, 한가지 작은 측면을 살펴볼 수 있음&lt;/li>
&lt;li>각 인덱스의 FSEG의 루트페이지는 인덱스에서 사용하는 파일 세그먼트를 설명하는 file segment INODE entry에 대한 포인터가 포함되어 있음&lt;/li>
&lt;li>각 인덱스는 leaf페이지에 하나의 세그먼트와, non-leaf페이지에 하나의 파일 세그먼트를 사용함&lt;/li>
&lt;li>이 정보는 FSEG header 구조에 저장되어 있음&lt;br>
&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512234447.png"
loading="lazy"
alt="center"
>&lt;/li>
&lt;li>space ID는 불필요한 것으로, 항상 현재 sapce와 동일함&lt;/li>
&lt;li>page number와 offset은 file segment INODE entry를 가르킴&lt;/li>
&lt;li>두 파일 세그먼트는 완전히 비어있어도 항상 존재함
&lt;ul>
&lt;li>예를 들면 새로 만든 테이블에서 존재하는 페이지는 루트페이지이며 리프페이지 이기도 하지만, internal file segment에 존재하므로 나중에 옮길 필요가 없음&lt;/li>
&lt;li>leaf file segment의INODE list와 fragment는 모두 비어있음&lt;/li>
&lt;li>internal file segment INODE list는 모두 비어있고, 단일 루트 페이지는 fragment array에 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="인덱스에-대한-전체-multi-level">인덱스에 대한 전체 multi level
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240512234938.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>index root pages는 두개의 inodes(file segment)를 가르키며, 각각은 fragment array(fragment list에서 최대 32개의 개별 페이지를 가르킴)전체 extents 목록(extent descriptor의 리스트 포인터를 사용하여 연결된)을 가짐&lt;/li>
&lt;li>extent descriptor는 extent를 참조할 뿐 아니라, extent내 free page를 추적하는 데도 사용됨&lt;/li>
&lt;/ul>
&lt;p>참고&lt;br>
&lt;a class="link" href="https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/" target="_blank" rel="noopener"
>https://blog.jcole.us/2013/01/04/page-management-in-innodb-space-files/&lt;/a>&lt;br>
&lt;a class="link" href="https://dev.mysql.com/blog-archive/innodb-tablespace-space-management/" target="_blank" rel="noopener"
>https://dev.mysql.com/blog-archive/innodb-tablespace-space-management/&lt;/a>&lt;br>
&lt;a class="link" href="https://dev.mysql.com/blog-archive/extent-descriptor-page-of-innodb/" target="_blank" rel="noopener"
>https://dev.mysql.com/blog-archive/extent-descriptor-page-of-innodb/&lt;/a>&lt;/p></description></item><item><title>1-page, space, idb file structure</title><link>https://sungho94.me/p/1-page-space-idb-file-structure/</link><pubDate>Fri, 10 May 2024 22:40:29 +0000</pubDate><guid>https://sungho94.me/p/1-page-space-idb-file-structure/</guid><description>&lt;h2 id="page">Page
&lt;/h2>&lt;ul>
&lt;li>각 스페이스는 16KiB의 페이지로 나누어짐
&lt;ul>
&lt;li>UNIV_PAGE_SIZE를 변경하거나, InnoDB 압축을 사용하는경우 변경 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>오프셋 이라고하는 32bit 정수 페이지 번호가 할당됨&lt;/li>
&lt;li>파일의 시작부분부터 해당 페이지 위치까지의 실제 오프셋임&lt;/li>
&lt;li>페이지 0은 파일 오프셋 0, 페이지1은 오프셋은 16384(16*1024)임&lt;/li>
&lt;/ul>
&lt;h3 id="페이지-구조">페이지 구조
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240511112606.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>각 페이지는 38바이트의 FIL(file의 줄임말) header와 FIL Trailer를 가지고 있음&lt;/li>
&lt;li>헤더에는 페이지의 남은 부분을 결정하는 page type 필드를 포함하고 있음&lt;/li>
&lt;/ul>
&lt;h3 id="fil-header--trailer">FIL Header / Trailer
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240511112813.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>page type은 페이지의 다른 부분을 파싱하기 위해 필수적인 부분임
&lt;ul>
&lt;li>page type은 file space management, extent management, the transaction system, the data dictionary, undo logs, blobs, indexes가 할당될 수 있음&lt;/li>
&lt;li>페이지는 앞서 나열한 페이지가 될 수 있다는것을 의미함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>페이지가 초기화 될때, page number(Offset)이 할당됨
&lt;ul>
&lt;li>해당 필드에서 읽은 페이지번호가 파일에 오프셋을 기준으로 해야하는 페이지 번호가 일치하는지 확인하여, 읽기가 올바른지 확인함&lt;/li>
&lt;li>이 필드가 초기화되면 페이자가 초기화되었다는 것을 의미함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>해당 페이지의 유형과 같은 이전 페이지와 다음페이지 포인터가 헤더가 저장되어 있음
&lt;ul>
&lt;li>이 필드들로 페이지를 double-linked list 구조가 됨&lt;/li>
&lt;li>인덱스 페이지를 동일한 수순으로 연결하는데 사용되므로 전체 인덱스 스캔을 효율적으로 수행할 수 있음&lt;/li>
&lt;li>대부분의 페이지 유형은 이 필드들을 사용하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="space---tablespace">Space - tablespace
&lt;/h2>&lt;ul>
&lt;li>각 테이블당 하나의 space가 존재&lt;/li>
&lt;li>하나의 스페이스는 .idb파일로 구성됨
&lt;ul>
&lt;li>하나 이상의 idb파일로 구현 될 수 있음&lt;/li>
&lt;li>물리적으로 하나 이상의 파일이지만, 논리적으로 단일파일 취급함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>.idb파일은 하나의 테이블에 대한 정보가 들어감
&lt;ul>
&lt;li>하나의 .idb파일에 여러 테이블이 들어갈 수 있는 구조지만, 하나의 테이블만 넣음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>space별로 32bit 정수인 space ID가 할당됨
&lt;ul>
&lt;li>해당 space를 참조할 목적&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>InnoDB는 InnoDB에서 필요로 하는 장부(book-keeping)를 작성하기 위해 system space를 가지고 있음
&lt;ul>
&lt;li>system space의 space ID는 0임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>많은 페이지가 연결된것&lt;/li>
&lt;li>효율적으로 페이지를 관리하기 위헤 1MiB 블록 단위로 페이지를 관리함
&lt;ul>
&lt;li>이를 extent라 부름&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>파티션을 나누면 각각의 space가 나누어짐&lt;/li>
&lt;/ul>
&lt;h3 id="space-file-구조">Space File 구조
&lt;/h3>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240511225238.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>Innodb는 모든 page, extent, space를 추적-관리하기 해야하므로 위와같은 구조를 가짐&lt;/li>
&lt;li>space의 첫번째 페이지(page 0)은 항상 FSP_HDR 또는 file space header 페이지임&lt;/li>
&lt;li>FSP_HDR페이지는 space의 크기, free, fragmented, full extents의 목록을 추적할 수 있는 FSP header 구조를 포함하고 있음&lt;/li>
&lt;li>FSP_HDR페이지는 내부적으로 256 extents(또는 16384페이지, 256MiB)에 대한 정보를 저장 가능함
&lt;ul>
&lt;li>그러므로 256extents마다 XDES정보를 저장하기 위해 공간을 미리 예약해놓음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>XDES와 FSP_HDR페이지는 XDES에서 FSP해더 구조가 0으로 처리된다는 점을 제외하면 동일함&lt;/li>
&lt;li>추가페이지는 스페이스 파일이 커짐에 따라 할당됨&lt;/li>
&lt;li>두번째페이지인 IBUF_BITMAP페이지는 insert buffering과 관련된 정보를 저장함(이 글의 범위를 벗어나는 부분이라 더 이상 언급하지 않음)&lt;/li>
&lt;li>세번째 페이지인 INODE페이지는 파일 세그먼트와 관련된 목록을 저장하는데 사용됨
&lt;ul>
&lt;li>각 INODE페이지에는 85개의 INODE항목을 저장할 수 있으며, 각 인덱스에는 2개의 INODE항목이 필요함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="system-space">System space
&lt;/h3>&lt;ul>
&lt;li>InnoDB에는 space ID가 0인 system space가 존재함&lt;/li>
&lt;li>InnoDB의 작동에 중요한 정보를 저장하기 위해 고정 페이지 번호로 할당된 페이지가 포함되어 있음&lt;/li>
&lt;li>다른공간과 마찬가지로 FSP_HDR, IBUF_BITMAP, INODE페이지가 처음 3페이지로 할당되어 있음&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240511231613.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>3번째 SYS페이지에는 insert buffering에 관련된 헤더와 부기정보가 있음&lt;/li>
&lt;li>4번째 INDEX페이지에는 insert buffering에 관련된 index구조의 루트 페이지가 존재&lt;/li>
&lt;li>5번째 TRX_SYS페이지에는 InnodDB의 트랜잭션 시스템의 동작과 관련된 정보가 존재함
&lt;ul>
&lt;li>최신 transaction ID, Mysql binary log정보, double write buffer extents의 위치 등&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>6번째 SYS페이지에는 첫번째 롤백 segment page정보가 있음
&lt;ul>
&lt;li>rollback segment data의 저장이 필요하다면, 추가적인 페이지가 할당될 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>7번째 SYS페이지에는 data dictionary와 관련된 헤더가 있음
&lt;ul>
&lt;li>data dictionary를 구성하는 인덱스의 루트 페이지 번호를 포함함&lt;/li>
&lt;li>루트 페이지 번호가 data dictionary 자체에 저장되므로,다른 인덱스를 찾기 위해 필요함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>64-127번째 페이지에는 double write buffer에 저장됨&lt;/li>
&lt;li>128-192번째 페이지에는 두번째 double write buffer&lt;/li>
&lt;/ul>
&lt;h2 id="ibd-파일-구조">IBD 파일 구조
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020240511233507.png"
loading="lazy"
alt="center"
>&lt;/p>
&lt;ul>
&lt;li>런타임에 인덱스를 생성하는 fast index creation을 제외하고, 필수 초기 3페이지 이후 공간에 할당된 페이지들은 테이블 생성에 정의된 순서대로 테이블에 있는 각 인덱스 루트 페이지가 됨&lt;/li>
&lt;li>3번째 페이지는 clustered index의 루트페이지, 4번째 페이지는 첫번째 secondary index의 루트페이지임&lt;/li>
&lt;li>InnoDB의 부기 구조는 대부분 시스템 공간에 저장되므로, 테이블별 공간에 할당된 대부분의 페이지는 INDEX유형이며, 테이블 데이터를 저장함&lt;/li>
&lt;/ul>
&lt;p>참고&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/" target="_blank" rel="noopener"
>https://blog.jcole.us/2013/01/03/the-basics-of-innodb-space-file-layout/&lt;/a>&lt;/p></description></item><item><title>Mysql Explain Plan(Extra Information) - 3</title><link>https://sungho94.me/p/mysql-explain-planextra-information-3/</link><pubDate>Fri, 03 May 2024 23:35:47 +0000</pubDate><guid>https://sungho94.me/p/mysql-explain-planextra-information-3/</guid><description>&lt;ul>
&lt;li>Extra 열에는 Mysql에서 쿼리를 resolve하기 위한 추가적인 정보가 들어감&lt;/li>
&lt;li>여기서는 추가적인 정보 중 유용하다고 생각되는 정보를 정리할 예정&lt;/li>
&lt;li>전체 정보는 다음 [링크]를 참고할것&lt;/li>
&lt;/ul>
&lt;h2 id="using-file-sort">Using file sort
&lt;/h2>&lt;ul>
&lt;li>정렬된 순서로 행을 찾기 위해 추가적인 작업이 필요하다는 것을 의미함&lt;/li>
&lt;li>정렬은 조인 유형에 따라 모든 행을 살펴보고, Where 절과 일치하는 모든 행에 대해 정렬키와 포인터를 저장하는 방식으로 수행됨
&lt;ul>
&lt;li>이후 키가 정렬되고 정렬된 순서대로 행을 검색함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>부하가 많이 걸리는 부분으로 개선이 필요함&lt;/li>
&lt;/ul>
&lt;h2 id="using-index">Using index
&lt;/h2>&lt;ul>
&lt;li>커버링 인덱스가 사용되었음을 의미함&lt;/li>
&lt;li>실제 테이블데이터를 읽지 않고, 인덱스만 조회함&lt;/li>
&lt;li>쿼리가 하나의 인덱스에서 조회에 필요한 모든 데이터를 가지고 있을 경우 사용됨&lt;/li>
&lt;/ul>
&lt;h2 id="using-index-condition">Using index condition
&lt;/h2>&lt;ul>
&lt;li>인덱스를 먼저 읽은 후 필요할 경우 테이블 데이터를 읽음&lt;/li>
&lt;li>테이블 데이터를 필요할때 까지 읽는것을 미룸&lt;/li>
&lt;li>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener"
>링크&lt;/a>참고&lt;/li>
&lt;/ul>
&lt;h2 id="using-index-for-group-by">Using index for group-by
&lt;/h2>&lt;ul>
&lt;li>Using index와 유사하게, 실제 테이블데이터를 읽지않고 인덱스에서 group by 또는 distinct에 필요한 모든 열을 찾았음을 의미&lt;/li>
&lt;li>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html" target="_blank" rel="noopener"
>그룹바이 최적화&lt;/a>참고&lt;/li>
&lt;/ul>
&lt;h2 id="using-join-buffer-block-nested-loopusing-join-buffer-batched-key-accessusing-join-buffer-hash-join">Using join buffer (Block Nested Loop), Using join buffer (Batched Key Access), Using join buffer (hash join) 
&lt;/h2>&lt;ul>
&lt;li>이전 조인 테이블을 버퍼에서 부분적으로 읽은 후 버퍼데이터와 해당 테이블의 조인을 실행함&lt;/li>
&lt;li>각 buffer는 괄호안의 알고리즘을 사용함&lt;/li>
&lt;/ul>
&lt;h2 id="using-temporary">Using temporary
&lt;/h2>&lt;ul>
&lt;li>해당 쿼리를 수행하기 위해서 임시 테이블이 사용됨을 의미&lt;/li>
&lt;li>주로 GROUP by나 order by를 사용하는 쿼리에서 보여짐&lt;/li>
&lt;/ul>
&lt;h2 id="using-where">Using where
&lt;/h2>&lt;ul>
&lt;li>where절을 사용하여 행을 제한한것을 의미함&lt;/li>
&lt;li>모든 행을 가져오는 경우가 아니라면, using where이 사용되지 않으면서 join type이 ALL이나 index이면 쿼리에 문제가 있는 것일 수 있음&lt;/li>
&lt;/ul>
&lt;h2 id="using-index-for-skip-scan">Using index for skip scan
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">INT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f2&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">40&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ANALYZE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">EXPLAIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f1&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">f2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">40&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>11번 라인의 쿼리문이 실행되면 Using index for skip scan이 적용됨&lt;/li>
&lt;li>11번 라인의 쿼리는 인덱스가 f1, f2가 걸려있는데, f2만 사용해서 조건을 걸었음
&lt;ul>
&lt;li>f1만을 사용하거나, f1, f2를 사용하면 Using Index로 나타남&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>11번 쿼리는 f1의 인덱스는 뛰어넘고, f2 인덱스 만 사용해서 결과를 가져옴&lt;/li>
&lt;li>f1의 인덱스에서 고유값을 찾고, 고유값마다 f2의 인덱스에 걸린 조건을 찾아 결과를 가져옴
&lt;ul>
&lt;li>단일 인덱스에 대한 여러 개별 검색이 이루어지고, 결합시 접두사 열의 영향이 제거됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="using-join-bufferblock-nested-loop-hash-join">Using join buffer(Block Nested Loop, hash join)
&lt;/h2></description></item><item><title>Mysql Explain Plan(조인타입) - 2</title><link>https://sungho94.me/p/mysql-explain-plan%EC%A1%B0%EC%9D%B8%ED%83%80%EC%9E%85-2/</link><pubDate>Fri, 03 May 2024 23:34:03 +0000</pubDate><guid>https://sungho94.me/p/mysql-explain-plan%EC%A1%B0%EC%9D%B8%ED%83%80%EC%9E%85-2/</guid><description>&lt;h2 id="조인타입">조인타입
&lt;/h2>&lt;p>먼저에 나올수록 성능이 좋음&lt;/p>
&lt;ul>
&lt;li>
&lt;p>system&lt;/p>
&lt;ul>
&lt;li>테이블이 하나의 row만 가지고 있을때 표시됨&lt;/li>
&lt;li>const join타입의 특별한 케이스임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>const&lt;/p>
&lt;ul>
&lt;li>쿼리시작시 결과가 오직 하나일때 표시됨&lt;/li>
&lt;li>결과가 하나의 row일 경우, 컬럼의 값은 옵티마이저에 의해 상수로 처리됨&lt;/li>
&lt;li>const 테이블은 오직 한번만 읽기에 매우 빠름&lt;/li>
&lt;li>기본키 또는 UNIQUE 인덱스의 모든 부분을 상수값과 비교될때 표시됨&lt;/li>
&lt;li>예제 쿼리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_tbl_name_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_primary_key_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_tbl_name_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_primary_key_part1_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_primary_key_part2_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>eq_ref
&lt;ul>
&lt;li>const와 system을 제외하고는 가장 최상의 join&lt;/li>
&lt;li>이전 테이블에서 가져온 행 조합마다 해당 테이블에서 정확히 한 행을 읽음&lt;/li>
&lt;li>인덱스의 모든 부분이 join에 사용되며, 인덱스가 기본키 또는 유니크키+not null조합이면서 &lt;code>=&lt;/code>를 사용하여 비교될때 사용됨&lt;/li>
&lt;li>비교하는 값은 상수이거나, 이전에 읽은 테이블의 컬럼 사용&lt;/li>
&lt;li>예제쿼리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">_other_table_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_key_column_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">_other_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_column_&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">_other_table_&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_key_column_part1_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">_other_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_column_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_key_column_part2_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>ref
&lt;ul>
&lt;li>이전 테이블에 가져온 행 조합마다일치하는 모든 인덱스를 읽음&lt;/li>
&lt;li>키의 접두사만 읽거나, 키가 기본키나 유니크키가 아닐 경우 사용됨
&lt;ul>
&lt;li>정확히 하나의 row를 반환하지 않는 경유를 의미&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>키에 해당하는 행이 적은경우, 충분히 좋은 join 방법임&lt;/li>
&lt;li>&lt;code>=&lt;/code>이거나 &lt;code>&amp;lt;=&amp;gt;&lt;/code>일때 사용됨&lt;/li>
&lt;li>예제쿼리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_key_column_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">_expr_&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">_other_table_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_key_column_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">_other_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_column_&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">_other_table_&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_key_column_part1_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">_other_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_column_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">_key_column_part2_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>fulltext&lt;/p>
&lt;ul>
&lt;li>FULLTEXT인덱스를 사용할때 사용됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>ref_or_null&lt;/p>
&lt;ul>
&lt;li>ref와 유사하지만, null을 포함하는 행의 질의를 할때 사용됨&lt;/li>
&lt;li>subquery를 처리할때 자주 표시됨&lt;/li>
&lt;li>예제쿼리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_ref_table_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_key_column_&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">_expr_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_key_column_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>index_merge&lt;/p>
&lt;ul>
&lt;li>인덱스 병합 최적화일때 사용됨&lt;/li>
&lt;li>이 경우 Explain의 key column에는 사용된 인덱스 목록이 포함되며, key_len에는 가장 긴 인덱스의 키 목록이 표함됨&lt;/li>
&lt;li>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/index-merge-optimization.html" target="_blank" rel="noopener"
>링크&lt;/a>참고&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>unique_subquery&lt;/p>
&lt;ul>
&lt;li>IN절 내의 eq_ref 서브쿼리의를 대체함&lt;/li>
&lt;li>효율성을 높이기 위해 서브쿼리를 대체하여 인덱스만 조회함&lt;/li>
&lt;li>예제쿼리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">primary_key&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">single_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">some_expr&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>index_subquery
&lt;ul>
&lt;li>unique_subquery와 유사하지만, non-unique 서브쿼리일때 사용됨&lt;/li>
&lt;li>예제쿼리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key_column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">single_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">some_expr&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>range
&lt;ul>
&lt;li>인덱스로 범위질의를 사용시 사용됨&lt;/li>
&lt;li> =, &amp;lt;&amp;gt;, &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, IS NULL, &amp;lt;=&amp;gt;, BETWEEN, LIKE, IN() 연산자를 사용하여 상수 값과 비교할때 나타남&lt;/li>
&lt;li>key_len에는 사용된 키 중 가장 긴키의 길이를 표시함&lt;/li>
&lt;li>예제쿼리&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tbl_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key_column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tbl_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key_column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BETWEEN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">and&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tbl_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key_column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">30&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tbl_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key_part1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AND&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">key_part2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">IN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">30&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">```&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">index&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">트리가&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">스캔되는&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">것을&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">제외하면&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ALL과&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">동일함&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">아래&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">두가지&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">경우에&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">나타남&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">쿼리가&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">커버링&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스이고&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">테이블에서&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">필요한&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">모든&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">데이터를&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스에서&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">가져올&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">수&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">있는&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">경우&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">트리만&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">스캔함&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Extra&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">column에&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Using&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Index라고&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">나타남&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">index&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Only&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">스캔은&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스만&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">스캔하므로&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">모든&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">테이블&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">데이터를&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">스캔하는&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ALL보다&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">항상&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">빠름&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스를&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">사용하여&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">모든&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">테이블&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">데이터를&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">순서대로&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">접근하는&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">경우&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Extra&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">column에&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Using&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Index라고&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">나타나지&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">않음&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">쿼리가&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">단일&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">인덱스의&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">일부&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">열만&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">사용하는&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">경우&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">이&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">조인&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">유형이&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">나타남&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ALL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">이전의&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">모든&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">테이블&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">행&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">조합마다&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">테이블&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">전체&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">테이블을&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">스캔함&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">거의&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">모든&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">경우&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">좋지않음&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">index를&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">추가하여&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">피할&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">수&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">있음&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>Mysql Explain Plan - 1</title><link>https://sungho94.me/p/mysql-explain-plan-1/</link><pubDate>Tue, 30 Apr 2024 22:35:11 +0000</pubDate><guid>https://sungho94.me/p/mysql-explain-plan-1/</guid><description>&lt;h2 id="개요">개요
&lt;/h2>&lt;ul>
&lt;li>Explain 문은 Mysql이 어떻게 statements를 실행할것인가에 대한 정보를 제공
&lt;ul>
&lt;li>select, delete, insert, replace, update문에 적용 가능&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>출력에 테이블이 나열되는 순서는, Mysql이 statements를 처리하는 동안 테이블을 읽는 순서임
&lt;ul>
&lt;li>첫번째 테이블에서 행을 읽고, 두번째테이블에서 일치하는 행을 찾고, 세번째에서 또 찾는 방식임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>모든 테이블이 처리되면 Mysql은 선택한 열을 출력하고, 더 많은 행을 찾기 찾을 때 까지 테이블 목록을 역추적함&lt;/li>
&lt;/ul>
&lt;h2 id="explain-output-columns">Explain Output Columns
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">Column&lt;/th>
&lt;th style="text-align: left">JSON Name&lt;/th>
&lt;th style="text-align: left">Meaning&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">id&lt;/td>
&lt;td style="text-align: left">select_id&lt;/td>
&lt;td style="text-align: left">Select 식별자&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">select_type&lt;/td>
&lt;td style="text-align: left">None&lt;/td>
&lt;td style="text-align: left">Select Type&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">table&lt;/td>
&lt;td style="text-align: left">table_name&lt;/td>
&lt;td style="text-align: left">결과 행을 가져오는 테이블&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">partitions&lt;/td>
&lt;td style="text-align: left">partitions&lt;/td>
&lt;td style="text-align: left">매칭되는 파티션&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">type&lt;/td>
&lt;td style="text-align: left">access_type&lt;/td>
&lt;td style="text-align: left">join 유형&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">possible_keys&lt;/td>
&lt;td style="text-align: left">possible_keys&lt;/td>
&lt;td style="text-align: left">선택될 수 있는 인덱스&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">key&lt;/td>
&lt;td style="text-align: left">key&lt;/td>
&lt;td style="text-align: left">실제로 선택된 인덱스&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">key_len&lt;/td>
&lt;td style="text-align: left">key_length&lt;/td>
&lt;td style="text-align: left">선택된 키의 길이&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">ref&lt;/td>
&lt;td style="text-align: left">ref&lt;/td>
&lt;td style="text-align: left">인덱스와 비교한 열&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">rows&lt;/td>
&lt;td style="text-align: left">rows&lt;/td>
&lt;td style="text-align: left">예상되는 행의 추정치&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">filtered&lt;/td>
&lt;td style="text-align: left">filtered&lt;/td>
&lt;td style="text-align: left">테이블 조건에 따라 필터링된 행의 비율&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">Extra&lt;/td>
&lt;td style="text-align: left">None&lt;/td>
&lt;td style="text-align: left">추가정보&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="id">id
&lt;/h2>&lt;ul>
&lt;li>Select의 식별자로, 쿼리 내 Select의 일련 번호&lt;/li>
&lt;li>다른행 의 유니온 결과를 참조하는 경우 Null일수 있음
&lt;ul>
&lt;li>이 경우 table Column은 &amp;lt;union M,N&amp;gt; 으로 나타남&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="select_type">select_type
&lt;/h2>&lt;ul>
&lt;li>Select의 유형으로 다음 표에 나타나는 것중 하나가 들어감&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">select_type&lt;/th>
&lt;th style="text-align: left">JSON Name&lt;/th>
&lt;th style="text-align: left">Meaning&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">SIMPLE&lt;/td>
&lt;td style="text-align: left">None&lt;/td>
&lt;td style="text-align: left">서브쿼리나 Union을 사용하지 않은 간단한 Select&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">PRIMARY&lt;/td>
&lt;td style="text-align: left">None&lt;/td>
&lt;td style="text-align: left">가장 바깥쪽의 SELECT&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">UNION&lt;/td>
&lt;td style="text-align: left">None&lt;/td>
&lt;td style="text-align: left">UNION으로 결합하는 첫번째를 제외한 두번째 이후의 쿼리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">DEPENDENT UNION&lt;/td>
&lt;td style="text-align: left">dependent (true)&lt;/td>
&lt;td style="text-align: left">UNION으로 결합하는 첫번째를 제외한 두번째 이후의 쿼리이지만 외부 쿼리의 영향을 받는 Select&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">UNION RESULT&lt;/td>
&lt;td style="text-align: left">union_result&lt;/td>
&lt;td style="text-align: left">UNION의 결과일때&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">SUBQUERY&lt;/td>
&lt;td style="text-align: left">None&lt;/td>
&lt;td style="text-align: left">Subquery의 첫번째 결과, From절 이외에서 사용되는 서브쿼리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">DEPENDENT SUBQUERY&lt;/td>
&lt;td style="text-align: left">dependent (true)&lt;/td>
&lt;td style="text-align: left">외부 쿼리에 의존하는 Subquery의 첫번째 결과,&lt;br>From절 이외에서 사용되는 서브쿼리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">DERIVED&lt;/td>
&lt;td style="text-align: left">None&lt;/td>
&lt;td style="text-align: left">Select쿼리의 실행결과로 메모리나 디스크에 임시 저장되는 정보&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">DEPENDENT DERIVED&lt;/td>
&lt;td style="text-align: left">dependent (true)&lt;/td>
&lt;td style="text-align: left">다른 테이블에 의존하고 있는 DERIVED 테이블&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">MATERIALIZED&lt;/td>
&lt;td style="text-align: left">materialized_from_subquery&lt;/td>
&lt;td style="text-align: left">서브쿼리의 내용을 임시테이블로 구체화 할때 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">UNCACHEABLE SUBQUERY&lt;/td>
&lt;td style="text-align: left">cacheable (false)&lt;/td>
&lt;td style="text-align: left">결과를 캐시할 수 없고, 외부 쿼리의 각 row에 대해 재평가가 필요한 데이터에 일때 표시됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">UNCACHEABLE UNION&lt;/td>
&lt;td style="text-align: left">cacheable (false)&lt;/td>
&lt;td style="text-align: left">캐시를 할 수 없는 서브쿼리를 포함하는, 첫번째를 제외한 두번째 이후의 UNION select일 경우 표시됨&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>select쿼리가 아닌 CUD쿼리는 해당 statements의 종류가 표시됨
&lt;ul>
&lt;li>DELETE일 경우, select_type에는 DELETE를 표시&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="table">table
&lt;/h2>&lt;ul>
&lt;li>각 행의 결과를 가져오는 테이블의 이름&lt;/li>
&lt;li>&amp;lt;union&lt;code>M&lt;/code>,&lt;code>N&lt;/code>&amp;gt;
&lt;ul>
&lt;li>id(Explain의 id 컬럼)가 M과 N인 행의 UNION결과를 나타냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;lt;derived&lt;code>N&lt;/code>&amp;gt;
&lt;ul>
&lt;li>id(Explain의 id 컬럼)가 N인 쿼리의 결과로 파생된 행&lt;/li>
&lt;li>derived테이블은 FROM에 있는 서브쿼리의 결과임&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;lt;subquery&lt;code>N&lt;/code>&amp;gt;
&lt;ul>
&lt;li>id(Explain의 id 컬럼)가 N인 행에 대한 구체화된 subquery의 결과를 나타냄&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="subquery-mareirialzied-최적화-링크httpsdevmysqlcomdocrefman80ensubquery-materializationhtml">subquery mareirialzied 최적화 &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/subquery-materialization.html" target="_blank" rel="noopener"
>링크&lt;/a>
&lt;/h3>&lt;h2 id="partitions">partitions
&lt;/h2>&lt;ul>
&lt;li>쿼리에 의해 매치된 파티션을 나타냄&lt;/li>
&lt;li>파티션이 없는 테이블은 NULL로 표시됨&lt;/li>
&lt;/ul>
&lt;h2 id="typejoin-유형">type(join 유형)
&lt;/h2>&lt;ul>
&lt;li>join type을 나타냄&lt;/li>
&lt;/ul>
&lt;h2 id="possible_keys">possible_keys
&lt;/h2>&lt;ul>
&lt;li>MySQL이 해당 테이블에서 데이터를 찾기위해 선택할 수 있는 인덱스를 보여줌&lt;/li>
&lt;li>EXPLAIN문과는 독립적이어서, possible_keys에 나타난 인덱스를 실제로 사용할 수 없을 수 있음&lt;/li>
&lt;li>해당 행이 NULL일경우 관련 인덱스가 없다는걸 난타냄
&lt;ul>
&lt;li>이 경우 WHERE절을 참고해 컬럼에 인덱스를 지정하여 쿼리 성능을 개선할 수 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="key">key
&lt;/h2>&lt;ul>
&lt;li>실제로 사용을 결정한 인덱스를 보여줌&lt;/li>
&lt;/ul>
&lt;h2 id="key_len">key_len
&lt;/h2>&lt;ul>
&lt;li>사용하기로 결정된 key의 길이를 나타냄&lt;/li>
&lt;/ul>
&lt;h2 id="ref">ref
&lt;/h2>&lt;ul>
&lt;li>key에서 선택된 인덱스와 비교되는 컬럼 또는 상수값을 나타냄&lt;/li>
&lt;/ul>
&lt;h2 id="rows">rows
&lt;/h2>&lt;ul>
&lt;li>MySQL이 해당 쿼리를 실행하기 위해 검사해야 한다고 생각되는 행의 수를 나타냄&lt;/li>
&lt;li>innodb의 경우 항상 추정치이며 정확하지 않을 수 있음&lt;/li>
&lt;/ul>
&lt;h2 id="filtered">filtered
&lt;/h2>&lt;ul>
&lt;li>테이블의 조건에 따라 필터링 되는 행의 수를 퍼센트로 나타낸것&lt;/li>
&lt;li>최대값은 100이며 필터링 되지 않은 것을 의미함&lt;/li>
&lt;/ul>
&lt;h2 id="extra">Extra
&lt;/h2>&lt;ul>
&lt;li>Mysql이 쿼리를 해결하는데 필요한 추가정보를 나타냄&lt;/li>
&lt;/ul>
&lt;p>Real Mysql 8.0&lt;br>
&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/explain-output.html&lt;/a>&lt;br>
&lt;a class="link" href="https://zzang9ha.tistory.com/436" target="_blank" rel="noopener"
>https://zzang9ha.tistory.com/436&lt;/a>&lt;/p></description></item><item><title>Mysql Connector j</title><link>https://sungho94.me/p/mysql-connector-j/</link><pubDate>Mon, 01 Apr 2024 23:04:47 +0000</pubDate><guid>https://sungho94.me/p/mysql-connector-j/</guid><description>&lt;ul>
&lt;li>
&lt;p>Java를 사용하는 어플리케이션에 mysql의 연결을 쉽게 하기 위해 개발됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>JDBC type 4 driver이며, JDBC 4.2 specification을 구현함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>mysql connector-j를 사용해서 커넥션을 얻고, 구문을 실행하여 5번째 컬럼의 문자열 결과를 얻어오는 코드는 아래와 같음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="nc">DriverManager&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getConnection&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;jdbc:mysql://localhost:3306/dreamStore&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s2">&amp;#34;root&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s2">&amp;#34;tjdgh123&amp;#34;&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">use&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="n">conn&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">conn&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">createStatement&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">use&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">statment&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">resultSet&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">statment&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">executeQuery&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;select * from product&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">resultSet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">()){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">resultSet&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getString&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Connection을 한번 생성하면 데이터베이스에서 메타데이터를 가져오기 위한, Statement객체와 PrepareStatement객체를 생성하는데 사용 가능함
&lt;ul>
&lt;li>select쿼리는 executeQuery(String)메서드를 사용해서 호출가능&lt;/li>
&lt;li>insert, update, delete쿼리는 executeUpdate(String)메서드를 사용해서 호출가능&lt;/li>
&lt;li>만약 쿼리가 조회 쿼리인지, 변경 쿼리인지 알 수 없다면, execute(String)을 사용하여 확인가능
&lt;ul>
&lt;li>데이터 조회 쿼리라면 true, 변경쿼리라면 false를 리턴함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Mysql Connection check query</title><link>https://sungho94.me/p/mysql-connection-check-query/</link><pubDate>Sun, 31 Mar 2024 22:41:00 +0000</pubDate><guid>https://sungho94.me/p/mysql-connection-check-query/</guid><description>&lt;ul>
&lt;li>커넥션 관련 쿼리&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-mysql" data-lang="mysql">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- 현재 mysql server에서 동시에 지원가능한 connection 가능 개수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">show&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%max_connections%&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- 서버가 시작된 후로 동시에 연결된 최대 connection 개수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">variable_name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Max_used_connections&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- 현저 서버에 연결된 connection 수
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">variable_name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Threads_connected&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>#MySQL&lt;/p></description></item><item><title>쿼리 실행 순서</title><link>https://sungho94.me/p/%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EC%88%9C%EC%84%9C/</link><pubDate>Mon, 19 Feb 2024 23:19:10 +0000</pubDate><guid>https://sungho94.me/p/%EC%BF%BC%EB%A6%AC-%EC%8B%A4%ED%96%89-%EC%88%9C%EC%84%9C/</guid><description>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-SQL" data-lang="SQL">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DISTINCT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">column&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">AGG_FUNC&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">_column_or_expression_&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">…&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mytable&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">another_table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">mytable&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">column&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">another_table&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">column&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_constraint_expression_&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">GROUP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">column&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">HAVING&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_constraint_expression_&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_column_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ASC&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">LIMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_count_&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">OFFSET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">_COUNT_&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="1-from-and-join">1. FROM and JOIN
&lt;/h2>&lt;ul>
&lt;li>전체 데이터 집합을 찾기 위해 FROM과 JOIN절이 먼저 실행됨&lt;/li>
&lt;li>서브쿼리가 있다면 JOIN될 데이터 테이블을 만들기 위해 임시 테이블을 생성할 수 있음&lt;/li>
&lt;/ul>
&lt;h2 id="2-where">2. WHERE
&lt;/h2>&lt;ul>
&lt;li>1에서 얻은 전체 데이터 집합의 각각의 row에 WHERE에 정의된 제약조건이 적용되고, 제약조건을 만족하지 않는 row는 버려짐&lt;/li>
&lt;li>FROM절에서 요청된 테이블의 열에만 접근 가능&lt;/li>
&lt;li>SELECT절의 Alias로 된 컬럼은 사용불가
&lt;ul>
&lt;li>아직 실행되지 않은 부분에 의해 값이 바뀔 수 있으므로 당장 처리하지 않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="3-group-by">3. GROUP BY
&lt;/h2>&lt;ul>
&lt;li>2에서 제약조건을 충족한 row들을 GROUB BY에 지정된 컬럼의 공통값으로 그룹화됨&lt;/li>
&lt;li>지정된 컬럼의 고유한 개수만큼 row가 생성됨&lt;/li>
&lt;/ul>
&lt;h2 id="4-having">4. HAVING
&lt;/h2>&lt;ul>
&lt;li>3에서 그룹화된 테이블은 2와 마찬가지로 제약조건을 적용하여 제약조건을 만족하지 않는 row는 버려짐&lt;/li>
&lt;li>2와 마찬가지로 Alias로된 컬럼은 사용 불가&lt;/li>
&lt;/ul>
&lt;h2 id="5-select">5. SELECT
&lt;/h2>&lt;ul>
&lt;li>SELECT부분의 모든 표현식이 최종적으로 계산됨&lt;/li>
&lt;/ul>
&lt;h2 id="6-distinct">6. DISTINCT
&lt;/h2>&lt;ul>
&lt;li>5에서나온 데이터에서 DISTINCT로 표시된 컬럼의 중복값이 제거됨&lt;/li>
&lt;/ul>
&lt;h2 id="7-order-by">7. ORDER BY
&lt;/h2>&lt;ul>
&lt;li>지정된 데이터를 따라 오름차순 또는 내림차순으로 정렬됨&lt;/li>
&lt;li>쿼리의 SELECT절이 수행되었으므로 SELECT의 Alias로 정렬 가능&lt;/li>
&lt;/ul>
&lt;h2 id="8-limit-offset">8. LIMIT, OFFSET
&lt;/h2>&lt;ul>
&lt;li>LIMIT 및 OFFSET으로 지정된 범위를 벗어나는 행은 삭제되고 최종 결과값만 남음&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://sqlbolt.com/lesson/select" target="_blank" rel="noopener"
>https://sqlbolt.com/lesson/select&lt;/a>_queries_order_of_execution&lt;/p>
&lt;p>#Database&lt;br>
#Query&lt;/p></description></item><item><title>버퍼풀 크기 확인 쿼리</title><link>https://sungho94.me/p/%EB%B2%84%ED%8D%BC%ED%92%80-%ED%81%AC%EA%B8%B0-%ED%99%95%EC%9D%B8-%EC%BF%BC%EB%A6%AC/</link><pubDate>Tue, 06 Feb 2024 16:25:30 +0000</pubDate><guid>https://sungho94.me/p/%EB%B2%84%ED%8D%BC%ED%92%80-%ED%81%AC%EA%B8%B0-%ED%99%95%EC%9D%B8-%EC%BF%BC%EB%A6%AC/</guid><description>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="n">InnoDB_buffer_pool_size&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>테이블 크기 확인할 쿼리</title><link>https://sungho94.me/p/%ED%85%8C%EC%9D%B4%EB%B8%94-%ED%81%AC%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%A0-%EC%BF%BC%EB%A6%AC/</link><pubDate>Tue, 06 Feb 2024 16:24:56 +0000</pubDate><guid>https://sungho94.me/p/%ED%85%8C%EC%9D%B4%EB%B8%94-%ED%81%AC%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%A0-%EC%BF%BC%EB%A6%AC/</guid><description>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;TableName&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ROUND&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">SUM&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data_length&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">index_length&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;All(MB)&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ROUND&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data_length&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Data(MB)&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">ROUND&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">index_length&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">1024&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;Index(MB)&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">information_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">tables&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">GROUP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">ORDER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">BY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">data_length&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DESC&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>mysqldmup</title><link>https://sungho94.me/p/mysqldmup/</link><pubDate>Mon, 29 Jan 2024 22:59:24 +0000</pubDate><guid>https://sungho94.me/p/mysqldmup/</guid><description>&lt;ul>
&lt;li>dms로 운영-&amp;gt;스테이지 디비 마이그레이션 하는데 인덱스가 사라져서 인덱스 추가를 위해 정보를 찾아보았다.&lt;/li>
&lt;li>직접 index를 넣어주는 방법과 AWS Schema Conversion Tool(AWS SCT)를 사용하는게 있었음&lt;/li>
&lt;li>macOS를 따로 지원하지 않아 mysqldump를 사용하여 스키마를 설정하기로함&lt;/li>
&lt;/ul>
&lt;h2 id="방법">방법
&lt;/h2>&lt;ul>
&lt;li>5.7.mysql_aurora.2.11.2 대상
&lt;ul>
&lt;li>mysql버전에 맞는 mysqldump가 필요&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>현재 로컬컴퓨터에 설치된 mysql버전과 대상 데이터베이스 버전이 다르다면 대상 데이터베이스 버전의 mysql-client 설치 필요&lt;/li>
&lt;/ul>
&lt;h3 id="데이터-덤프">데이터 덤프
&lt;/h3>&lt;ul>
&lt;li>데이터를 가져올 데이터베이스&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mysqldump -u [유저명] -P [포트] -h [호스트명] --no-data -p --databases [스키마명] &amp;gt; schema.sql
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="데이터-복구">데이터 복구
&lt;/h3>&lt;ul>
&lt;li>데이터를 넣을 데이터베이스&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mysql -u [유저명] -p -P [포트번호] -h [호스트명] &amp;lt; schema.sql
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">ERROR 1227 (42000) at line 1715: Access denied; you need (at least one of) the SUPER privilege(s) for this operation
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>이런 에러가 날 수 있다&lt;br>
해당 라인(예제에서는 1715라인)을 확인해서 삭제 or 주석처리 하거나 아래 링크를 참고하면 됨&lt;/p>
&lt;blockquote>
&lt;p>aws에서 제공하는 아래 가이드가 있는데 효과가 있지 않았음&lt;br>
&lt;a class="link" href="https://aws.amazon.com/ko/premiumsupport/knowledge-center/error-1227-mysqldump/" target="_blank" rel="noopener"
>https://aws.amazon.com/ko/premiumsupport/knowledge-center/error-1227-mysqldump/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="에러에-대한-정보">에러에 대한 정보
&lt;/h3>&lt;ul>
&lt;li>에러가 나는 라인은 아래 3줄이다&lt;/li>
&lt;li>언뜻 보면 세개의 변수에 특정값을 넣는건데 어떤 의미일까 찾아보았&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SET @MYSQLDUMP_TEMP_LOG_BIN = @@SESSION.SQL_LOG_BIN;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@SESSION.SQL_LOG_BIN= 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@GLOBAL.GTID_PURGED=&amp;#39;&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SET @MYSQLDUMP_TEMP_LOG_BIN = @@SESSION.SQL_LOG_BIN;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@SESSION.SQL_LOG_BIN= 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>먼저 이 두줄은 SESSION.SQL_LOG_BIN 변수를 수정하기 위한 옵션이다&lt;/li>
&lt;li>첫번째줄은 원래 설정으로 돌리기 위해 SESSION.SQL_LOG_BIN값을 MYSQLDUMP_TEMP_LOG_BIN에 임시로 저장한다&lt;/li>
&lt;li>두번째줄이 핵심인데 SESSION.SQL_LOG_BIN를 0, false값으로 변경한다&lt;/li>
&lt;li>sql_log_bin은 현재 세션에서 바이너리 로그에 대한 로깅을 활성화할지 여부를 제어&lt;/li>
&lt;li>off로 설정시 현재 세션에서 바이너리 로그를 로깅하지 않음
&lt;ul>
&lt;li>세션뿐만아니라 글로벌로 적용 가능&lt;/li>
&lt;li>sql_log_bin값을 변경하려면 SUPER권한이 필요한데 없어서 에러가 발생하는&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>GLOBAL.GTID_PURGED는 선행지식이 좀 필요해보여 넘김&lt;/p>
&lt;ul>
&lt;li>시간날때 더 공부해보자&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>에러 참고 링크&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/60320794/aws-rds-mysql-import-db-access-denied" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/60320794/aws-rds-mysql-import-db-access-denied&lt;/a>&lt;br>
&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/set-sql-log-bin.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/set-sql-log-bin.html&lt;/a>&lt;br>
&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-gtids.html#sysvar" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/replication-options-gtids.html#sysvar&lt;/a>_gtid_purged&lt;/p>
&lt;p>참고자료&lt;br>
&lt;a class="link" href="https://serverfault.com/questions/934879/copying-over-indexes-with-aws-dms" target="_blank" rel="noopener"
>https://serverfault.com/questions/934879/copying-over-indexes-with-aws-dms&lt;/a>&lt;br>
&lt;a class="link" href="https://www.lesstif.com/dbms/mysqldump-db-backup-load-17105804.html" target="_blank" rel="noopener"
>https://www.lesstif.com/dbms/mysqldump-db-backup-load-17105804.html&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/44015692/access-denied-you-need-at-least-one-of-the-super-privileges-for-this-operat" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/44015692/access-denied-you-need-at-least-one-of-the-super-privileges-for-this-operat&lt;/a>&lt;br>
&lt;a class="link" href="https://medium.com/@pushkarjoshi0410/solved-aws-rds-import-you-need-super-privilege-s-71e350b41989" target="_blank" rel="noopener"
>https://medium.com/@pushkarjoshi0410/solved-aws-rds-import-you-need-super-privilege-s-71e350b41989&lt;/a>&lt;/p></description></item><item><title>Database LSN</title><link>https://sungho94.me/p/database-lsn/</link><pubDate>Wed, 11 Oct 2023 23:20:55 +0000</pubDate><guid>https://sungho94.me/p/database-lsn/</guid><description>&lt;ul>
&lt;li>Log Sequence Number의 약자&lt;/li>
&lt;li>임의로 계속 증분하여 redo log에 저장됨&lt;/li>
&lt;li>체크포인트 발생시 어느 LSN까지 처리되었는지 알려줌&lt;/li>
&lt;li>로그 복구시 LSN으로 실행여부를 알 수 있음&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.percona.com/blog/mvcc-transaction-ids-log-sequence-numbers-and-snapshots/" target="_blank" rel="noopener"
>https://www.percona.com/blog/mvcc-transaction-ids-log-sequence-numbers-and-snapshots/&lt;/a>&lt;br>
&lt;a class="link" href="https://dba.stackexchange.com/questions/45716/what-is-log-sequence-number-how-it-is-used-in-mysql" target="_blank" rel="noopener"
>https://dba.stackexchange.com/questions/45716/what-is-log-sequence-number-how-it-is-used-in-mysql&lt;/a>&lt;br>
&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/glossary.html&lt;/a>&lt;/p>
&lt;p>#InnoDB&lt;/p></description></item><item><title>Database Check point</title><link>https://sungho94.me/p/database-check-point/</link><pubDate>Wed, 11 Oct 2023 22:26:05 +0000</pubDate><guid>https://sungho94.me/p/database-check-point/</guid><description>&lt;ul>
&lt;li>데이터베이스는 성능상의 이유로 매 변경마다 데이터를 디스크에 쓰는게 아닌 메모리에 기록함&lt;/li>
&lt;li>이후 주기적으로 메모리에 있는 데이터를 디스크에 저장하는데, 성공적으로 디스크에 저장된 최신의 레코드가 체크포인트임&lt;/li>
&lt;li>이 체크포인트는 성공적으로 저장된 것이므로 체크포인트 장애나 충돌로 인한 복구시 체크포인트 이후의 로그를 사용하여 복구하면 시간이 단축됨&lt;/li>
&lt;li>레코드 뿐만 아니라 트랜잭션 정보도 저장함&lt;/li>
&lt;/ul>
&lt;h2 id="check-point-recovery-방법">check point recovery 방법
&lt;/h2>&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231011230739.png"
loading="lazy"
alt="Pasted image 20231011230739"
>&lt;/p>
&lt;ul>
&lt;li>위 상황에서 T1, T2, T3는 redo list에 저장되고, T4는 undo list에 저장되어있음&lt;/li>
&lt;li>해당 리스트에서 데이터를 재생하면됨&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>데이터베이스는 T4에서 T1순으로 읽음&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos&lt;/a>_checkpoint&lt;br>
&lt;a class="link" href="https://learn.microsoft.com/en-us/sql/relational-databases/logs/database-checkpoints-sql-server?view=sql-server-ver16" target="_blank" rel="noopener"
>https://learn.microsoft.com/en-us/sql/relational-databases/logs/database-checkpoints-sql-server?view=sql-server-ver16&lt;/a>&lt;/p>
&lt;p>#Database&lt;br>
#InnoDB&lt;/p></description></item><item><title>mysql 프로세스 리스트 보기</title><link>https://sungho94.me/p/mysql-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%B3%B4%EA%B8%B0/</link><pubDate>Fri, 06 Oct 2023 23:30:28 +0000</pubDate><guid>https://sungho94.me/p/mysql-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EB%B3%B4%EA%B8%B0/</guid><description>&lt;p>select * from information_schema.PROCESSLIST;&lt;/p>
&lt;p>&lt;img src="https://sungho94.me/image/real-resource-image/Pasted%20image%2020231007162016.png"
loading="lazy"
alt="Pasted image 20231007162016"
>&lt;/p>
&lt;h3 id="id">ID
&lt;/h3>&lt;ul>
&lt;li>connection의 식별자&lt;/li>
&lt;/ul>
&lt;h3 id="user">USER
&lt;/h3>&lt;ul>
&lt;li>해당 구문을 실행한 유저&lt;/li>
&lt;li>event_schduler는 예약된 이벤트를 모니터링하는 스레드&lt;/li>
&lt;/ul>
&lt;h3 id="host">HOST
&lt;/h3>&lt;ul>
&lt;li>해당 구문을 실행한 호스트명&lt;/li>
&lt;/ul>
&lt;h3 id="db">DB
&lt;/h3>&lt;ul>
&lt;li>해당 스레드가 선택한 데이터베이스&lt;/li>
&lt;/ul>
&lt;h3 id="command">COMMAND
&lt;/h3>&lt;ul>
&lt;li>실행하는 명령의 유형&lt;/li>
&lt;li>sleep - 클라이언트에게 새로운 구문을 받기위해 대기하는 상태&lt;/li>
&lt;li>query - 쿼리를 실행중인 상태&lt;/li>
&lt;li>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/thread-commands.html" target="_blank" rel="noopener"
>상태 참고 링크&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="time">TIME
&lt;/h2>&lt;ul>
&lt;li>쓰레드가 현재 상태에 있던 시간&lt;/li>
&lt;li>초단위&lt;/li>
&lt;/ul>
&lt;h3 id="state">STATE
&lt;/h3>&lt;ul>
&lt;li>스레드가 수행 중인 작업, 이벤트의 상태입니다&lt;/li>
&lt;li>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/general-thread-states.html" target="_blank" rel="noopener"
>참고 링크&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="info">INFO
&lt;/h3>&lt;ul>
&lt;li>쓰레드가 실행하고있는 구문을 보여줌&lt;/li>
&lt;li>nll일 때는 구문을 실행하고 있지 않다는것&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/information-schema-processlist-table.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/information-schema-processlist-table.html&lt;/a>&lt;/p>
&lt;p>#Database&lt;br>
#Query&lt;br>
#Trouble-Shooting&lt;/p></description></item><item><title>mysql 락걸린 쿼리 확인</title><link>https://sungho94.me/p/mysql-%EB%9D%BD%EA%B1%B8%EB%A6%B0-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8/</link><pubDate>Fri, 06 Oct 2023 23:29:37 +0000</pubDate><guid>https://sungho94.me/p/mysql-%EB%9D%BD%EA%B1%B8%EB%A6%B0-%EC%BF%BC%EB%A6%AC-%ED%99%95%EC%9D%B8/</guid><description>&lt;p>mysql 8.0&lt;br>
select * from performance_schema.data_locks;&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-locks-table.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/performance-schema-data-locks-table.html&lt;/a>&lt;/p>
&lt;ul>
&lt;li>테이블에 대한 설명&lt;/li>
&lt;/ul>
&lt;p>mysql 5.7&lt;br>
select * from information_schema.InnoDB_LOCKS;&lt;/p>
&lt;p>#Database&lt;br>
#Query&lt;br>
#lock&lt;br>
#Trouble-Shooting&lt;br>
#InnoDB&lt;/p></description></item><item><title>정규화 역정규화</title><link>https://sungho94.me/p/%EC%A0%95%EA%B7%9C%ED%99%94-%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94/</link><pubDate>Thu, 05 Oct 2023 23:22:05 +0000</pubDate><guid>https://sungho94.me/p/%EC%A0%95%EA%B7%9C%ED%99%94-%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94/</guid><description>&lt;h2 id="정규화">정규화
&lt;/h2>&lt;ul>
&lt;li>정규화를 많이하면 join을 많이해야 함으로 성능저하가 올 수 있음&lt;/li>
&lt;li>적게하면 확장성이 떨어짐&lt;/li>
&lt;/ul>
&lt;h3 id="고려해야-할점">고려해야 할점
&lt;/h3>&lt;ul>
&lt;li>부모-자식관계에서 부모가 삭제되었을때 삭제되어야 하는데이터인지 확인&lt;/li>
&lt;li>변경되었을때 같이 변경되어야 하는 데이터인지 고민할것&lt;/li>
&lt;li>위 2개의상황에서는 정규화 해서는 안됨&lt;/li>
&lt;/ul>
&lt;h2 id="역정규화">역정규화
&lt;/h2>&lt;ul>
&lt;li>join을 적게하여 성능을 향상을 이룰 수 있음&lt;/li>
&lt;li>중복되는 데이터 저장&lt;/li>
&lt;/ul>
&lt;p>#Database&lt;/p></description></item><item><title>그룹별 순위 가져오기</title><link>https://sungho94.me/p/%EA%B7%B8%EB%A3%B9%EB%B3%84-%EC%88%9C%EC%9C%84-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/</link><pubDate>Wed, 04 Oct 2023 22:57:58 +0000</pubDate><guid>https://sungho94.me/p/%EA%B7%B8%EB%A3%B9%EB%B3%84-%EC%88%9C%EC%9C%84-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/</guid><description>&lt;p>가져오는 그룹 컬럼이 1개일떄&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mysql 5.7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT name, year, month FROM (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT *, IF(@prev &amp;lt;&amp;gt; name, @rn:=0,@rn), @prev:=name, @rn:=@rn+1 AS rn
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM example, (SELECT @rn:=0) rn, (SELECT @prev:=&amp;#39;&amp;#39;) prev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ORDER BY name ASC, year DESC, month DESC
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">) t WHERE rn &amp;lt;= 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysql 8.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT name, year, month FROM (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT name, year, month,
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ROW_NUMBER() OVER (PARTITION BY name ORDER BY year DESC, month DESC) AS rn
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM example
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">) t WHERE rn &amp;lt;= 2;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>가져오는 그룹 컬럼이 1개일떄&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">mysql 5.7
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT name, year, month FROM (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT *, IF(@prev &amp;lt;&amp;gt; name + year, @rn:=0,@rn), @prev:=name + year, @rn:=@rn+1 AS rn
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM example, (SELECT @rn:=0)rn, (SELECT @prev:=&amp;#39;&amp;#39;)prev
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> ORDER BY name ASC, year DESC, month DESC
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">)t WHERE rn &amp;lt;= 2;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Using MySQL 8.0 with ROW_NUMBER:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">mysql 8.0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT name, year, month FROM (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> SELECT name, year, month, ROW_NUMBER() OVER (PARTITION BY name, year ORDER BY year DESC, month DESC) AS rn
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> FROM example
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;a class="link" href="https://stackoverflow.com/questions/58645949/emulating-partition-over-with-mysql-5-7" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/58645949/emulating-partition-over-with-mysql-5-7&lt;/a>&lt;/p>
&lt;p>#Database&lt;br>
#Query&lt;/p></description></item><item><title>Count(*) vs Count(Column)</title><link>https://sungho94.me/p/count-vs-countcolumn/</link><pubDate>Tue, 03 Oct 2023 23:20:03 +0000</pubDate><guid>https://sungho94.me/p/count-vs-countcolumn/</guid><description>&lt;ul>
&lt;li>테이블의 전체 개수를 얻기 위해 Count()과 Count(Column)를 사용할때는 Count(_)가 성능적으로 더 좋음&lt;/li>
&lt;li>Count를 할때는 null값을 확인한 후 null이 아닌 개수만 리턴하는데, Count(Column)을 하게되면 Column의 null체크를 하기때문에 성능 저하가 발생함,&lt;/li>
&lt;li>전체개수를 파악하기 위해서는 Count(*)을 사용하자&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://m.blog.naver.com/pjt3591oo/221030483713" target="_blank" rel="noopener"
>https://m.blog.naver.com/pjt3591oo/221030483713&lt;/a>&lt;/p>
&lt;p>#Database&lt;br>
#Query-turning&lt;/p></description></item><item><title>DB PK 자연키 vs 대체키</title><link>https://sungho94.me/p/db-pk-%EC%9E%90%EC%97%B0%ED%82%A4-vs-%EB%8C%80%EC%B2%B4%ED%82%A4/</link><pubDate>Tue, 03 Oct 2023 09:59:31 +0000</pubDate><guid>https://sungho94.me/p/db-pk-%EC%9E%90%EC%97%B0%ED%82%A4-vs-%EB%8C%80%EC%B2%B4%ED%82%A4/</guid><description>&lt;h3 id="pk">PK
&lt;/h3>&lt;ul>
&lt;li>테이블에서 하나의 로우를 식별할 수 있는 최소 집합&lt;/li>
&lt;li>유일성
&lt;ul>
&lt;li>row마다 유일한 값을 가져야함&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>안정성
&lt;ul>
&lt;li>변경되지 않아야됨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="자연키">자연키
&lt;/h3>&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>사람이 이해하기 쉬움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>잘 설계하지 않는다면 중복의 위험이 있음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="대체키">대체키
&lt;/h3>&lt;ul>
&lt;li>장점
&lt;ul>
&lt;li>중복되지않음&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>단점
&lt;ul>
&lt;li>의미없는 키값이라 한눈에 파악하기 어려움&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>항상 대체키만 써왔고, &amp;lsquo;자연키를 쓰면 안될까&amp;rsquo;라는 생각을 종종 했었다.&lt;br>
중복의 위험이 있고, 이로인해 기본키를 바꿔야 한다는 상황이 개인적으로 자연키의 가장 위험한 점이라 생각되고, 대체키를 쓰는게 더 안전할 것이라는 확실한 생각이 들었다.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;blockquote>
&lt;p>하지만 잘 설계한다면 대체키를 사용하면 좋을거같다&lt;br>
설계를 잘못하면 바뀌야한다는 위험성 때문에 도전하지 못한다면 아무것도 도전하지 못한다&lt;br>
자연키를 사용할 만한 상황이 나온다면 사용해보자!&lt;/p>
&lt;/blockquote>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://vertabelo.com/blog/primary-key/" target="_blank" rel="noopener"
>https://vertabelo.com/blog/primary-key/&lt;/a>&lt;/p>
&lt;p>#Database&lt;br>
#Definition&lt;/p></description></item><item><title>Sargable query</title><link>https://sungho94.me/p/sargable-query/</link><pubDate>Tue, 03 Oct 2023 09:58:50 +0000</pubDate><guid>https://sungho94.me/p/sargable-query/</guid><description>&lt;ul>
&lt;li>&amp;lsquo;Search Argument-able&amp;rsquo;의 약자&lt;/li>
&lt;li>DBMS 엔진이 인덱스를 활용해서 실행 속도를 높일 수 있는 쿼리를 말함&lt;/li>
&lt;li>연산자&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SARGable predicates include the following operators
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">=, &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, IN, BETWEEN, and LIKE (in the case of prefix matching)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Non-SARGable operators include
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">NOT, NOT IN, &amp;lt;&amp;gt;, and LIKE
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>컬럼을 함수로 감싸지 않은것&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Bad: Select ... WHERE isNull(FullName,&amp;#39;Ed Jones&amp;#39;) = &amp;#39;Ed Jones&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Fixed: Select ... WHERE ((FullName = &amp;#39;Ed Jones&amp;#39;) OR (FullName IS NULL))
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Bad: Select ... WHERE SUBSTRING(DealerName,4) = &amp;#39;Ford&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Fixed: Select ... WHERE DealerName Like &amp;#39;Ford%&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Bad: Select ... WHERE DateDiff(mm,OrderDate,GetDate()) &amp;gt;= 30
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Fixed: Select ... WHERE OrderDate &amp;lt; DateAdd(mm,-30,GetDate())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>생각해보면 간단한듯! 컬럼에 함수를 씌우면 컬럼마다 함수를 실행해야하니 속도가 느려짐&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://en.wikipedia.org/wiki/Sargable" target="_blank" rel="noopener"
>https://en.wikipedia.org/wiki/Sargable&lt;/a>&lt;br>
&lt;a class="link" href="https://stackoverflow.com/questions/799584/what-makes-a-sql-statement-sargable" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/799584/what-makes-a-sql-statement-sargable&lt;/a>&lt;/p>
&lt;p>#Query-turning&lt;/p></description></item><item><title>Cardinality</title><link>https://sungho94.me/p/cardinality/</link><pubDate>Mon, 02 Oct 2023 23:32:28 +0000</pubDate><guid>https://sungho94.me/p/cardinality/</guid><description>&lt;ul>
&lt;li>각각의 컬럼들은 요구사항에 따라 카디널리티가 다름&lt;/li>
&lt;li>카디널리티가 높다
&lt;ul>
&lt;li>모든 값들이 다를때&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>카디널리티가 낮다
&lt;ul>
&lt;li>모든 값들이 같을때&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>여러 컬럼을 인덱스로 만들때, 카디널리티가 높은순에서 낮은순으로 설정할것
&lt;ul>
&lt;li>필터링 되는 숫자가 다르기 때문&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>카디널리티는 데이터베이스가 정렬하거나, 검색시 성능에 영향을 끼침기에 데이터베이스가 최적의 플랜을 짜기한 중요한 요소임&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>인덱스는 데이터베이스에서 어떤 요소를 빨리 찾기 위한 자료구조임&lt;br>
카디널리티가 낮은 컬럼을 인덱스로 잡는다면 하나의 인덱스에 많은 데이터가 있을것이고&lt;br>
카디널리티가 높은 컬럼을 인덱스로 잡는다면 하나의 인덱스에 적인 데이터가 있겠지?&lt;br>
이런것들을 고려해서 인덱스로 잡으면 좋겠다!&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://stackoverflow.com/questions/2566211/what-is-cardinality-in-mysql" target="_blank" rel="noopener"
>https://stackoverflow.com/questions/2566211/what-is-cardinality-in-mysql&lt;/a>&lt;br>
&lt;a class="link" href="https://learn.microsoft.com/en-us/sql/relational-databases/performance/cardinality-estimation-sql-server?view=sql-server-ver16" target="_blank" rel="noopener"
>https://learn.microsoft.com/en-us/sql/relational-databases/performance/cardinality-estimation-sql-server?view=sql-server-ver16&lt;/a>&lt;/p>
&lt;p>#Database&lt;br>
#Definition&lt;/p></description></item><item><title>Clustered Index, non-Clustered Index</title><link>https://sungho94.me/p/clustered-index-non-clustered-index/</link><pubDate>Mon, 02 Oct 2023 23:31:55 +0000</pubDate><guid>https://sungho94.me/p/clustered-index-non-clustered-index/</guid><description>&lt;p>테이블에 대한 색인을 만들때,&lt;br>
해당하는 색인에 데이터를 같이 놓는다면, 색인을 찾은 후 바로 데이터를 가져올 수 있습니다&lt;br>
색인과 테이블을 따로 만들면 색인 에있는 데이터의 위치를 가지고 다시 데이터를 찾아야합니다&lt;/p>
&lt;p>색인이 여러개일때 색인과 데이터를 같이 놓는다면 데이터의 중복이 발생하고, 읽기 성능은 좋아지겠지만 쓰기성능이 저하됩니다.&lt;br>
그래서 하나의 색인에만 데이터를 같이놓고(clustered index), 다른색인에는 색인과 데이터의 위치(non-clutered-index)를 가지고 있습니다ㅇ&lt;/p>
&lt;p>index는 key-value 구조로, key는 index의 값입니다.&lt;br>
value는 clustered index에서는 해당하는 데이터값(row)이고 non-clutered-index의 값은 해당하는 clustered index의 키값입니다&lt;br>
clustered Index의 값이 길면, non-clutered-index는 각 인덱스마다 긴 clutered-index를 가져야해서 저장공간이 늘어 좋지않습니다&lt;/p>
&lt;h2 id="clustering-index">Clustering Index
&lt;/h2>&lt;ul>
&lt;li>데이터가 물리적으로 저장될떄 정렬 방식을 정의&lt;/li>
&lt;li>테이블당 하나만 존재 가능&lt;/li>
&lt;li>기본키 제약조건이 걸린 컬럼에 자동으로 생성됨&lt;/li>
&lt;/ul>
&lt;h2 id="non-clustering-index">non-Clustering Index
&lt;/h2>&lt;ul>
&lt;li>데이터를 물리적으로 정렬하지 않음&lt;/li>
&lt;li>테이블과 다른 물리적 공간에 저장됨&lt;/li>
&lt;li>테이블에 여러개가 존재 가능&lt;/li>
&lt;li>유니크 제약조건에 걸린 컬럼에 자동으로 적용됨&lt;/li>
&lt;li>너무 많이 생성시 생성, 수정, 삭제의 오버헤드가 커짐&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://www.sqlshack.com/what-is-the-difference-between-clustered-and-non-clustered-indexes-in-sql-server/" target="_blank" rel="noopener"
>https://www.sqlshack.com/what-is-the-difference-between-clustered-and-non-clustered-indexes-in-sql-server/&lt;/a>&lt;br>
&lt;a class="link" href="https://learn.microsoft.com/ko-kr/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-ver16" target="_blank" rel="noopener"
>https://learn.microsoft.com/ko-kr/sql/relational-databases/indexes/clustered-and-nonclustered-indexes-described?view=sql-server-ver16&lt;/a>&lt;br>
&lt;a class="link" href="https://gwang920.github.io/database/clusterednonclustered/" target="_blank" rel="noopener"
>https://gwang920.github.io/database/clusterednonclustered/&lt;/a>&lt;br>
&lt;a class="link" href="https://mozi.tistory.com/320" target="_blank" rel="noopener"
>https://mozi.tistory.com/320&lt;/a>&lt;br>
&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/InnoDB-index-types.html" target="_blank" rel="noopener"
>https://dev.mysql.com/doc/refman/8.0/en/InnoDB-index-types.html&lt;/a>&lt;/p>
&lt;p>#InnoDB&lt;/p></description></item><item><title>Covering Indexes(커버링 인덱스)</title><link>https://sungho94.me/p/covering-indexes%EC%BB%A4%EB%B2%84%EB%A7%81-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</link><pubDate>Mon, 02 Oct 2023 23:30:52 +0000</pubDate><guid>https://sungho94.me/p/covering-indexes%EC%BB%A4%EB%B2%84%EB%A7%81-%EC%9D%B8%EB%8D%B1%EC%8A%A4/</guid><description>&lt;ul>
&lt;li>하나의 쿼리의 전체 요구사항이 인덱스인 상황&lt;/li>
&lt;li>커버링 인덱스를 활용하므로서 실제 테이블에 접근하지 않고, Index tree만 검색 후 결과를 리턴&lt;/li>
&lt;li>실제 테이블을 접근하지 않음으로 속도가 매우 빠름&lt;/li>
&lt;li>출력되어야 하는 값까지 모두 인덱스일경우&lt;/li>
&lt;/ul>
&lt;p>&lt;a class="link" href="https://planetscale.com/learn/courses/mysql-for-developers/indexes/covering-indexes" target="_blank" rel="noopener"
>https://planetscale.com/learn/courses/mysql-for-developers/indexes/covering-indexes&lt;/a>&lt;br>
&lt;a class="link" href="https://www.sqler.com/board_SQLQA/707203" target="_blank" rel="noopener"
>https://www.sqler.com/board_SQLQA/707203&lt;/a>&lt;/p>
&lt;p>#Database&lt;/p></description></item><item><title>DB 날려먹었을때 복구방법</title><link>https://sungho94.me/p/db-%EB%82%A0%EB%A0%A4%EB%A8%B9%EC%97%88%EC%9D%84%EB%95%8C-%EB%B3%B5%EA%B5%AC%EB%B0%A9%EB%B2%95/</link><pubDate>Sun, 17 Sep 2023 22:31:08 +0000</pubDate><guid>https://sungho94.me/p/db-%EB%82%A0%EB%A0%A4%EB%A8%B9%EC%97%88%EC%9D%84%EB%95%8C-%EB%B3%B5%EA%B5%AC%EB%B0%A9%EB%B2%95/</guid><description>&lt;p>MySQL .ibd 파일을 이용하여 데이터 복구하기&lt;br>
&lt;a class="link" href="https://puleugo.tistory.com/167" target="_blank" rel="noopener"
>https://puleugo.tistory.com/167&lt;/a>&lt;/p>
&lt;p>MySQL binlog를 이용하여 데이터 복구하기&lt;br>
&lt;a class="link" href="https://puleugo.tistory.com/168" target="_blank" rel="noopener"
>https://puleugo.tistory.com/168&lt;/a>&lt;/p>
&lt;p>#Database&lt;/p></description></item><item><title>쿼리 튜닝시</title><link>https://sungho94.me/p/%EC%BF%BC%EB%A6%AC-%ED%8A%9C%EB%8B%9D%EC%8B%9C/</link><pubDate>Sun, 17 Sep 2023 22:26:20 +0000</pubDate><guid>https://sungho94.me/p/%EC%BF%BC%EB%A6%AC-%ED%8A%9C%EB%8B%9D%EC%8B%9C/</guid><description>&lt;p>쿼리튜닝에서 젤 먼저 우선시 되어야하는건 서비스 특성과 요구사항을 이해하는게 중요합니다. 만약에 꼭 하신다고 하면 본인 서비스가 어떤 특성을 갖고 데이터가 어떤 형태를 띄는지 부터 정리 해놓으셔야 합니다.&lt;/p>
&lt;p>#Database&lt;/p></description></item></channel></rss>